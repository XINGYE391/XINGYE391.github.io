<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java基础 | XINGYE's Blog</title><meta name="keywords" content="Java"><meta name="author" content="XINGYE"><meta name="copyright" content="XINGYE"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Java基础笔记汇总">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="https://blog.xing-ye.top/posts/Java/index.html">
<meta property="og:site_name" content="XINGYE&#39;s Blog">
<meta property="og:description" content="Java基础笔记汇总">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xingye-blog.s3.bitiful.net/2024/06/5490fa80bad8d791ba9122e9008952ee.webp">
<meta property="article:published_time" content="2024-02-08T16:00:00.000Z">
<meta property="article:modified_time" content="2024-06-23T10:12:37.709Z">
<meta property="article:author" content="XINGYE">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xingye-blog.s3.bitiful.net/2024/06/5490fa80bad8d791ba9122e9008952ee.webp"><link rel="shortcut icon" href="https://xingye-blog.s3.bitiful.net/favicon.webp"><link rel="canonical" href="https://blog.xing-ye.top/posts/Java/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: XINGYE","link":"链接: ","source":"来源: XINGYE's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-23 18:12:37'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link rel="stylesheet" href="https://cdn2.codesign.qq.com/icons/XMx86jzlQw0brz3/latest/iconfont.css"><script type="text/javascript" src="https://js.users.51.la/21883845.js"></script><meta name="baidu-site-verification" content="codeva-vSV8D700jj" /><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="XINGYE's Blog" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/avatar.webp" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 建站日志</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/footprint/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zuji">                   </use></svg><span class="menu_word" style="font-size:17px"> 足迹</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/essay/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 哔哔</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XINGYE's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 建站日志</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/footprint/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zuji">                   </use></svg><span class="menu_word" style="font-size:17px"> 足迹</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/essay/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 哔哔</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toRandomPost()" title="随机前往一篇文章" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-suiji"></use></svg></a><a class="meihua faa-parent animated-hover" onclick="travel()" title="开往-友链接力" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-bus"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">Java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2024-02-08T16:00:00.000Z" title="发表于 2024-02-09 00:00:00">2024-02-09</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-23T10:12:37.709Z" title="更新于 2024-06-23 18:12:37">2024-06-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">7w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>271分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>在此感谢黑马程序员的<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Cv411372m/?p=92&amp;vd_source=39cd09fae5d0f121c16eee7c134119f6">视频教程</a>！</p>
</blockquote>
<h1 id="面向对象高级（一）">面向对象高级（一）</h1>
<h2 id="一、静态">一、静态</h2>
<h3 id="1-1-static修饰成员变量">1.1 static修饰成员变量</h3>
<p>Java中的成员变量按照有无static修饰分为两种：<strong>类变量、实例变量</strong>。它们的区别如下图所示：</p>
<p><img src="https://s2.loli.net/2024/05/05/OufzceRlmdq8ZFa.webp" alt="1663977705413"></p>
<p>由于静态变量是属于类的，只需要通过类名就可以调用：<strong><code>类名.静态变量</code></strong></p>
<p>实例变量是属于对象的，需要通过对象才能调用：<strong><code>对象.实例变量</code></strong></p>
<ul>
<li>代码的内存原理</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/05/bqdCTxtkg6J4HsF.webp" alt="1663978808670"></p>
<ul>
<li><strong>最后总结一下</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="number">1.</span>类变量：属于类，在内存中只有一份，用类名调用</span><br><span class="line">- <span class="number">2.</span>实例变量：属于对象，每一个对象都有一份，用对象调用</span><br></pre></td></tr></table></figure>
<h3 id="1-2-static修饰成员变量的应用场景">1.2 static修饰成员变量的应用场景</h3>
<p>在实际开发中，如果某个数据只需要一份，且希望能够被共享（访问、修改），则该数据可以定义成员变量来记住。</p>
<blockquote>
<p><strong>我们看一个案例</strong></p>
<p>需求：系统启动后，要求用于类可以记住自己创建了多少个用户对象。**</p>
</blockquote>
<ul>
<li>第一步：先定义一个<code>User</code>类，在用户类中定义一个static修饰的变量，用来表示在线人数；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> number;</span><br><span class="line">    <span class="comment">//每次创建对象时，number自增一下</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span>&#123;</span><br><span class="line">        User.number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二步：再写一个测试类，再测试类中创建4个User对象，再打印number的值，观察number的值是否再自增。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建4个对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">User</span>(); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//查看系统创建了多少个User对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;系统创建的User对象个数：&quot;</span>+User.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，查看执行结果是：<strong><code>系统创建的User对象个数：4</code></strong></p>
<h3 id="1-3-static修饰成员方法">1.3 static修饰成员方法</h3>
<ul>
<li>成员方法根据有无static也分为两类：<strong>类方法、实例方法</strong></li>
</ul>
<p><img src="https://s2.loli.net/2024/05/05/JWyUO7u6dkleCgB.webp" alt="1664004813041"></p>
<blockquote>
<p>有static修饰的方法，是属于类的，称为<strong>类方法</strong>；调用时直接用类名调用即可。</p>
</blockquote>
<blockquote>
<p>无static修饰的方法，是属于对象的，称为实例方法；调用时，需要使用对象调用。</p>
</blockquote>
<p>我们看一个案例，演示类方法、实例方法的基本使用</p>
<ul>
<li>先定义一个Student类，在类中定义一个类方法、定义一个实例方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类方法：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> printHelloWorld&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实例方法（对象的方法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printPass</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//打印成绩是否合格</span></span><br><span class="line">        System.out.println(score&gt;=<span class="number">60</span>?<span class="string">&quot;成绩合格&quot;</span>:<span class="string">&quot;成绩不合格&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在定义一个测试类，注意类方法、对象方法调用的区别</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//1.调用Student类中的类方法</span></span><br><span class="line">        Student.printHelloWorld();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.调用Student类中的实例方法</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();        </span><br><span class="line">        s.printPass();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用对象也能调用类方法【不推荐，IDEA连提示都不给你，你就别这么用了】</span></span><br><span class="line">        s.printHelloWorld();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>static修饰成员方法的内存原理。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">.类方法：static修饰的方法，可以被类名调用，是因为它是随着类的加载而加载的；</span></span><br><span class="line">		 <span class="string">所以类名直接就可以找到static修饰的方法</span></span><br><span class="line">		 </span><br><span class="line"><span class="number">2</span><span class="string">.实例方法：非static修饰的方法，需要创建对象后才能调用，是因为实例方法中可能会访问实例变量，而实例变量需要创建对象后才存在。所以实例方法，必须创建对象后才能调用。</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/05/05/UrOqLDZv3kz6osR.webp" alt="1664005554987"></p>
<h3 id="1-4-工具类">1.4 工具类</h3>
<p>如果一个类中的方法全都是静态的，那么这个类中的方法就全都可以被类名直接调用，由于调用起来非常方便，就像一个工具一下，所以把这样的类就叫做工具类。</p>
<ul>
<li>我们写一个生成验证码的工具类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUtils</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createCode</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">//1.定义一个字符串，用来记录产生的验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.验证码是由所有的大写字母、小写字母或者数字字符组成</span></span><br><span class="line">        <span class="comment">//这里先把所有的字符写成一个字符串，一会从字符串中随机找字符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.循环n次，产生n个索引,再通过索引获取字符</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> r.nextInt(data.length());</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> data.charAt(index);</span><br><span class="line">            <span class="comment">//4.把获取到的字符，拼接到code验证码字符串上。</span></span><br><span class="line">            code+=ch;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最后返回code,code的值就是验证码</span></span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接着可以在任何位置调用<code>MyUtils</code>的<code>createCOde()方法</code>产生任意个数的验证码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如这是一个登录界面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(MyUtils.createCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如这是一个注册界面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">registerDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(MyUtils.createCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在补充一点，工具类里的方法全都是静态的，推荐用类名调用为了防止使用者用对象调用。我们可以把工具类的构造方法私有化。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUtils</span>&#123;</span><br><span class="line">    <span class="comment">//私有化构造方法：这样别人就不能使用构造方法new对象了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MyUtils</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createCode</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-static的注意事项">1.5 static的注意事项</h3>
<p><img src="https://s2.loli.net/2024/05/05/EpzH64qP9i8aQDG.webp" alt="1664007168869"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> String schoolName; <span class="comment">// 类变量</span></span><br><span class="line">    <span class="type">double</span> score; <span class="comment">// 实例变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、类方法中可以直接访问类的成员，不可以直接访问实例成员。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printHelloWorld</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 注意：同一个类中，访问类成员，可以省略类名不写。</span></span><br><span class="line">        schoolName = <span class="string">&quot;学校&quot;</span>;</span><br><span class="line">        printHelloWorld2();</span><br><span class="line"></span><br><span class="line">        System.out.println(score); <span class="comment">// 报错的</span></span><br><span class="line">        printPass(); <span class="comment">// 报错的</span></span><br><span class="line"></span><br><span class="line">        ystem.out.println(<span class="built_in">this</span>); <span class="comment">// 报错的</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 类方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printHelloWorld2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printPass2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="comment">// 2、实例方法中既可以直接访问类成员，也可以直接访问实例成员。</span></span><br><span class="line">    <span class="comment">// 3、实例方法中可以出现this关键字，类方法中不可以出现this关键字的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printPass</span><span class="params">()</span>&#123;</span><br><span class="line">        schoolName = <span class="string">&quot;学校2&quot;</span>; <span class="comment">//对的</span></span><br><span class="line">        printHelloWorld2(); <span class="comment">//对的</span></span><br><span class="line"></span><br><span class="line">        System.out.println(score); <span class="comment">//对的</span></span><br><span class="line">        printPass2(); <span class="comment">//对的</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="built_in">this</span>); <span class="comment">//对的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-static应用（代码块）">1.6 static应用（代码块）</h3>
<p>代码块根据有无static修饰分为两种：静态代码块、实例代码块</p>
<blockquote>
<p><strong>静态代码块：</strong></p>
</blockquote>
<p><img src="https://s2.loli.net/2024/05/05/quBOeLkPx9r7vMT.webp" alt="1664007549583"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">schoolName</span> <span class="operator">=</span> <span class="string">&quot;黑马&quot;</span>;</span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了~~&quot;</span>);</span><br><span class="line">        schoolName = <span class="string">&quot;黑马&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态代码块不需要创建对象就能够执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：认识两种代码块，了解他们的特点和基本作用。</span></span><br><span class="line">        System.out.println(Student.number);</span><br><span class="line">        System.out.println(Student.number);</span><br><span class="line">        System.out.println(Student.number);</span><br><span class="line"></span><br><span class="line">        System.out.println(Student.schoolName); <span class="comment">// 黑马</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上面代码时，发现没有创建对象，静态代码块就已经执行了。</p>
<p><img src="https://s2.loli.net/2024/05/05/rcuwnIRQD12U4mJ.webp" alt="1664007747151"></p>
<p>关于静态代码块重点注意：<strong>静态代码块，随着类的加载而执行，而且只执行一次。</strong></p>
<blockquote>
<p><strong>实例代码块</strong></p>
</blockquote>
<p><img src="https://s2.loli.net/2024/05/05/hK74tlJzo1ZuvVr.webp" alt="1664008215853"></p>
<p>实例代码块的作用和构造器的作用是一样的，用来给对象初始化值；而且每次创建对象之前都会先执行实例代码块。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//实例代码块：实例代码块会执行在每一个构造方法之前</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实例代码块执行了~~&quot;</span>);</span><br><span class="line">        age = <span class="number">18</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;有人创建了对象：&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参数构造器执行了~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数构造器执行了~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来在测试类中进行测试，观察创建对象时，实例代码块是否先执行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(s1.age);</span><br><span class="line">        System.out.println(s2.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于实例代码块重点注意：<strong>实例代码块每次创建对象之前都会执行一次</strong></p>
<h2 id="二、继承">二、继承</h2>
<h3 id="2-1-继承">2.1 继承</h3>
<p><img src="https://s2.loli.net/2024/05/05/G4KXD9MpRemgFtL.webp" alt="1664009338913"></p>
<p>接下来，我们演示一下使用继承来编写代码，注意观察继承的特点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//公开的成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===print1===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//私有的成员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===print2===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，写一个B类，让B类继承A类。在继承A类的同时，B类中新增一个方法print3</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//由于i和print1是属于父类A的公有成员，在子类中可以直接被使用</span></span><br><span class="line">        System.out.println(i); <span class="comment">//正确</span></span><br><span class="line">        print1(); <span class="comment">//正确</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//由于j和print2是属于父类A的私有成员，在子类中不可以被使用</span></span><br><span class="line">        System.out.println(j); <span class="comment">//错误</span></span><br><span class="line">        print2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>继承的内存原理</li>
</ul>
<p>这里我们只需要关注一点：<strong>子类对象实际上是由子、父类两张设计图共同创建出来的。</strong></p>
<p>所以，在子类对象的空间中，既有本类的成员，也有父类的成员。但是子类只能调用父类公有的成员。</p>
<p><img src="https://s2.loli.net/2024/05/05/oE9sPjHx45TBRFf.webp" alt="1664010590126"></p>
<h3 id="2-2-继承的好处">2.2 继承的好处</h3>
<p><img src="https://s2.loli.net/2024/05/05/9TcCmxRDa6UtqVs.webp" alt="1664010915416"></p>
<p>观察代码发现，我们会发现Teacher类中和Consultant类中有相同的代码；其实像这种两个类中有相同代码时，没必要重复写。</p>
<p>我们可以把重复的代码提取出来，作为父类，然后让其他类继承父类就可以了，这样可以提高代码的复用性。改造后的代码如下：</p>
<p><img src="https://s2.loli.net/2024/05/05/oqRsT4aDUyirvJh.webp" alt="1664011136599"></p>
<p>接下来使用继承来完成上面的案例，这里只演示People类和Teacher类，然后你尝试自己完成Consultant类。</p>
<ul>
<li>先写一个父类 People，用来设计Teacher和Consultant公有的成员。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>再写两个子类Teacher继承People类，同时在子类中加上自己特有的成员。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String skill; <span class="comment">//技能</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSkill</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> skill;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSkill</span><span class="params">(String skill)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.skill=skill;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(getName()+<span class="string">&quot;具备的技能：&quot;</span>+skill);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后再写一个测试类，再测试类中创建Teacher、Consultant对象，并调用方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：搞清楚继承的好处。</span></span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        t.setName(<span class="string">&quot;播仔&quot;</span>);</span><br><span class="line">        t.setSkill(<span class="string">&quot;Java、Spring&quot;</span>);</span><br><span class="line">        System.out.println(t.getName());</span><br><span class="line">        System.out.println(t.getSkill());</span><br><span class="line">        t.printInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码，打印结果如下：</p>
<p><img src="https://s2.loli.net/2024/05/05/4pWMx6jbrcB5Vgz.webp" alt="1664011737379"></p>
<p>关于继承的好处我们只需要记住：<strong>继承可以提高代码的复用性</strong></p>
<h3 id="2-3-权限修饰符">2.3 权限修饰符</h3>
<blockquote>
<p><strong>什么是权限修饰符呢？</strong></p>
<p>权限修饰符是用来限制类的成员（成员变量、成员方法、构造器…）能够被访问的范围。</p>
</blockquote>
<p>每一种权限修饰符能够被访问的范围如下</p>
<p><img src="https://s2.loli.net/2024/05/05/84hCqHQGUmnN2Ol.webp" alt="1664012151488"></p>
<p>下面我们用代码演示一下，在本类中可以访问到哪些权限修饰的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="comment">// 1、私有:只能在本类中访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==private==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、缺省：本类，同一个包下的类</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==缺省==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、protected: 本类，同一个包下的类，任意包下的子类</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">protectedMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==protected==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、public： 本类，同一个包下的类，任意包下的子类，任意包下的任意类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==public==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//在本类中，所有权限都可以被访问到</span></span><br><span class="line">        privateMethod(); <span class="comment">//正确</span></span><br><span class="line">        method(); <span class="comment">//正确</span></span><br><span class="line">        protectedMethod(); <span class="comment">//正确</span></span><br><span class="line">        publicMethod(); <span class="comment">//正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，在和Fu类同一个包下，创建一个测试类Demo，演示同一个包下可以访问到哪些权限修饰的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Fu</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fu</span>();</span><br><span class="line">        <span class="comment">// f.privateMethod();	//私有方法无法使用</span></span><br><span class="line">        f.method();</span><br><span class="line">        f.protectedMethod();</span><br><span class="line">        f.publicMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，在另一个包下创建一个Fu类的子类，演示不同包下的子类中可以访问哪些权限修饰的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="comment">//在不同包下的子类中，只能访问到public、protected修饰的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// privateMethod(); // 报错</span></span><br><span class="line">        <span class="comment">// method(); // 报错</span></span><br><span class="line">        protectedMethod();	<span class="comment">//正确</span></span><br><span class="line">        publicMethod();	<span class="comment">//正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，在和Fu类不同的包下，创建一个测试类Demo2，演示一下不同包的无关类，能访问到哪些权限修饰的方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Fu</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fu</span>();</span><br><span class="line">        <span class="comment">// f.privateMethod(); // 报错</span></span><br><span class="line">        <span class="comment">// f.method();		  //报错</span></span><br><span class="line">        <span class="comment">// f.protecedMethod();//报错</span></span><br><span class="line">        f.publicMethod();	<span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">        <span class="comment">// zi.protectedMethod();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-单继承、Object">2.4 单继承、Object</h3>
<p><strong>Java语言只支持单继承，不支持多继承，但是可以多层继承</strong>。就像家族里儿子、爸爸和爷爷的关系一样：一个儿子只能有一个爸爸，不能有多个爸爸，但是爸爸也是有爸爸的。</p>
<p><img src="https://s2.loli.net/2024/05/05/Y3OUSWCeifNAgPQ.webp" alt="1664016601977"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握继承的两个注意事项事项。</span></span><br><span class="line">        <span class="comment">// 1、Java是单继承的：一个类只能继承一个直接父类；</span></span><br><span class="line">        <span class="comment">// 2、Object类是Java中所有类的祖宗。</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125; <span class="comment">//extends Object&#123;&#125;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="comment">// class C extends B , A&#123;&#125; // 报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-方法重写">2.5 方法重写</h3>
<blockquote>
<p><strong>什么是方法重写</strong></p>
</blockquote>
<p>当子类觉得父类方法不好用，或者无法满足父类需求时，子类可以重写一个方法名称、参数列表一样的方法，去覆盖父类的这个方法，这就是方法重写。</p>
<p><strong>注意：重写后，方法的访问遵循就近原则</strong>。下面我们看一个代码演示</p>
<p>写一个A类作为父类，定义两个方法print1和print2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;111111&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再写一个B类作为A类的子类，重写print1和print2方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">// 方法重写</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 安全，可读性好</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法重写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;666666&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，在测试类中创建B类对象，调用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：认识方法重写，掌握方法重写的常见应用场景。</span></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.print1();</span><br><span class="line">        b.print2(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码，我们发现真正执行的是B类中的print1和print2方法</p>
<p><img src="https://s2.loli.net/2024/05/05/X6RiDJA7ZtQx1ny.webp" alt="1664149862001"></p>
<p>知道什么是方法重写之后，还有一些注意事项，需要和大家分享一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- <span class="number">1.</span>重写的方法上面，可以加一个注解<span class="meta">@Override</span>,用于标注这个方法是复写的父类方法</span><br><span class="line">- <span class="number">2.</span>子类复写父类方法时，访问权限必须大于或者等于父类方法的权限</span><br><span class="line">	<span class="keyword">public</span> &gt; <span class="keyword">protected</span> &gt; 缺省</span><br><span class="line">- <span class="number">3.</span> 重写的方法返回值类型，必须与被重写的方法返回值类型一样，或者范围更小</span><br><span class="line">- <span class="number">4.</span> 私有方法、静态方法不能被重写，如果重写会报错。</span><br></pre></td></tr></table></figure>
<p>关于这些注意事项，同学们其实只需要了解一下就可以了。实际上我们实际写代码时，只要和父类写的一样就可以（ 总结起来就8个字：<strong>声明不变，重新实现</strong>）</p>
<blockquote>
<p><strong>方法重写的应用场景</strong></p>
</blockquote>
<p>方法重写的应用场景之一就是：<strong>子类重写Object的toString()方法，以便返回对象的内容。</strong></p>
<p>比如：有一个Student类，这个类会默认继承Object类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Object</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实Object类中有一个toString()方法，直接通过Student对象调用Object的toString()方法，会得到对象的地址值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;播妞&quot;</span>, <span class="number">19</span>);</span><br><span class="line">        <span class="comment">// System.out.println(s.toString());</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/05/05/aClcJ8I93eNqmdu.webp" alt="1664150713665"></p>
<p>但是，此时不想调用父类Object的toString()方法，那就可以在Student类中重新写一个toSting()方法，用于返回对象的属性值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.d12_extends_override;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Object</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新运行测试类，结果如下</p>
<p><img src="https://s2.loli.net/2024/05/05/ReuJwBxUOqCVZA1.webp" alt="1664150752636"></p>
<h3 id="2-6-子类中访问成员的特点">2.6 子类中访问成员的特点</h3>
<ul>
<li><strong>原则：在子类中访问其他成员（成员变量、成员方法），是依据就近原则的</strong></li>
</ul>
<p>定义一个父类，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;父类名字&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==父类的print1方法执行==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再定义一个子类，代码如下。有一个同名的name成员变量，有一个同名的print1成员方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Z</span> <span class="keyword">extends</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;子类名称&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;局部名称&quot;</span>;</span><br><span class="line">        System.out.println(name); <span class="comment">// 局部名称</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==子类的print1方法执行了=&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        print1(); <span class="comment">// 子类的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来写一个测试类，观察运行结果，我们发现都是调用的子类变量、子类方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握子类中访问其他成员的特点：就近原则。</span></span><br><span class="line">        <span class="type">Z</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Z</span>();</span><br><span class="line">        z.showName();</span><br><span class="line">        z.showMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果子类和父类出现同名变量或者方法，优先使用子类的；此时如果一定要在子类中使用父类的成员，可以加this或者super进行区分。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Z</span> <span class="keyword">extends</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;子类名称&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;局部名称&quot;</span>;</span><br><span class="line">        System.out.println(name); <span class="comment">// 局部名称</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name); <span class="comment">// 子类成员变量</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name); <span class="comment">// 父类的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==子类的print1方法执行了=&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        print1(); <span class="comment">// 子类的</span></span><br><span class="line">        <span class="built_in">super</span>.print1(); <span class="comment">// 父类的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-7-子类中访问构造器的特点">2.7 子类中访问构造器的特点</h3>
<p>我们先认识子类构造器的语法特点，再讲一下子类构造器的应用场景</p>
<blockquote>
<p><strong>子类中访问构造器的语法规则</strong></p>
</blockquote>
<ul>
<li>
<p>首先，子类全部构造器，都会先调用父类构造器，再执行自己。</p>
<p>执行顺序，如下图按照① ② ③ 步骤执行：</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/05/jwgbhSPtkzMEyd6.webp" alt="1664160225526"></p>
<blockquote>
<p><strong>子类访问构造器的应用场景</strong></p>
</blockquote>
<ul>
<li>如果不想使用默认的<code>super()</code>方式调用父类构造器，还可以手动使用<code>super(参数)</code>调用父类有参数构造器。</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/05/a578AoTUmcrbHB6.webp" alt="1664163881728"></p>
<blockquote>
<p><strong>在本类中访问自己的构造方法</strong></p>
</blockquote>
<p>刚才我们学习了通过<code>super()</code>和<code>super(参数)</code>可以访问父类的构造器。有时候我们也需要访问自己类的构造器。语法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>(): 调用本类的空参数构造器</span><br><span class="line"><span class="built_in">this</span>(参数): 调用本类有参数的构造器</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/05/05/B6QtnDqfEwMuvs8.webp" alt="1664170865036"></p>
<blockquote>
<p><strong>最后我们被this和super的用法在总结一下</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">访问本类成员：</span><br><span class="line">	<span class="built_in">this</span>.成员变量	<span class="comment">//访问本类成员变量</span></span><br><span class="line">	<span class="built_in">this</span>.成员方法	<span class="comment">//调用本类成员方法</span></span><br><span class="line">	<span class="built_in">this</span>()		   <span class="comment">//调用本类空参数构造器</span></span><br><span class="line">    <span class="built_in">this</span>(参数)	  <span class="comment">//调用本类有参数构造器</span></span><br><span class="line">	</span><br><span class="line">访问父类成员：</span><br><span class="line">	<span class="built_in">super</span>.成员变量	<span class="comment">//访问父类成员变量</span></span><br><span class="line">	<span class="built_in">super</span>.成员方法	<span class="comment">//调用父类成员方法</span></span><br><span class="line">	<span class="built_in">super</span>()		   <span class="comment">//调用父类空参数构造器</span></span><br><span class="line">    <span class="built_in">super</span>(参数)	  <span class="comment">//调用父类有参数构造器</span></span><br><span class="line">    </span><br><span class="line">注意：<span class="built_in">this</span>和<span class="built_in">super</span>访问构造方法，只能用到构造方法的第一句，否则会报错。</span><br></pre></td></tr></table></figure>
<h1 id="面向对象高级（二）">面向对象高级（二）</h1>
<h2 id="一、多态">一、多态</h2>
<h3 id="1-1-多态概述">1.1 多态概述</h3>
<blockquote>
<p><strong>什么是多态？</strong></p>
<p>多态是在继承、实现情况下的一种现象，表现为：对象多态、行为多态。</p>
</blockquote>
<p>比如：Teacher和Student都是People的子类，代码可以写成下面的样子</p>
<p><img src="https://s2.loli.net/2024/05/05/QVOoR91umGbHfUX.webp" alt="1664278943905"></p>
<p><img src="https://s2.loli.net/2024/05/05/NxulQTLYVWDHbJZ.webp" alt="1664278943905"></p>
<h3 id="1-2-多态的好处">1.2 多态的好处</h3>
<blockquote>
<p>在多态形式下，右边的代码是解耦合的，更便于扩展和维护。</p>
</blockquote>
<ul>
<li>怎么理解这句话呢？比如刚开始p1指向Student对象，run方法执行的就是Student对象的业务；假如p1指向Student对象 ，run方法执行的自然是Student对象的业务。</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/05/LpNGDMR2hyQAsfg.webp" alt="1665018279234"></p>
<blockquote>
<p>定义方法时，使用父类类型作为形参，可以接收一切子类对象，扩展更强，更便利。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握使用多态的好处</span></span><br><span class="line">		<span class="type">Teacher</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">		go(t);</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        go(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数People p既可以接收Student对象，也能接收Teacher对象。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(People p)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始------------------------&quot;</span>);</span><br><span class="line">        p.run();</span><br><span class="line">        System.out.println(<span class="string">&quot;结束------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-类型转换">1.3 类型转换</h3>
<p>虽然多态形式下有一些好处，但是也有一些弊端。在多态形式下，不能调用子类特有的方法，比如在Teacher类中多了一个teach方法，在Student类中多了一个study方法，这两个方法在多态形式下是不能直接调用的。</p>
<p><img src="https://s2.loli.net/2024/05/05/7QsSOpDRWB3Tu4N.webp" alt="1665018661860"></p>
<p>多态形式下不能直接调用子类特有方法，但是转型后是可以调用的。这里所说的转型就是把父类变量转换为子类类型。格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果p接收的是子类对象</span></span><br><span class="line"><span class="keyword">if</span>(父类变量 instance 子类)&#123;</span><br><span class="line">    <span class="comment">//则可以将p转换为子类类型</span></span><br><span class="line">    子类 变量名 = (子类)父类变量;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/05/05/YO46dw7A3rhpusQ.webp" alt="1665018905475"></p>
<p>如果类型转换错了，就会出现类型转换异常ClassCastException，比如把Teacher类型转换成了Student类型.</p>
<p><img src="https://s2.loli.net/2024/05/05/PRfOnwljCc3pWZX.webp" alt="1665019335142"></p>
<p>关于多态转型问题，我们最终记住一句话：<strong>原本是什么类型，才能还原成什么类型</strong></p>
<h2 id="二、final关键字">二、final关键字</h2>
<h3 id="2-1-final修饰符的特点">2.1 final修饰符的特点</h3>
<p>我们先来认识一下final的特点，final关键字是最终的意思，可以修饰类、修饰方法、修饰变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">final</span>修饰类：该类称为最终类，特点是不能被继承</span><br><span class="line">- <span class="keyword">final</span>修饰方法：该方法称之为最终方法，特点是不能被重写。</span><br><span class="line">- <span class="keyword">final</span>修饰变量：该变量只能被赋值一次。</span><br></pre></td></tr></table></figure>
<ul>
<li>接下来我们分别演示一下，先看final修饰类的特点</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/05/GucUg3vNBnOzepx.webp" alt="1665020107661"></p>
<ul>
<li>
<p>再来演示一下final修饰方法的特点</p>
<p><img src="https://s2.loli.net/2024/05/05/8CBOFmYnEV2PMzS.webp" alt="1665020283101"></p>
</li>
<li>
<p>再演示一下final修饰变量的特点</p>
<ul>
<li>情况一</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/05/tsTIU2dKoFa8HYl.webp" alt="1665020419364"></p>
<ul>
<li>情况二</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/05/oIA7gQZEicRqeT2.webp" alt="1665020580223"></p>
<ul>
<li>情况三</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/05/UtisLrR7vm6DAT2.webp" alt="1665020721501"></p>
<p><img src="https://s2.loli.net/2024/05/05/FG14yE9OB3WSKUT.webp" alt="1665020951170"></p>
</li>
</ul>
<h3 id="2-2-补充知识：常量">2.2 补充知识：常量</h3>
<ul>
<li>被 static final 修饰的成员变量，称之为常量。</li>
<li>通常用于记录系统的配置信息</li>
</ul>
<p>接下来我们用代码来演示一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constant</span> &#123;</span><br><span class="line">    <span class="comment">//常量: 定义一个常量表示学校名称</span></span><br><span class="line">    <span class="comment">//为了方便在其他类中被访问所以一般还会加上public修饰符</span></span><br><span class="line">    <span class="comment">//常量命名规范：建议都采用大写字母命名，多个单词之前有_隔开</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SCHOOL_NAME</span> <span class="operator">=</span> <span class="string">&quot;传智教育&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//由于常量是static的所以，在使用时直接用类名就可以调用</span></span><br><span class="line">        System.out.println(Constant.SCHOOL_NAME);</span><br><span class="line">        System.out.println(Constant.SCHOOL_NAME);</span><br><span class="line">        System.out.println(Constant.SCHOOL_NAME);</span><br><span class="line">        System.out.println(Constant.SCHOOL_NAME);</span><br><span class="line">        System.out.println(Constant.SCHOOL_NAME);</span><br><span class="line">        System.out.println(Constant.SCHOOL_NAME);</span><br><span class="line">        System.out.println(Constant.SCHOOL_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关于常量的原理，同学们也可以了解一下：在程序编译后，常量会“宏替换”，出现常量的地方，全都会被替换为其记住的字面量。把代码反编译后，其实代码是下面的样子</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;传智教育&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;传智教育&quot;</span>E);</span><br><span class="line">        System.out.println(<span class="string">&quot;传智教育&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;传智教育&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;传智教育&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;传智教育&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;传智教育&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、抽象">三、抽象</h2>
<h3 id="3-1-认识抽象类">3.1 认识抽象类</h3>
<p>我们先来认识一下什么是抽象类，以及抽象类有什么特点。</p>
<ul>
<li>在Java中有一个关键字叫abstract，它就是抽象的意思，它可以修饰类也可以修饰方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 被<span class="keyword">abstract</span>修饰的类，就是抽象类</span><br><span class="line">- 被<span class="keyword">abstract</span>修饰的方法，就是抽象方法（不允许有方法体）</span><br></pre></td></tr></table></figure>
<p>接下来用代码来演示一下抽象类和抽象方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//abstract修饰类，这个类就是抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//abstract修饰方法，这个方法就是抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类的成员（成员变量、成员方法、构造器），类的成员都可以有。如下面代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">static</span> String schoolName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>抽象类是不能创建对象的，如果抽象类的对象就会报错</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/05/ErbKQNd8uD41FWV.webp" alt="1665026273870"></p>
<ul>
<li>抽象类虽然不能创建对象，但是它可以作为父类让子类继承。而且子类继承父类必须重写父类的所有抽象方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//B类继承A类，必须复写test方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>子类继承父类如果不复写父类的抽象方法，要想不出错，这个子类也必须是抽象类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//B类基础A类，此时B类也是抽象类，这个时候就可以不重写A类的抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-抽象类的好处">3.2 抽象类的好处</h3>
<p><img src="https://s2.loli.net/2024/05/05/oXPQSHB1F9CjV4D.webp" alt="1665028790780"></p>
<p>分析需求发现，该案例中猫和狗都有名字这个属性，也都有叫这个行为，所以我们可以将共性的内容抽取成一个父类，Animal类，但是由于猫和狗叫的声音不一样，于是我们在Animal类中将叫的行为写成抽象的。代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动物叫的行为：不具体，是抽象的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着写一个Animal的子类，Dog类。代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;汪汪汪的叫~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，再写一个Animal的子类，Cat类。代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;喵喵喵的叫~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，再写一个测试类，Test类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握抽象类的使用场景和好处.</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        a.cry();	<span class="comment">//这时执行的是Dog类的cry方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再学一招，假设现在系统有需要加一个Pig类，也有叫的行为，这时候也很容易原有功能扩展。只需要让Pig类继承Animal，复写cry方法就行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pig</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;嚯嚯嚯~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，创建对象时，让Animal接收Pig，就可以执行Pig的cry方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握抽象类的使用场景和好处.</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pig</span>();</span><br><span class="line">        a.cry();	<span class="comment">//这时执行的是Pig类的cry方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上所述，我们总结一下抽象类的使用场景和好处</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>用抽象类可以把父类中相同的代码，包括方法声明都抽取到父类，这样能更好的支持多态，一提高代码的灵活性。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>反过来用，我们不知道系统未来具体的业务实现时，我们可以先定义抽象类，将来让子类去实现，以方便系统的扩展。</span><br></pre></td></tr></table></figure>
<h3 id="3-3-模板方法模式">3.3 模板方法模式</h3>
<p>那模板方法设计模式解决什么问题呢？<strong>模板方法模式主要解决方法中存在重复代码的问题</strong></p>
<p>比如A类和B类都有sing()方法，sing()方法的开头和结尾都是一样的，只是中间一段内容不一样。此时A类和B类的sing()方法中就存在一些相同的代码。</p>
<p><img src="https://s2.loli.net/2024/05/05/UWpSecJsPQkwVrx.webp" alt="1665058597483"></p>
<p>怎么解决上面的重复代码问题呢？ 我们可以写一个抽象类C类，在C类中写一个doSing()的抽象方法。再写一个sing()方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板方法设计模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;唱一首你喜欢的歌：&quot;</span>);</span><br><span class="line"></span><br><span class="line">        doSing();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;唱完了!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doSing</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，写一个A类继承C类，复写doSing()方法，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一只小小小小鸟，想要飞就能飞的高~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，再写一个B类继承C类，也复写doSing()方法，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们一起学猫叫，喵喵喵喵喵喵喵~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，再写一个测试类Test</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：搞清楚模板方法设计模式能解决什么问题，以及怎么写。</span></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.sing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上所述：模板方法模式解决了多个子类中有相同代码的问题。具体实现步骤如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第<span class="number">1</span>步：定义一个抽象类，把子类中相同的代码写成一个模板方法。</span><br><span class="line">第<span class="number">2</span>步：把模板方法中不能确定的代码写成抽象方法，并在模板方法中调用。</span><br><span class="line">第<span class="number">3</span>步：子类继承抽象类，只需要父类抽象方法就可以了。</span><br></pre></td></tr></table></figure>
<h2 id="四、接口">四、接口</h2>
<h3 id="4-1-认识接口">4.1 认识接口</h3>
<p>我们先来认识一下接口？Java提供了一个关键字interface，用这个关键字来定义接口这种特殊结构。格式如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;</span><br><span class="line">    <span class="comment">//成员变量（常量）</span></span><br><span class="line">    <span class="comment">//成员方法（抽象方法）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照接口的格式，我们定义一个接口看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//这里public static final可以加，可以不加。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SCHOOL_NAME</span> <span class="operator">=</span> <span class="string">&quot;黑马程序员&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里的public abstract可以加，可以不加。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写好A接口之后，在写一个测试类，用一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//打印A接口中的常量</span></span><br><span class="line">        System.out.println(A.SCHOOL_NAME);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//接口是不能创建对象的</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现定义好接口之后，是不能创建对象的。那接口到底什么使用呢？需要我注意下面两点</p>
<ul>
<li><strong>接口是用来被类实现（implements）的，我们称之为实现类。</strong></li>
<li><strong>一个类是可以实现多个接口的（接口可以理解成干爹），类实现接口必须重写所有接口的全部抽象方法，否则这个类也必须是抽象类</strong></li>
</ul>
<p>比如，再定义一个B接口，里面有两个方法testb1()，testb2()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testb1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testb2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，再定义一个C接口，里面有两个方法testc1(), testc2()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testc1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testc2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，再写一个实现类D，同时实现B接口和C接口，此时就需要复写四个方法，如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">B</span>, C&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testb1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testb2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testc1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testc2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，定义一个测试类Test</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：认识接口。</span></span><br><span class="line">        System.out.println(A.SCHOOL_NAME);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A a = new A();</span></span><br><span class="line">        <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-接口的好处">4.2 接口的好处</h3>
<p>使用接口到底有什么好处呢？主要有下面的两点</p>
<ul>
<li>弥补了类单继承的不足，一个类同时可以实现多个接口。</li>
<li>让程序可以面向接口编程，这样程序员可以灵活方便的切换各种业务实现。</li>
</ul>
<p>我们看一个案例演示，假设有一个Studnet学生类，还有一个Driver司机的接口，还有一个Singer歌手的接口。</p>
<p>现在要写一个A类，想让他既是学生，偶然也是司机能够开车，偶尔也是歌手能够唱歌。那我们代码就可以这样设计，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Driver</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Singer</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A类是Student的子类，同时也实现了Dirver接口和Singer接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Driver</span>, Singer&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//想唱歌的时候，A类对象就表现为Singer类型</span></span><br><span class="line">        <span class="type">Singer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        s.sing();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//想开车的时候，A类对象就表现为Driver类型</span></span><br><span class="line">        <span class="type">Driver</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        d.drive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上所述：接口弥补了单继承的不足，同时可以轻松实现在多种业务场景之间的切换。</p>
<h3 id="4-3-接口的案例">4.3 接口的案例</h3>
<p><img src="https://s2.loli.net/2024/05/05/c9USqkHrG8WFRmh.webp" alt="1665102202635"></p>
<p>首先我们写一个学生类，用来描述学生的相关信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">char</span> sex, <span class="type">double</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">char</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">double</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，写一个StudentOperator接口，表示学生信息管理系统的两个功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentOperator</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printAllInfo</span><span class="params">(ArrayList&lt;Student&gt; students)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printAverageScore</span><span class="params">(ArrayList&lt;Student&gt; students)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，写一个StudentOperator接口的实现类StudentOperatorImpl1，采用第1套方案对业务进行实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentOperatorImpl1</span> <span class="keyword">implements</span> <span class="title class_">StudentOperator</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printAllInfo</span><span class="params">(ArrayList&lt;Student&gt; students)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------全班全部学生信息如下--------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.size(); i++) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> students.get(i);</span><br><span class="line">            System.out.println(<span class="string">&quot;姓名：&quot;</span> + s.getName() + <span class="string">&quot;, 性别：&quot;</span> + s.getSex() + <span class="string">&quot;, 成绩：&quot;</span> + s.getScore());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printAverageScore</span><span class="params">(ArrayList&lt;Student&gt; students)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">allScore</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.size(); i++) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> students.get(i);</span><br><span class="line">            allScore += s.getScore();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;平均分：&quot;</span> + (allScore) / students.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，再写一个StudentOperator接口的实现类StudentOperatorImpl2，采用第2套方案对业务进行实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentOperatorImpl2</span> <span class="keyword">implements</span> <span class="title class_">StudentOperator</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printAllInfo</span><span class="params">(ArrayList&lt;Student&gt; students)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------全班全部学生信息如下--------------&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.size(); i++) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> students.get(i);</span><br><span class="line">            System.out.println(<span class="string">&quot;姓名：&quot;</span> + s.getName() + <span class="string">&quot;, 性别：&quot;</span> + s.getSex() + <span class="string">&quot;, 成绩：&quot;</span> + s.getScore());</span><br><span class="line">            <span class="keyword">if</span>(s.getSex() == <span class="string">&#x27;男&#x27;</span>)&#123;</span><br><span class="line">                count1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                count2 ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;男生人数是：&quot;</span> + count1  + <span class="string">&quot;, 女士人数是：&quot;</span> + count2);</span><br><span class="line">        System.out.println(<span class="string">&quot;班级总人数是：&quot;</span> + students.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printAverageScore</span><span class="params">(ArrayList&lt;Student&gt; students)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">allScore</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> students.get(<span class="number">0</span>).getScore();</span><br><span class="line">        <span class="type">double</span> <span class="variable">min</span> <span class="operator">=</span> students.get(<span class="number">0</span>).getScore();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.size(); i++) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> students.get(i);</span><br><span class="line">            <span class="keyword">if</span>(s.getScore() &gt; max) max = s.getScore();</span><br><span class="line">            <span class="keyword">if</span>(s.getScore() &lt; min) min = s.getScore();</span><br><span class="line">            allScore += s.getScore();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生的最高分是：&quot;</span> + max);</span><br><span class="line">        System.out.println(<span class="string">&quot;学生的最低分是：&quot;</span> + min);</span><br><span class="line">        System.out.println(<span class="string">&quot;平均分：&quot;</span> + (allScore - max - min) / (students.size() - <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再写一个班级管理类ClassManager，在班级管理类中使用StudentOperator的实现类StudentOperatorImpl1对学生进行操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StudentOperator</span> <span class="variable">studentOperator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentOperatorImpl1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassManager</span><span class="params">()</span>&#123;</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">99</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;古力娜扎&quot;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">100</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;马尔扎哈&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">80</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;卡尔扎巴&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">60</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印全班全部学生的信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        studentOperator.printAllInfo(students);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印全班全部学生的平均分</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScore</span><span class="params">()</span>&#123;</span><br><span class="line">        studentOperator.printAverageScore(students);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，再写一个测试类Test，在测试类中使用ClassMananger完成班级学生信息的管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：完成班级学生信息管理的案例。</span></span><br><span class="line">        <span class="type">ClassManager</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassManager</span>();</span><br><span class="line">        clazz.printInfo();</span><br><span class="line">        clazz.printScore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果想切换班级管理系统的业务功能，随时可以将StudentOperatorImpl1切换为StudentOperatorImpl2。自己试试</p>
<h3 id="4-4-接口JDK8的新特性">4.4 接口JDK8的新特性</h3>
<p>我们看一下这三种方法分别有什么特点？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、默认方法：必须使用default修饰，默认会被public修饰</span></span><br><span class="line"><span class="comment">     * 实例方法：对象的方法，必须使用实现类的对象来访问。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===默认方法==&quot;</span>);</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、私有方法：必须使用private修饰。(JDK 9开始才支持的)</span></span><br><span class="line"><span class="comment">     *   实例方法：对象的方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===私有方法==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3、静态方法：必须使用static修饰，默认会被public修饰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==静态方法==&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>;</span><br><span class="line">     <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们写一个B类，实现A接口。B类作为A接口的实现类，只需要重写抽象方法就尅了，对于默认方法不需要子类重写。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，写一个测试类，观察接口中的三种方法，是如何调用的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握接口新增的三种方法形式</span></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.test1();	<span class="comment">//默认方法使用对象调用</span></span><br><span class="line">        <span class="comment">// b.test2();	//A接口中的私有方法，B类调用不了</span></span><br><span class="line">        A.test3();	<span class="comment">//静态方法，使用接口名调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上所述：JDK8对接口新增的特性，有利于对程序进行扩展。</p>
<h3 id="4-5-接口的其他细节">4.5 接口的其他细节</h3>
<p>注意事项：</p>
<ul>
<li>一个接口可以继承多个接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：理解接口的多继承。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">C</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比如：D接口继承C、B、A</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">C</span>, B, A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//E类在实现D接口时，必须重写D接口、以及其父类中的所有抽象方法。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> <span class="keyword">implements</span> <span class="title class_">D</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口除了上面的多继承特点之外，在多实现、继承和实现并存时，有可能出现方法名冲突的问题，需要了解怎么解决（仅仅只是了解一下，实际上工作中几乎不会出现这种情况）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>一个接口继承多个接口，如果多个接口中存在相同的方法声明，则此时不支持多继承</span><br><span class="line"><span class="number">2.</span>一个类实现多个接口，如果多个接口中存在相同的方法声明，则此时不支持多实现</span><br><span class="line"><span class="number">3.</span>一个类继承了父类，又同时实现了接口，父类中和接口中有同名的默认方法，实现类会有限使用父类的方法</span><br><span class="line"><span class="number">4.</span>一个类实现类多个接口，多个接口中有同名的默认方法，则这个类必须重写该方法。</span><br></pre></td></tr></table></figure>
<p>综上所述：一个接口可以继承多个接口，接口同时也可以被类实现。</p>
<h1 id="面向对象高级（三）">面向对象高级（三）</h1>
<h2 id="一、内部类">一、内部类</h2>
<p>内部类是类中的五大成分之一（成员变量、方法、构造器、内部类、代码块），如果一个类定义在另一个类的内部，这个类就是内部类。</p>
<p>当一个类的内部，包含一个完整的事物，且这个事物没有必要单独设计时，就可以把这个事物设计成内部类。</p>
<p>比如：汽车、的内部有发动机，发动机是包含在汽车内部的一个完整事物，可以把发动机设计成内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">	<span class="comment">//内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Engine</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部类有四种形式，分别是成员内部类、静态内部类、局部内部类、匿名内部类。</p>
<h3 id="1-1-成员内部类">1.1 成员内部类</h3>
<p>成员内部类就是类中的一个普通成员，类似于成员变量、成员方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String a=<span class="string">&quot;黑马&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span>  <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">88</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在内部类中既可以访问自己类的成员，也可以访问外部类的成员</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(age); <span class="comment">//88</span></span><br><span class="line">            System.out.println(a);   <span class="comment">//黑马</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">77</span>;</span><br><span class="line">            System.out.println(age); <span class="comment">//77</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.age); <span class="comment">//88</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.age); <span class="comment">//99</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员内部类如何创建对象，格式如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外部类.内部类 变量名 = new 外部类().new 内部类();</span></span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line"><span class="comment">//调用内部类的方法</span></span><br><span class="line">in.test();</span><br></pre></td></tr></table></figure>
<p>总结一下内部类访问成员的特点</p>
<ul>
<li>既可以访问内部类成员、也可以访问外部类成员</li>
<li>如果内部类成员和外部类成员同名，可以使用**<code>类名.this.成员</code>**区分</li>
</ul>
<h3 id="1-2-静态内部类">1.2 静态内部类</h3>
<p>静态内部类，其实就是在成员内部类的前面加了一个static关键字。静态内部类属于外部类自己持有。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String schoolName=<span class="string">&quot;黑马&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="comment">//静态内部类访问外部类的静态变量，是可以的；</span></span><br><span class="line">        <span class="comment">//静态内部类访问外部类的实例变量，是不行的</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(schoolName); <span class="comment">//99</span></span><br><span class="line">            <span class="comment">//System.out.println(age);   //报错</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态内部类创建对象时，需要使用外部类的类名调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式：外部类.内部类 变量名 = new 外部类.内部类();</span></span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br><span class="line">in.test();</span><br></pre></td></tr></table></figure>
<h3 id="1-3-局部内部类">1.3 局部内部类</h3>
<p>局部内部类是定义在方法中的类，和局部变量一样，只能在方法中有效。所以局部内部类的局限性很强，一般在开发中是不会使用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Inner...show&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//局部内部类只能在方法中创建对象，并使用</span></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        in.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-匿名内部类">1.4 匿名内部类*</h3>
<blockquote>
<p><strong>1.4.1 认识匿名内部类，基本使用</strong></p>
</blockquote>
<p>一种在实际开发中用得最多的一种内部类，叫匿名内部类。相比于前面几种内部类，匿名内部类就比较重要的。</p>
<p>我们还是先认识一下什么是匿名内部类？</p>
<p>匿名内部类是一种特殊的局部内部类；所谓匿名，指的是程序员不需要为这个类声明名字。</p>
<p>下面就是匿名内部类的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类/接口(参数值)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    重写父类/接口的方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名内部类本质上是一个没有名字的子类对象、或者接口的实现类对象。</p>
<p>比如，先定义一个Animal抽象类，里面定义一个cry()方法，表示所有的动物有叫的行为，但是因为动物还不具体，cry()这个行为并不能具体化，所以写成抽象方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我想要在不定义子类的情况下创建Animal的子类对象，就可以使用匿名内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//这里后面new 的部分，其实就是一个Animal的子类对象</span></span><br><span class="line">        <span class="comment">//这里隐含的有多态的特性： Animal a = Animal子类对象;</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;猫喵喵喵的叫~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a.eat(); <span class="comment">//直线上面重写的cry()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，匿名内部类在编写代码时没有名字，编译后系统会为自动为匿名内部类生产字节码，字节码的名称会以<code>外部类$1.class</code>的方法命名</p>
<p><img src="https://s2.loli.net/2024/05/05/pehvxD7ybN9tkMj.webp" alt="1665658585267"></p>
<p><strong>匿名内部类的作用：简化了创建子类对象、实现类对象的书写格式。</strong></p>
<blockquote>
<p><strong>1.4.2 匿名内部类的应用场景</strong></p>
</blockquote>
<p>一般我们会主动的使用匿名内部类。</p>
<p>**只有在调用方法时，当方法的形参是一个接口或者抽象类，为了简化代码书写，而直接传递匿名内部类对象给方法。**这样就可以少写一个类。比如，看下面代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Swimming</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Swimming</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swimming</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;狗刨飞快&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        go(s1);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Swimming</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swimming</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;猴子游泳也还行&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        go(s1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//形参是Swimming接口，实参可以接收任意Swimming接口的实现类对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(Swimming s)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始~~~~~~~~&quot;</span>);</span><br><span class="line">        s.swim();</span><br><span class="line">        System.out.println(<span class="string">&quot;结束~~~~~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、枚举">二、枚举</h2>
<h3 id="2-1-认识枚举">2.1 认识枚举</h3>
<blockquote>
<p><strong>2.1.1 认识枚举、枚举的原理</strong></p>
</blockquote>
<p>枚举是一种特殊的类，它的格式是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> 枚举类名&#123;</span><br><span class="line">    枚举项<span class="number">1</span>,枚举项<span class="number">2</span>,枚举项<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实枚举项就表示枚举类的对象，只是这些对象在定义枚举类时就预先写好了，以后就只能用这几个固定的对象。</p>
<p>我们用代码演示一下，定义一个枚举类A，在枚举类中定义三个枚举项X, Y, Z</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    X,Y,Z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要获取枚举类中的枚举项，只需要用类名调用就可以了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//获取枚举A类的，枚举项</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> A.X;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a2</span> <span class="operator">=</span> A.Y;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a3</span> <span class="operator">=</span> A.Z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刚才说，枚举项实际上是枚举类的对象，这一点其实可以通过反编译的形式来验证（需要用到反编译的命令，这里不能直接将字节码拖进idea反编译）</p>
<p><img src="https://s2.loli.net/2024/05/05/habmwkKSr6BFpV4.webp" alt="1665669996020"></p>
<p>我们会看到，枚举类A是用class定义的，说明枚举确实是一个类，而且X，Y，Z都是A类的对象；而且每一个枚举项都是被<code>public static final </code>修饰，所以被可以类名调用，而且不能更改。</p>
<blockquote>
<p><strong>2.1.2 枚举深入</strong></p>
</blockquote>
<p>既然枚举是一个类的话，我们能不能在枚举类中定义构造器、成员变量、成员方法呢？答案是可以的。来看一下代码吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//定义枚举项</span></span><br><span class="line">    X,Y,Z(<span class="string">&quot;张三&quot;</span>); <span class="comment">//枚举项后面加括号，就是在执行枚举类的带参数构造方法。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义空构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//定义带参数构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然枚举类中可以像类一样，写一些类的其他成员，但是一般不会这么写，如果你真要这么干的话，到不如直接写普通类来的直接。</p>
<h3 id="2-2-枚举的应用场景">2.2 枚举的应用场景</h3>
<p>枚举的应用场景是这样的：<strong>枚举一般表示一组信息，然后作为参数进行传输。</strong></p>
<p>我们来看一个案例。比如我们现在有这么一个应用，用户进入应用时，需要让用户选择是女生、还是男生，然后系统会根据用户选择的是男生，还是女生推荐不同的信息给用户观看。</p>
<p><img src="https://s2.loli.net/2024/05/05/62TlhtR9au5jk38.webp" alt="1665670887179"></p>
<p>这里我们就可以先定义一个枚举类，用来表示男生、或者女生</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constant</span>&#123;</span><br><span class="line">    BOY,GRIL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再定义一个测试类，完成用户进入系统后的选择</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//调用方法，传递男生</span></span><br><span class="line">        provideInfo(Constant.BOY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">provideInfo</span><span class="params">(Constant c)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> BOY:</span><br><span class="line">                System.out.println(<span class="string">&quot;展示一些信息给男生看&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GRIL:</span><br><span class="line">                System.out.println(<span class="string">&quot;展示一些信息给女生看&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终再总结一下枚举的应用场景：<strong>枚举一般表示几个固定的值，然后作为参数进行传输</strong>。</p>
<h2 id="三、泛型">三、泛型</h2>
<h3 id="3-1-认识泛型">3.1 认识泛型</h3>
<p>所谓泛型指的是，在定义类、接口、方法时，同时声明了一个或者多个类型变量（如：<E>），称为泛型类、泛型接口、泛型方法、它们统称为泛型。</p>
<p>ArrayList类就是一个泛型类，打开API文档看一下ArrayList类的声明。</p>
<p><img src="https://s2.loli.net/2024/05/05/FTjGNbsYxcn8d64.webp" alt="1665671616852"></p>
<p>ArrayList集合的设计者在定义ArrayList集合时，就已经明确ArrayList集合时给别人装数据用的，但是别人用ArrayList集合时候，装什么类型的数据他不知道，所以就用一个<code>&lt;E&gt;</code>表示元素的数据类型。</p>
<p>当别人使用ArrayList集合创建对象时，<code>new ArrayList&lt;String&gt; </code>就表示元素为String类型，<code>new ArrayList&lt;Integer&gt;</code>表示元素为Integer类型。</p>
<p><img src="https://s2.loli.net/2024/05/05/9bzVqu4acgI7yv5.webp" alt="1665671987771"></p>
<p>我们总结一下泛型的作用、本质：</p>
<ul>
<li>
<p><strong>泛型的好处：在编译阶段可以避免出现一些非法的数据。</strong></p>
</li>
<li>
<p><strong>泛型的本质：把具体的数据类型传递给类型变量。</strong></p>
</li>
</ul>
<h3 id="3-2-自定义泛型类">3.2 自定义泛型类</h3>
<p>泛型类，在实际工作中一般都是源代码中写好，我们直接用的，就是ArrayList<E>这样的，自己定义泛型类是<code>非常少的</code>。</p>
<p>自定义泛型类的格式如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的&lt;T,W&gt;其实指的就是类型变量，可以是一个，也可以是多个。</span></span><br><span class="line"><span class="keyword">public</span> class 类名&lt;T,W&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们自己定义一个MyArrayList<E>泛型类，模拟一下自定义泛型类的使用。注意这里重点仅仅只是模拟泛型类的使用，所以方法中的一些逻辑是次要的，也不会写得太严谨。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型类，用来表示一个容器</span></span><br><span class="line"><span class="comment">//容器中存储的数据，它的类型用&lt;E&gt;先代替用着，等调用者来确认&lt;E&gt;的具体类型。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArrayList</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//定一个索引，方便对数组进行操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        array[index]=e;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E)array[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们写一个测试类，来测试自定义的泛型类MyArrayList是否能够正常使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//1.确定MyArrayList集合中，元素类型为String类型</span></span><br><span class="line">        MyArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">MyArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//此时添加元素时，只能添加String类型</span></span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        </span><br><span class="line">         <span class="comment">//2.确定MyArrayList集合中，元素类型为Integer类型</span></span><br><span class="line">        MyArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">MyArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//此时添加元素时，只能添加String类型</span></span><br><span class="line">        list.add(<span class="number">100</span>);</span><br><span class="line">        list.add(<span class="number">200</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-自定义泛型接口">3.3 自定义泛型接口</h3>
<p>泛型接口其实指的是在接口中把不确定的数据类型用<code>&lt;类型变量&gt;</code>表示。定义格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的类型变量，一般是一个字母，比如&lt;E&gt;</span></span><br><span class="line"><span class="keyword">public</span> interface 接口名&lt;类型变量&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如，我们现在要做一个系统要处理学生和老师的数据，需要提供2个功能，保存对象数据、根据名称查询数据，要求：这两个功能处理的数据既能是老师对象，也能是学生对象。</p>
<p>首先我们得有一个学生类和老师类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义一个<code>Data&lt;T&gt;</code>泛型接口，T表示接口中要处理数据的类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Data</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;T&gt; <span class="title function_">getByName</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们写一个处理Teacher对象的接口实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此时确定Data&lt;E&gt;中的E为Teacher类型，</span></span><br><span class="line"><span class="comment">//接口中add和getByName方法上的T也都会变成Teacher类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherData</span> <span class="keyword">implements</span> <span class="title class_">Data</span>&lt;Teacher&gt;&#123;</span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Teacher t)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Teacher&gt; <span class="title function_">getByName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们写一个处理Student对象的接口实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此时确定Data&lt;E&gt;中的E为Student类型，</span></span><br><span class="line"><span class="comment">//接口中add和getByName方法上的T也都会变成Student类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentData</span> <span class="keyword">implements</span> <span class="title class_">Data</span>&lt;Student&gt;&#123;</span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Student t)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Student&gt; <span class="title function_">getByName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-泛型方法">3.4 泛型方法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;泛型变量,泛型变量&gt; 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图中在返回值类型和修饰符之间有<T>定义的才是泛型方法。</p>
<p><img src="https://s2.loli.net/2024/05/05/GlHiF35xWa6mT8e.webp" alt="1665750638693"></p>
<p>接下我们看一个泛型方法的案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//调用test方法，传递字符串数据，那么test方法的泛型就是String类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> test(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//调用test方法，传递Dog对象，那么test方法的泛型就是Dog类型</span></span><br><span class="line">    	<span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> test(<span class="keyword">new</span> <span class="title class_">Dog</span>()); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这是一个泛型方法&lt;T&gt;表示一个不确定的数据类型，由调用者确定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; test(T t)&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-泛型限定">3.5 泛型限定</h3>
<p>学习一个泛型的特殊用法，叫做泛型限定。泛型限定的意思是对泛型的数据类型进行范围的限制。有如下的三种格式</p>
<ul>
<li>
<?> 表示任意类型
</li>
<li>
<? extends 数据类型> 表示指定类型或者指定类型的子类
</li>
<li>
<? super 数据类型> 表示指定类型或者指定类型的父类
</li>
</ul>
<p>下面我们演示一下，假设有Car作为父类，BENZ，BWM两个类作为Car的子类，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BENZ</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BWN</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//1.集合中的元素不管是什么类型，test1方法都能接收</span></span><br><span class="line">        ArrayList&lt;BWM&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Benz&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        test1(list1);</span><br><span class="line">        test1(list2);</span><br><span class="line">        test1(list3);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.集合中的元素只能是Car或者Car的子类类型，才能被test2方法接收</span></span><br><span class="line">        ArrayList&lt;Car&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;BWM&gt; list5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        test2(list4);</span><br><span class="line">        test2(list5);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.集合中的元素只能是Car或者Car的父类类型，才能被test3方法接收</span></span><br><span class="line">        ArrayList&lt;Car&gt; list6 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Object&gt; list7 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        test3(list6);</span><br><span class="line">        test3(list7);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(ArrayList&lt;?&gt; list)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">(ArrayList&lt;? extends Car&gt; list)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">(ArrayList&lt;? <span class="built_in">super</span> Car&gt; list)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-泛型擦除">3.6 泛型擦除</h3>
<p>泛型擦除。什么意思呢？<strong>也就是说泛型只能编译阶段有效，一旦编译成字节码，字节码中是不包含泛型的</strong>。而且泛型只支持引用数据类型，不支持基本数据类型。</p>
<p>把下面的代码的字节码进行反编译</p>
<p><img src="https://s2.loli.net/2024/05/05/GgExJsC3rNSnVpD.webp" alt="1665752105271"></p>
<p>下面是反编译之后的代码，我们发现ArrayList后面没有泛型</p>
<p><img src="https://s2.loli.net/2024/05/05/68Nx2RbpahYMLzG.webp" alt="1665752037764"></p>
<h2 id="四、常用API">四、常用API</h2>
<p>API（Application Programming interface）意思是应用程序编程接口，说人话就是Java帮我们写好的一些程序，如：类、方法等，我们直接拿过来用就可以解决一些问题。</p>
<p><img src="https://s2.loli.net/2024/05/05/HxnTdBCGmzgY7bf.webp" alt="1665752705389"></p>
<p>我们要学习那些API呢？</p>
<p><img src="https://s2.loli.net/2024/05/05/xT5OXujvFBYRNhd.webp" alt="1665752813753"></p>
<p><strong>“千里之行始于足下，多记、多查、多些代码、孰能生巧！”</strong></p>
<h3 id="4-1-Object类">4.1 Object类</h3>
<p>Object类。Object类是Java中所有类的祖宗类，因此，Java中所有类的对象都可以直接使用Object类中提供的一些方法。</p>
<p>按照下图的提示，可以搜索到你想要找的类</p>
<p><img src="https://s2.loli.net/2024/05/05/x8Dl1tCcFo7KzZL.webp" alt="1665753230409"></p>
<p>我们找到Object类的下面两个方法</p>
<p><img src="https://s2.loli.net/2024/05/05/ON8m9u2XHBnyQJ3.webp" alt="1665753282718"></p>
<ul>
<li><strong>4.1.1 toString()方法</strong></li>
</ul>
<p>我们先来学习toString()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    调用toString()方法可以返回对象的字符串表示形式。</span><br><span class="line">    默认的格式是：“包名.类名@哈希值<span class="number">16</span>进制”</span><br></pre></td></tr></table></figure>
<p>假设有一个学生类如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再定义一个测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;赵敏&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        System.out.println(s1.toString()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果如下</p>
<p><img src="https://s2.loli.net/2024/05/05/nwLXRsxtS9KbEiP.webp" alt="1665753662732"></p>
<p>如果，在Student类重写toString()方法，那么我们可以返回对象的属性值，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;name=‘&quot;</span>+name+<span class="string">&quot;’, age=&quot;</span>+age+<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试类，结果如下</p>
<p><img src="https://s2.loli.net/2024/05/05/cYivmTFHatCQ4Df.webp" alt="1665754067446"></p>
<blockquote>
<p><strong>4.1.2 equals(Object o)方法</strong></p>
</blockquote>
<p>接下来，我们学习一下Object类的equals方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span></span><br><span class="line">    判断此对象与参数对象是否<span class="string">&quot;相等&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们写一个测试类，测试一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;赵薇&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;赵薇&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//equals本身也是比较对象的地址，和&quot;==&quot;没有区别</span></span><br><span class="line">        System.out.println(s1.equals(s2)); <span class="comment">//false</span></span><br><span class="line">         <span class="comment">//&quot;==&quot;比较对象的地址</span></span><br><span class="line">        System.out.println(s1==s2); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果我们在Student类中，把equals方法重写了，就按照对象的属性值进行比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;name=‘&quot;</span>+name+<span class="string">&quot;’, age=&quot;</span>+age+<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写equals方法，按照对象的属性值进行比较</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (age != student.age) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="literal">null</span> ? name.equals(student.name) : student.name == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再运行测试类，效果如下</p>
<p><img src="https://s2.loli.net/2024/05/05/zNbaXM4VfrjYG1L.webp" alt="1665754859931"></p>
<p>总结一下Object的toString方法和equals方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">   	返回对象的字符串表示形式。默认的格式是：“包名.类名@哈希值<span class="number">16</span>进制”</span><br><span class="line">   	【子类重写后，返回对象的属性值】</span><br><span class="line">   	</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span></span><br><span class="line">    判断此对象与参数对象是否<span class="string">&quot;相等&quot;</span>。默认比较对象的地址值，和<span class="string">&quot;==&quot;</span>没有区别</span><br><span class="line">    【子类重写后，比较对象的属性值】</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>4.1.3 clone() 方法</strong></p>
</blockquote>
<p>接下来，我们学习Object类的clone()方法，克隆。意思就是某一个对象调用这个方法，这个方法会复制一个一模一样的新对象，并返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span></span><br><span class="line">    克隆当前对象，返回一个新对象</span><br></pre></td></tr></table></figure>
<p>想要调用clone()方法，必须让被克隆的类实现Cloneable接口。如我们准备克隆User类的对象，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id; <span class="comment">//编号</span></span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span>[] scores; <span class="comment">//分数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String id, String username, String password, <span class="type">double</span>[] scores)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.scores = scores;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...get和set...方法自己加上</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，我们写一个测试类，克隆User类的对象。并观察打印的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;wo666&quot;</span>,<span class="keyword">new</span> <span class="title class_">double</span>[]&#123;<span class="number">99.0</span>,<span class="number">99.5</span>&#125;);</span><br><span class="line">		<span class="comment">//调用方法克隆得到一个新对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> (User) u1.clone();</span><br><span class="line">        System.out.println(u2.getId());</span><br><span class="line">        System.out.println(u2.getUsername());</span><br><span class="line">        System.out.println(u2.getPassword());</span><br><span class="line">        System.out.println(u2.getScores()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现，克隆得到的对象u2它的属性值和原来u1对象的属性值是一样的。</p>
<p><img src="https://s2.loli.net/2024/05/05/hAdxwJPB9NXLiCr.webp" alt="1665757008178"></p>
<p>上面演示的克隆方式，是一种浅克隆的方法，浅克隆的意思：<strong>拷贝出来的对象封装的数据与原对象封装的数据一模一样（引用类型拷贝的是地址值）</strong>。如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/05/n4LPgJ5OGvNY9BI.webp" alt="1665757187877"></p>
<p>还有一种拷贝方式，称之为深拷贝，拷贝原理如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/05/hbX6TYH1RMG3uUC.webp" alt="1665757265609"></p>
<p>下面演示一下深拷贝User对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id; <span class="comment">//编号</span></span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span>[] scores; <span class="comment">//分数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String id, String username, String password, <span class="type">double</span>[] scores)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.scores = scores;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...get和set...方法自己加上</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="comment">//先克隆得到一个新对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User) <span class="built_in">super</span>.clone();</span><br><span class="line">        <span class="comment">//再将新对象中的引用类型数据，再次克隆</span></span><br><span class="line">        u.scores = u.scores.clone();</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/05/05/9yKpVLnebHIFc7J.webp" alt="1665757536274"></p>
<h3 id="4-2-Objects类">4.2 Objects类</h3>
<p>Objects是一个工具类，提供了一些方法可以对任意对象进行操作。主要方法如下</p>
<p><img src="https://s2.loli.net/2024/05/05/b9JZkaORAsuzPlG.webp" alt="1665760840329"></p>
<p>下面写代码演示一下这几个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;itheima&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里会出现NullPointerException异常，调用者不能为null</span></span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">        <span class="comment">//此时不会有NullPointerException异常，底层会自动先判断空</span></span><br><span class="line">        System.out.println(Objects.equals(s1,s2));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断对象是否为null，等价于==</span></span><br><span class="line">        System.out.println(Objects.isNull(s1)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1==<span class="literal">null</span>); <span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断对象是否不为null，等价于!=</span></span><br><span class="line">        System.out.println(Objects.nonNull(s2)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s2!=<span class="literal">null</span>); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-基本类型包装类">4.3 基本类型包装类</h3>
<p>为什么要学习包装类呢？因为在Java中有一句很经典的话，万物皆对象。Java中的8种基本数据类型还不是对象，所以要把它们变成对象，变成对象之后，可以提供一些方法对数据进行操作。</p>
<p>Java中8种基本数据类型都用一个包装类与之对一个，如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/05/adO8gr5SmbACTsk.webp" alt="1665758797003"></p>
<p>学习包装类两要点：</p>
<ul>
<li>
<ol>
<li>创建包装类的对象方式、自动装箱和拆箱的特性；</li>
</ol>
</li>
<li>
<ol start="2">
<li>利用包装类提供的方法对字符串和基本类型数据进行相互转换</li>
</ol>
</li>
</ul>
<blockquote>
<p><strong>4.2.1 创建包装类对象</strong></p>
</blockquote>
<p>我们先来学习，创建包装类对象的方法，以及包装类的一个特性叫自动装箱和自动拆箱。我们以Integer为例，其他的都是类似的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建Integer对象，封装基本类型数据10</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用Integer类的静态方法valueOf(数据)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.还有一种自动装箱的写法（意思就是自动将基本类型转换为引用类型）</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.有装箱肯定还有拆箱（意思就是自动将引用类型转换为基本类型）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.装箱和拆箱在使用集合时就有体现</span></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//添加的元素是基本类型，实际上会自动装箱为Integer类型</span></span><br><span class="line">list.add(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//获取元素时，会将Integer类型自动拆箱为int类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>4.2.2 包装类数据类型转换</strong></p>
</blockquote>
<p>在开发中，经常使用包装类对字符串和基本类型数据进行相互转换。</p>
<ul>
<li>把字符串转换为数值型数据：包装类.parseXxx(字符串)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parseInt</span><span class="params">(String s)</span></span><br><span class="line">    把字符串转换为基本数据类型</span><br></pre></td></tr></table></figure>
<ul>
<li>将数值型数据转换为字符串：包装类.valueOf(数据);</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">    把基本类型数据转换为</span><br></pre></td></tr></table></figure>
<ul>
<li>写一个测试类演示一下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.字符串转换为数值型数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">ageStr</span> <span class="operator">=</span> <span class="string">&quot;29&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">age1</span> <span class="operator">=</span> Integer.parseInt(ageStr);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">scoreStr</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> Double.prarseDouble(scoreStr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.整数转换为字符串，以下几种方式都可以（挑中你喜欢的记一下）</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> Integer.toString(a);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> a.toString();</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> a+<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> String.valueOf(a);</span><br></pre></td></tr></table></figure>
<h1 id="常用API">常用API</h1>
<h2 id="一、-StringBuilder类">一、 StringBuilder类</h2>
<ul>
<li>StringBuilder代表可变字符串对象，相当于是一个容器，它里面的字符串是可以改变的，就是用来操作字符串的。</li>
<li>好处：StringBuilder比String更合适做字符串的修改操作，效率更高，代码也更加简洁。</li>
</ul>
<p><strong>1.1 StringBuilder方法演示</strong></p>
<p>接下来我们用代码演示一下StringBuilder的用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;itehima&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.拼接内容</span></span><br><span class="line">        sb.append(<span class="number">12</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;黑马&quot;</span>);</span><br><span class="line">        sb.append(<span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.append方法，支持临时编程</span></span><br><span class="line">        sb.append(<span class="number">666</span>).append(<span class="string">&quot;黑马2&quot;</span>).append(<span class="number">666</span>);</span><br><span class="line">        System.out.println(sb); <span class="comment">//打印：12黑马666黑马2666</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.反转操作</span></span><br><span class="line">        sb.reverse();</span><br><span class="line">        System.out.println(sb); <span class="comment">//打印：6662马黑666马黑21</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.返回字符串的长度</span></span><br><span class="line">        System.out.println(sb.length());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.StringBuilder还可以转换为字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        System.out.println(s); <span class="comment">//打印：6662马黑666马黑21</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要用StringBuilder对字符串进行操作呢？因为它的效率比String更高，我们可以下面两段代码验证一下。</p>
<p><img src="https://s2.loli.net/2024/05/05/dnPgIqc5p8Wf3YT.webp" alt="1667402173587"></p>
<p>经过验证，直接使用Stirng拼接100万次，等了1分钟，还没结束，我等不下去了；但是使用StringBuilder做拼接，不到1秒钟出结果了。</p>
<p><strong>1.2 StringBuilder应用案例</strong></p>
<p>通过一个案例把StringBuilder运用下，案例需求如下图所示</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> getArrayData( <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>&#125;);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法作用：将int数组转换为指定格式的字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getArrayData</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="comment">//1.判断数组是否为null</span></span><br><span class="line">        <span class="keyword">if</span>(arr==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.如果数组不为null，再遍历，并拼接数组中的元素</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==arr.legnth-<span class="number">1</span>)&#123;</span><br><span class="line">                sb.append(arr[i]).append(<span class="string">&quot;]&quot;</span>);;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(arr[i]).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、把StirngBuilder转换为String，并返回。</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、StringJoiner类">二、StringJoiner类</h2>
<p>StringJoiner号称是拼接神器，不仅效率高，而且代码简洁。</p>
<p>下面演示一下StringJoiner的基本使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">StringJoiner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        s.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">        s.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">        s.add(<span class="string">&quot;java3&quot;</span>);</span><br><span class="line">        System.out.println(s); <span class="comment">//结果为： java1,java2,java3</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//参数1：间隔符</span></span><br><span class="line">        <span class="comment">//参数2：开头</span></span><br><span class="line">        <span class="comment">//参数3：结尾</span></span><br><span class="line">        <span class="type">StringJoiner</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;,&quot;</span>,<span class="string">&quot;[&quot;</span>,<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        s1.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">        s1.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">        s1.add(<span class="string">&quot;java3&quot;</span>);</span><br><span class="line">        System.out.println(s1); <span class="comment">//结果为： [java1,java2,java3]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用StirngJoiner改写前面把数组转换为字符串的案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> getArrayData( <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>&#125;);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法作用：将int数组转换为指定格式的字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getArrayData</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="comment">//1.判断数组是否为null</span></span><br><span class="line">        <span class="keyword">if</span>(arr==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.如果数组不为null，再遍历，并拼接数组中的元素</span></span><br><span class="line">        <span class="type">StringJoiner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;, &quot;</span>,<span class="string">&quot;[&quot;</span>,<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            <span class="comment">//加&quot;&quot;是因为add方法的参数要的是String类型</span></span><br><span class="line">            s.add(String.valueOf(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、把StringJoiner转换为String，并返回。</span></span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、Math类">三、Math类</h2>
<p>Math是数学的意思，该类提供了很多个进行数学运算的方法，如求绝对值，求最大值，四舍五入等，话不多说，直接上代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：了解下Math类提供的常见方法。</span></span><br><span class="line">        <span class="comment">// 1、public static int abs(int a)：取绝对值（拿到的结果一定是正数）</span></span><br><span class="line">        <span class="comment">//    public static double abs(double a)</span></span><br><span class="line">        System.out.println(Math.abs(-<span class="number">12</span>)); <span class="comment">// 12</span></span><br><span class="line">        System.out.println(Math.abs(<span class="number">123</span>)); <span class="comment">// 123</span></span><br><span class="line">        System.out.println(Math.abs(-<span class="number">3.14</span>)); <span class="comment">// 3.14</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、public static double ceil(double a): 向上取整</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">4.0000001</span>)); <span class="comment">// 5.0</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">4.0</span>)); <span class="comment">// 4.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、public static double floor(double a): 向下取整</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">4.999999</span>)); <span class="comment">// 4.0</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">4.0</span>)); <span class="comment">// 4.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、public static long round(double a)：四舍五入</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">3.4999</span>)); <span class="comment">// 3</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">3.50001</span>)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、public static int max(int a, int b)：取较大值</span></span><br><span class="line">        <span class="comment">//   public static int min(int a, int b)：取较小值</span></span><br><span class="line">        System.out.println(Math.max(<span class="number">10</span>, <span class="number">20</span>)); <span class="comment">// 20</span></span><br><span class="line">        System.out.println(Math.min(<span class="number">10</span>, <span class="number">20</span>)); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、 public static double pow(double a, double b)：取次方</span></span><br><span class="line">        System.out.println(Math.pow(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 2的3次方   8.0</span></span><br><span class="line">        System.out.println(Math.pow(<span class="number">3</span>, <span class="number">2</span>)); <span class="comment">// 3的2次方   9.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7、public static double random()： 取随机数 [0.0 , 1.0) (包前不包后)</span></span><br><span class="line">        System.out.println(Math.random());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、-System类">四、 System类</h2>
<p>System类，这是系统类，提供了一些获取获取系统数据的方法。比如获取系统时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：了解下System类的常见方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、public static void exit(int status):</span></span><br><span class="line">        <span class="comment">//   终止当前运行的Java虚拟机。</span></span><br><span class="line">        <span class="comment">//   该参数用作状态代码; 按照惯例，非零状态代码表示异常终止。</span></span><br><span class="line">        System.exit(<span class="number">0</span>); <span class="comment">// 人为的终止虚拟机。(不要使用)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、public static long currentTimeMillis():</span></span><br><span class="line">        <span class="comment">//    获取当前系统的时间</span></span><br><span class="line">        <span class="comment">//    返回的是long类型的时间毫秒值：指的是从1970-1-1 0:0:0开始走到此刻的总的毫秒值，1s = 1000ms</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(time);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输出了：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">time2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println((time2 - time) / <span class="number">1000.0</span> + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、Runtime类">五、Runtime类</h2>
<p>Java的运行时类，叫Runtime类。这个类可以用来获取JVM的一些信息，也可以用这个类去执行其他的程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：了解下Runtime的几个常见方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuntimeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、public static Runtime getRuntime() 返回与当前Java应用程序关联的运行时对象。</span></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、public void exit(int status) 终止当前运行的虚拟机,该参数用作状态代码; 按照惯例，非零状态代码表示异常终止。</span></span><br><span class="line">        <span class="comment">// r.exit(0);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、public int availableProcessors(): 获取虚拟机能够使用的处理器数。</span></span><br><span class="line">        System.out.println(r.availableProcessors());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、public long totalMemory() 返回Java虚拟机中的内存总量。</span></span><br><span class="line">        System.out.println(r.totalMemory()/<span class="number">1024.0</span>/<span class="number">1024.0</span> + <span class="string">&quot;MB&quot;</span>); <span class="comment">// 1024 = 1K     1024 * 1024 = 1M</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、public long freeMemory() 返回Java虚拟机中的可用内存量</span></span><br><span class="line">        System.out.println(r.freeMemory()/<span class="number">1024.0</span>/<span class="number">1024.0</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、public Process exec(String command) 启动某个程序，并返回代表该程序的对象。</span></span><br><span class="line">        <span class="comment">// r.exec(&quot;D:\\soft\\XMind\\XMind.exe&quot;);</span></span><br><span class="line">        <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> r.exec(<span class="string">&quot;QQ&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>); <span class="comment">// 让程序在这里暂停5s后继续往下走！！</span></span><br><span class="line">        p.destroy(); <span class="comment">// 销毁！关闭程序！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、BigDecimal类">六、BigDecimal类</h2>
<p>我们先看一段代码，看这个代码有什么问题？再说BigDeimal这个类是干什么用的，这样会更好理解一些。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="number">0.1</span> + <span class="number">0.2</span>);</span><br><span class="line">        System.out.println(<span class="number">1.0</span> - <span class="number">0.32</span>);</span><br><span class="line">        System.out.println(<span class="number">1.015</span> * <span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="number">1.301</span> / <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行以上代码，我们会发现，结果并和我们想看到的不太一样。如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/05/gEBeTP2lRJSqZoh.webp" alt="1667398959905"></p>
<p>为了解决计算精度损失的问题，Java给我们提供了BigDecimal类，它提供了一些方法可以对数据进行四则运算，而且不丢失精度，同时还可以保留指定的小数位。下面看代码，演示一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握BigDecimal进行精确运算的方案。</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0.1</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、把浮点型数据封装成BigDecimal对象，再来参与运算。</span></span><br><span class="line">        <span class="comment">// a、public BigDecimal(double val) 得到的BigDecimal对象是无法精确计算浮点型数据的。 注意：不推荐使用这个，</span></span><br><span class="line">        <span class="comment">// b、public BigDecimal(String val)  得到的BigDecimal对象是可以精确计算浮点型数据的。 可以使用。</span></span><br><span class="line">        <span class="comment">// c、public static BigDecimal valueOf(double val): 通过这个静态方法得到的BigDecimal对象是可以精确运算的。是最好的方案。</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">a1</span> <span class="operator">=</span> BigDecimal.valueOf(a);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、public BigDecimal add(BigDecimal augend): 加法</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">c1</span> <span class="operator">=</span> a1.add(b1);</span><br><span class="line">        System.out.println(c1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、public BigDecimal subtract(BigDecimal augend): 减法</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">c2</span> <span class="operator">=</span> a1.subtract(b1);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、public BigDecimal multiply(BigDecimal augend): 乘法</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">c3</span> <span class="operator">=</span> a1.multiply(b1);</span><br><span class="line">        System.out.println(c3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、public BigDecimal divide(BigDecimal b): 除法</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">c4</span> <span class="operator">=</span> a1.divide(b1);</span><br><span class="line">        System.out.println(c4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        BigDecimal d1 = BigDecimal.valueOf(0.1);</span></span><br><span class="line"><span class="comment">//        BigDecimal d2 = BigDecimal.valueOf(0.3);</span></span><br><span class="line"><span class="comment">//        BigDecimal d3 = d1.divide(d2);</span></span><br><span class="line"><span class="comment">//        System.out.println(d3);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、public BigDecimal divide(另一个BigDecimal对象，精确几位，舍入模式) : 除法，可以设置精确几位。</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">d1</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">0.1</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">d2</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">0.3</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">d3</span> <span class="operator">=</span> d1.divide(d2,  <span class="number">2</span>, RoundingMode.HALF_UP); <span class="comment">// 0.33</span></span><br><span class="line">        System.out.println(d3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7、public double doubleValue() : 把BigDecimal对象又转换成double类型的数据。</span></span><br><span class="line">        <span class="comment">//print(d3);</span></span><br><span class="line">        <span class="comment">//print(c1);</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">db1</span> <span class="operator">=</span> d3.doubleValue();</span><br><span class="line">        <span class="type">double</span> <span class="variable">db2</span> <span class="operator">=</span> c1.doubleValue();</span><br><span class="line">        print(db1);</span><br><span class="line">        print(db2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">double</span> a)</span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="五、Date类">五、Date类</h2>
<p>Date类，Java中是由这个类的对象用来表示日期或者时间。</p>
<p>Date对象记录的时间是用毫秒值来表示的。Java语言规定，1970年1月1日0时0分0秒认为是时间的起点，此时记作0，那么1000（1秒=1000毫秒）就表示1970年1月1日0时0分1秒，依次类推。</p>
<p><img src="https://s2.loli.net/2024/05/05/qDlU1wfiyQGCgWx.webp" alt="1667399304240"></p>
<p>下面是Date类的构造方法，和常见的成员方法，利用这些API写代码尝试一下</p>
<p><img src="https://s2.loli.net/2024/05/05/wCt5YmcsWK4Ul3Z.webp" alt="1667399443159"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1Date</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握Date日期类的使用。</span></span><br><span class="line">        <span class="comment">// 1、创建一个Date的对象：代表系统当前时间信息的。</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、拿到时间毫秒值。</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> d.getTime();</span><br><span class="line">        System.out.println(time);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、把时间毫秒值转换成日期对象： 2s之后的时间是多少。</span></span><br><span class="line">        time += <span class="number">2</span> * <span class="number">1000</span>;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(time);</span><br><span class="line">        System.out.println(d2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、直接把日期对象的时间通过setTime方法进行修改</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        d3.setTime(time);</span><br><span class="line">        System.out.println(d3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、SimpleDateFormat类">六、SimpleDateFormat类</h2>
<blockquote>
<p>SimpleDateFormat类就可以转换Date对象表示日期时间的显示格式。</p>
</blockquote>
<ul>
<li>
<p>我们把Date对象转换为指定格式的日期字符串这个操作，叫做<strong>日期格式化，</strong></p>
</li>
<li>
<p>反过来把指定格式的日期符串转换为Date对象的操作，叫做<strong>日期解析。</strong></p>
</li>
</ul>
<p>接下来，我们先演示一下日期格式化，需要用到如下的几个方法</p>
<p><img src="https://s2.loli.net/2024/05/05/BmvzY3MV59n8pW2.webp" alt="1667399804244"></p>
<p>注意：创建SimpleDateFormat对象时，在构造方法的参数位置传递日期格式，而日期格式是由一些特定的字母拼接而来的。我们需要记住常用的几种日期/时间格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">字母	   表示含义</span><br><span class="line">yyyy	年</span><br><span class="line">MM		月</span><br><span class="line">dd		日</span><br><span class="line">HH		时</span><br><span class="line">mm		分</span><br><span class="line">ss		秒</span><br><span class="line">SSS		毫秒</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;2022年12月12日&quot;</span> 的格式是 <span class="string">&quot;yyyy年MM月dd日&quot;</span></span><br><span class="line"><span class="string">&quot;2022-12-12 12:12:12&quot;</span> 的格式是 <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span></span><br><span class="line">按照上面的格式可以任意拼接，但是字母不能写错</span><br></pre></td></tr></table></figure>
<p>最后，上代码演示一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2SimpleDateFormat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握SimpleDateFormat的使用。</span></span><br><span class="line">        <span class="comment">// 1、准备一些时间</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(d);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> d.getTime();</span><br><span class="line">        System.out.println(time);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、格式化日期对象，和时间 毫秒值。</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss EEE a&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> sdf.format(d);</span><br><span class="line">        <span class="type">String</span> <span class="variable">rs2</span> <span class="operator">=</span> sdf.format(time);</span><br><span class="line">        System.out.println(rs);</span><br><span class="line">        System.out.println(rs2);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目标：掌握SimpleDateFormat解析字符串时间 成为日期对象。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> <span class="string">&quot;2022-12-12 12:12:11&quot;</span>;</span><br><span class="line">        <span class="comment">// 1、创建简单日期格式化对象 , 指定的时间格式必须与被解析的时间格式一模一样，否则程序会出bug.</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> sdf2.parse(dateStr);</span><br><span class="line">        System.out.println(d2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七、Calendar类">七、Calendar类</h2>
<p>Calendar类表示日历，它提供了一些比Date类更好用的方法。</p>
<p><img src="https://s2.loli.net/2024/05/05/GXxZnrf24eH67va.webp" alt="1667400365583"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4Calendar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握Calendar的使用和特点。</span></span><br><span class="line">        <span class="comment">// 1、得到系统此刻时间对应的日历对象。</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">now</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        System.out.println(now);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、获取日历中的某个信息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> now.get(Calendar.YEAR);</span><br><span class="line">        System.out.println(year);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> now.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">        System.out.println(days);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、拿到日历中记录的日期对象。</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> now.getTime();</span><br><span class="line">        System.out.println(d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、拿到时间毫秒值</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> now.getTimeInMillis();</span><br><span class="line">        System.out.println(time);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、修改日历中的某个信息</span></span><br><span class="line">        now.set(Calendar.MONTH, <span class="number">9</span>); <span class="comment">// 修改月份成为10月份。</span></span><br><span class="line">        now.set(Calendar.DAY_OF_YEAR, <span class="number">125</span>); <span class="comment">// 修改成一年中的第125天。</span></span><br><span class="line">        System.out.println(now);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、为某个信息增加或者减少多少</span></span><br><span class="line">        now.add(Calendar.DAY_OF_YEAR, <span class="number">100</span>);</span><br><span class="line">        now.add(Calendar.DAY_OF_YEAR, -<span class="number">10</span>);</span><br><span class="line">        now.add(Calendar.DAY_OF_MONTH, <span class="number">6</span>);</span><br><span class="line">        now.add(Calendar.HOUR, <span class="number">12</span>);</span><br><span class="line">        now.set(<span class="number">2026</span>, <span class="number">11</span>, <span class="number">22</span>);</span><br><span class="line">        System.out.println(now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="八、为什么JDK8要新增日期类">八、为什么JDK8要新增日期类</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：搞清楚为什么要用JDK 8开始新增的时间类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 传统的时间类（Date、SimpleDateFormat、Calendar）存在如下问题：</span></span><br><span class="line">        <span class="comment">// 1、设计不合理，使用不方便，很多都被淘汰了。</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="comment">//System.out.println(d.getYear() + 1900);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> c.get(Calendar.YEAR);</span><br><span class="line">        System.out.println(year);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、都是可变对象，修改后会丢失最开始的时间信息。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、线程不安全。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、不能精确到纳秒，只能精确到毫秒。</span></span><br><span class="line">        <span class="comment">// 1秒 = 1000毫秒</span></span><br><span class="line">        <span class="comment">// 1毫秒 = 1000微妙</span></span><br><span class="line">        <span class="comment">// 1微妙 = 1000纳秒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="九、JDK8日期、时间、日期时间">九、JDK8日期、时间、日期时间</h2>
<p>JDK8新增的日期类。为什么以前的Date类就可以表示日期，为什么要有新增的日期类呢？原因如下</p>
<p><img src="https://s2.loli.net/2024/05/05/inCNrcoqVBPb13a.webp" alt="1667400465054"></p>
<p>JDK8新增的日期类分得更细致一些，比如表示年月日用LocalDate类、表示时间秒用LocalTime类、而表示年月日时分秒用LocalDateTime类等；除了这些类还提供了对时区、时间间隔进行操作的类等。它们几乎把对日期/时间的所有操作都通过了API方法，用起来特别方便。</p>
<p><img src="https://s2.loli.net/2024/05/05/ECMhF5AD8qnmSXH.webp" alt="1667400655334"></p>
<p>先学习表示日期、时间、日期时间的类；有LocalDate、LocalTime、以及LocalDateTime类。仔细阅读代码，你会发现这三个类的用法套路都是一样的。</p>
<ul>
<li>LocalDate类的基本使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1_LocalDate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 0、获取本地日期对象(不可变对象)</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld</span> <span class="operator">=</span> LocalDate.now(); <span class="comment">// 年 月 日</span></span><br><span class="line">        System.out.println(ld);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、获取日期对象中的信息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> ld.getYear(); <span class="comment">// 年</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> ld.getMonthValue(); <span class="comment">// 月(1-12)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> ld.getDayOfMonth(); <span class="comment">// 日</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfYear</span> <span class="operator">=</span> ld.getDayOfYear();  <span class="comment">// 一年中的第几天</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> ld.getDayOfWeek().getValue(); <span class="comment">// 星期几</span></span><br><span class="line">        System.out.println(year);</span><br><span class="line">        System.out.println(day);</span><br><span class="line">        System.out.println(dayOfWeek);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、直接修改某个信息: withYear、withMonth、withDayOfMonth、withDayOfYear</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld2</span> <span class="operator">=</span> ld.withYear(<span class="number">2099</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld3</span> <span class="operator">=</span> ld.withMonth(<span class="number">12</span>);</span><br><span class="line">        System.out.println(ld2);</span><br><span class="line">        System.out.println(ld3);</span><br><span class="line">        System.out.println(ld);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、把某个信息加多少: plusYears、plusMonths、plusDays、plusWeeks</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld4</span> <span class="operator">=</span> ld.plusYears(<span class="number">2</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld5</span> <span class="operator">=</span> ld.plusMonths(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、把某个信息减多少：minusYears、minusMonths、minusDays、minusWeeks</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld6</span> <span class="operator">=</span> ld.minusYears(<span class="number">2</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld7</span> <span class="operator">=</span> ld.minusMonths(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、获取指定日期的LocalDate对象： public static LocalDate of(int year, int month, int dayOfMonth)</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld8</span> <span class="operator">=</span> LocalDate.of(<span class="number">2099</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld9</span> <span class="operator">=</span> LocalDate.of(<span class="number">2099</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、判断2个日期对象，是否相等，在前还是在后： equals isBefore isAfter</span></span><br><span class="line">        System.out.println(ld8.equals(ld9));<span class="comment">// true</span></span><br><span class="line">        System.out.println(ld8.isAfter(ld)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(ld8.isBefore(ld)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>LocalTime类的基本使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2_LocalTime</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 0、获取本地时间对象</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt</span> <span class="operator">=</span> LocalTime.now(); <span class="comment">// 时 分 秒 纳秒 不可变的</span></span><br><span class="line">        System.out.println(lt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、获取时间中的信息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> lt.getHour(); <span class="comment">//时</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> lt.getMinute(); <span class="comment">//分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> lt.getSecond(); <span class="comment">//秒</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nano</span> <span class="operator">=</span> lt.getNano(); <span class="comment">//纳秒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、修改时间：withHour、withMinute、withSecond、withNano</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt3</span> <span class="operator">=</span> lt.withHour(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt4</span> <span class="operator">=</span> lt.withMinute(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt5</span> <span class="operator">=</span> lt.withSecond(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt6</span> <span class="operator">=</span> lt.withNano(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、加多少：plusHours、plusMinutes、plusSeconds、plusNanos</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt7</span> <span class="operator">=</span> lt.plusHours(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt8</span> <span class="operator">=</span> lt.plusMinutes(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt9</span> <span class="operator">=</span> lt.plusSeconds(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt10</span> <span class="operator">=</span> lt.plusNanos(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、减多少：minusHours、minusMinutes、minusSeconds、minusNanos</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt11</span> <span class="operator">=</span> lt.minusHours(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt12</span> <span class="operator">=</span> lt.minusMinutes(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt13</span> <span class="operator">=</span> lt.minusSeconds(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt14</span> <span class="operator">=</span> lt.minusNanos(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、获取指定时间的LocalTime对象：</span></span><br><span class="line">        <span class="comment">// public static LocalTime of(int hour, int minute, int second)</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt15</span> <span class="operator">=</span> LocalTime.of(<span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt16</span> <span class="operator">=</span> LocalTime.of(<span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、判断2个时间对象，是否相等，在前还是在后： equals isBefore isAfter</span></span><br><span class="line">        System.out.println(lt15.equals(lt16)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(lt15.isAfter(lt)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(lt15.isBefore(lt)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>LocalDateTime类的基本使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3_LocalDateTime</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 0、获取本地日期和时间对象。</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now(); <span class="comment">// 年 月 日 时 分 秒 纳秒</span></span><br><span class="line">        System.out.println(ldt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、可以获取日期和时间的全部信息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> ldt.getYear(); <span class="comment">// 年</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> ldt.getMonthValue(); <span class="comment">// 月</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> ldt.getDayOfMonth(); <span class="comment">// 日</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfYear</span> <span class="operator">=</span> ldt.getDayOfYear();  <span class="comment">// 一年中的第几天</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> ldt.getDayOfWeek().getValue();  <span class="comment">// 获取是周几</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> ldt.getHour(); <span class="comment">//时</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> ldt.getMinute(); <span class="comment">//分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> ldt.getSecond(); <span class="comment">//秒</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nano</span> <span class="operator">=</span> ldt.getNano(); <span class="comment">//纳秒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、修改时间信息：</span></span><br><span class="line">        <span class="comment">// withYear withMonth withDayOfMonth withDayOfYear withHour</span></span><br><span class="line">        <span class="comment">// withMinute withSecond withNano</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt2</span> <span class="operator">=</span> ldt.withYear(<span class="number">2029</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt3</span> <span class="operator">=</span> ldt.withMinute(<span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、加多少:</span></span><br><span class="line">        <span class="comment">// plusYears  plusMonths plusDays plusWeeks plusHours plusMinutes plusSeconds plusNanos</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt4</span> <span class="operator">=</span> ldt.plusYears(<span class="number">2</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt5</span> <span class="operator">=</span> ldt.plusMinutes(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、减多少：</span></span><br><span class="line">        <span class="comment">// minusDays minusYears minusMonths minusWeeks minusHours minusMinutes minusSeconds minusNanos</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt6</span> <span class="operator">=</span> ldt.minusYears(<span class="number">2</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt7</span> <span class="operator">=</span> ldt.minusMinutes(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、获取指定日期和时间的LocalDateTime对象：</span></span><br><span class="line">        <span class="comment">// public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour,</span></span><br><span class="line">        <span class="comment">//                                  int minute, int second, int nanoOfSecond)</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt8</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2029</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">1222</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt9</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2029</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">1222</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、 判断2个日期、时间对象，是否相等，在前还是在后： equals、isBefore、isAfter</span></span><br><span class="line">        System.out.println(ldt9.equals(ldt8));</span><br><span class="line">        System.out.println(ldt9.isAfter(ldt));</span><br><span class="line">        System.out.println(ldt9.isBefore(ldt));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7、可以把LocalDateTime转换成LocalDate和LocalTime</span></span><br><span class="line">        <span class="comment">// public LocalDate toLocalDate()</span></span><br><span class="line">        <span class="comment">// public LocalTime toLocalTime()</span></span><br><span class="line">        <span class="comment">// public static LocalDateTime of(LocalDate date, LocalTime time)</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld</span> <span class="operator">=</span> ldt.toLocalDate();</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt</span> <span class="operator">=</span> ldt.toLocalTime();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt10</span> <span class="operator">=</span> LocalDateTime.of(ld, lt);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="十、JDK8日期（时区）">十、JDK8日期（时区）</h2>
<p>代表时区的两个类。由于世界各个国家与地区的经度不同，各地区的时间也有所不同，因此会划分为不同的时区。每一个时区的时间也不太一样。</p>
<p><img src="https://s2.loli.net/2024/05/05/xCbDHfFPXZYNWET.webp" alt="1667400888534"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4_ZoneId_ZonedDateTime</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：了解时区和带时区的时间。</span></span><br><span class="line">        <span class="comment">// 1、ZoneId的常见方法：</span></span><br><span class="line">        <span class="comment">// public static ZoneId systemDefault(): 获取系统默认的时区</span></span><br><span class="line">        <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">        System.out.println(zoneId.getId());</span><br><span class="line">        System.out.println(zoneId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// public static Set&lt;String&gt; getAvailableZoneIds(): 获取Java支持的全部时区Id</span></span><br><span class="line">        System.out.println(ZoneId.getAvailableZoneIds());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// public static ZoneId of(String zoneId) : 把某个时区id封装成ZoneId对象。</span></span><br><span class="line">        <span class="type">ZoneId</span> <span class="variable">zoneId1</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、ZonedDateTime：带时区的时间。</span></span><br><span class="line">        <span class="comment">// public static ZonedDateTime now(ZoneId zone): 获取某个时区的ZonedDateTime对象。</span></span><br><span class="line">        <span class="type">ZonedDateTime</span> <span class="variable">now</span> <span class="operator">=</span> ZonedDateTime.now(zoneId1);</span><br><span class="line">        System.out.println(now);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 世界标准时间了</span></span><br><span class="line">        <span class="type">ZonedDateTime</span> <span class="variable">now1</span> <span class="operator">=</span> ZonedDateTime.now(Clock.systemUTC());</span><br><span class="line">        System.out.println(now1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// public static ZonedDateTime now()：获取系统默认时区的ZonedDateTime对象</span></span><br><span class="line">        <span class="type">ZonedDateTime</span> <span class="variable">now2</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">        System.out.println(now2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calendar instance = Calendar.getInstance(TimeZone.getTimeZone(zoneId1));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="十一、JDK8日期（Instant类）">十一、JDK8日期（Instant类）</h2>
<p>Instant类。通过获取Instant的对象可以拿到此刻的时间，该时间由两部分组成：从1970-01-01 00:00:00 开始走到此刻的总秒数+不够1秒的纳秒数。</p>
<p><img src="https://s2.loli.net/2024/05/05/3ExcNdkKQ1pygUl.webp" alt="1667401284295"></p>
<p>该类提供的方法如下图所示，可以用来获取当前时间，也可以对时间进行加、减、获取等操作。</p>
<p><img src="https://s2.loli.net/2024/05/05/oB3cAQ7hZuVyp5I.webp" alt="1667401373923"></p>
<p><strong>作用：可以用来记录代码的执行时间，或用于记录用户操作某个事件的时间点。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握Instant的使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5_Instant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">// 1、创建Instant的对象，获取此刻时间信息</span></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> Instant.now(); <span class="comment">// 不可变对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、获取总秒数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">second</span> <span class="operator">=</span> now.getEpochSecond();</span><br><span class="line">        System.out.println(second);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、不够1秒的纳秒数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nano</span> <span class="operator">=</span> now.getNano();</span><br><span class="line">        System.out.println(nano);</span><br><span class="line"></span><br><span class="line">        System.out.println(now);</span><br><span class="line"></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> now.plusNanos(<span class="number">111</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Instant对象的作用：做代码的性能分析，或者记录用户的操作时间点</span></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">now1</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">        <span class="comment">// 代码执行。。。。</span></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">now2</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">l</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="十二、JDK8日期（格式化器）">十二、JDK8日期（格式化器）</h2>
<p>日期格式化类，叫DateTimeFormater。它可以从来对日期进行格式化和解析。它代替了原来的SimpleDateFormat类。</p>
<p><img src="https://s2.loli.net/2024/05/05/jP48ygqWMERGwvD.webp" alt="1667401511710"></p>
<p>需要用到的方法，如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/05/Nu9tiBnoeLXZgOS.webp" alt="1667401564173"></p>
<p>接下来，将上面的方法用代码来演示一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：掌握JDK 8新增的DateTimeFormatter格式化器的用法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test6_DateTimeFormatter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个日期时间格式化器对象出来。</span></span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、对时间进行格式化</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> formatter.format(now); <span class="comment">// 正向格式化</span></span><br><span class="line">        System.out.println(rs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、格式化时间，其实还有一种方案。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs2</span> <span class="operator">=</span> now.format(formatter); <span class="comment">// 反向格式化</span></span><br><span class="line">        System.out.println(rs2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、解析时间：解析时间一般使用LocalDateTime提供的解析方法来解析。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> <span class="string">&quot;2029年12月12日 12:12:11&quot;</span>;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.parse(dateStr, formatter);</span><br><span class="line">        System.out.println(ldt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="十三、JDK8日期（Period类）">十三、JDK8日期（Period类）</h2>
<p>除以了上新增的类，JDK8还补充了两个类，一个叫Period类、一个叫Duration类；这两个类可以用来对计算两个时间点的时间间隔。</p>
<p>其中Period用来计算日期间隔（年、月、日），Duration用来计算时间间隔（时、分、秒、纳秒）</p>
<p><img src="https://s2.loli.net/2024/05/05/71bvlt26JwCMAaN.webp" alt="1667401637360"></p>
<p>先来演示Period类的用法，它的方法如下图所示。可以用来计算两个日期之间相隔的年、相隔的月、相隔的日。<strong>只能两个计算LocalDate对象之间的间隔</strong></p>
<p><img src="https://s2.loli.net/2024/05/05/v9ybGOM3rHtE8K2.webp" alt="1667401886743"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握Period的作用：计算机两个日期相差的年数，月数、天数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test7_Period</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">start</span> <span class="operator">=</span> LocalDate.of(<span class="number">2029</span>, <span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">end</span> <span class="operator">=</span> LocalDate.of(<span class="number">2029</span>, <span class="number">12</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建Period对象，封装两个日期对象。</span></span><br><span class="line">        <span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(start, end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、通过period对象获取两个日期对象相差的信息。</span></span><br><span class="line">        System.out.println(period.getYears());</span><br><span class="line">        System.out.println(period.getMonths());</span><br><span class="line">        System.out.println(period.getDays());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="十四、JDK8日期（Duration类）">十四、JDK8日期（Duration类）</h2>
<p>Duration类。它是用来表示两个时间对象的时间间隔。<strong>可以用于计算两个时间对象相差的天数、小时数、分数、秒数、纳秒数；支持LocalTime、LocalDateTime、Instant等时间</strong></p>
<p><img src="https://s2.loli.net/2024/05/05/BQSMHTIj8FEUXgA.webp" alt="1667401938724"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test8_Duration</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">start</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2025</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">end</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2025</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line">        <span class="comment">// 1、得到Duration对象</span></span><br><span class="line">        <span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(start, end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、获取两个时间对象间隔的信息</span></span><br><span class="line">        System.out.println(duration.toDays());<span class="comment">// 间隔多少天</span></span><br><span class="line">        System.out.println(duration.toHours());<span class="comment">// 间隔多少小时</span></span><br><span class="line">        System.out.println(duration.toMinutes());<span class="comment">// 间隔多少分</span></span><br><span class="line">        System.out.println(duration.toSeconds());<span class="comment">// 间隔多少秒</span></span><br><span class="line">        System.out.println(duration.toMillis());<span class="comment">// 间隔多少毫秒</span></span><br><span class="line">        System.out.println(duration.toNanos());<span class="comment">// 间隔多少纳秒</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Lambda、方法引用、正则表达式">Lambda、方法引用、正则表达式</h1>
<h2 id="一、Lambda表达式">一、Lambda表达式</h2>
<p>学习一个JDK8新增的一种语法形式，叫做Lambda表达式。<strong>作用：用于简化匿名内部类代码的书写。</strong></p>
<h3 id="1-1-Lambda表达式基本使用">1.1 Lambda表达式基本使用</h3>
<p>怎么去简化呢？Lamdba是有特有的格式的，按照下面的格式来编写Lamdba。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(被重写方法的形参列表) -&gt; &#123;</span><br><span class="line">    被重写方法的方法体代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要给说明一下的是，在使用Lambda表达式之前，必须先有一个接口，而且接口中只能有一个抽象方法。<strong>（注意：不能是抽象类，只能是接口）</strong></p>
<p>像这样的接口，我们称之为函数式接口，只有基于函数式接口的匿名内部类才能被Lambda表达式简化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Swimming</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了以上的Swimming接口之后，接下来才能再演示，使用Lambda表达式，简化匿名内部类书写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：认识Lambda表达式.</span></span><br><span class="line">        <span class="comment">//1.创建一个Swimming接口的匿名内部类对象</span></span><br><span class="line">		<span class="type">Swimming</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swimming</span>()&#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                 System.out.println(<span class="string">&quot;学生快乐的游泳~~~~&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;;</span><br><span class="line">         s.swim();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//2.使用Lambda表达式对Swimming接口的匿名内部类进行简化</span></span><br><span class="line">        <span class="type">Swimming</span> <span class="variable">s1</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;学生快乐的游泳~~~~&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        s1.swim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的，我们现在已经知道Lamdba表达式可以简化基于函数式接口的匿名内部类的书写。接下来，我们可以使用Arrays方法时的代码，使用Lambda表达式简化一下了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：使用Lambda简化函数式接口。</span></span><br><span class="line">        <span class="type">double</span>[] prices = &#123;<span class="number">99.8</span>, <span class="number">128</span>, <span class="number">100</span>&#125;;</span><br><span class="line">		<span class="comment">//1.把所有元素*0.8: 先用匿名内部类写法</span></span><br><span class="line">        Arrays.setAll(prices, <span class="keyword">new</span> <span class="title class_">IntToDoubleFunction</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">applyAsDouble</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">                <span class="comment">// value = 0  1  2</span></span><br><span class="line">                <span class="keyword">return</span> prices[value] * <span class="number">0.8</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">		<span class="comment">//2.把所有元素*0.8: 改用Lamdba表达式写法</span></span><br><span class="line">        Arrays.setAll(prices, (<span class="type">int</span> value) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> prices[value] * <span class="number">0.8</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(prices));</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line">		</span><br><span class="line">        Student[] students = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">4</span>];</span><br><span class="line">        students[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">169.5</span>, <span class="number">23</span>);</span><br><span class="line">        students[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>, <span class="number">162.8</span>, <span class="number">26</span>);</span><br><span class="line">        students[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>, <span class="number">162.8</span>, <span class="number">26</span>);</span><br><span class="line">        students[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;至尊宝&quot;</span>, <span class="number">167.5</span>, <span class="number">24</span>);</span><br><span class="line">		<span class="comment">//2.对数组中的元素按照年龄升序排列: 先用匿名内部类写法</span></span><br><span class="line">        Arrays.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Double.compare(o1.getHeight(), o2.getHeight()); <span class="comment">// 升序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">		<span class="comment">//4.对数组中的元素按照年龄升序排列: 改用Lambda写法</span></span><br><span class="line">        Arrays.sort(students, (Student o1, Student o2) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> Double.compare(o1.getHeight(), o2.getHeight()); <span class="comment">// 升序</span></span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(students));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-Lambda表达式省略规则">1.2 Lambda表达式省略规则</h3>
<p>Lamdba表达式的几种简化写法。具体的简化规则如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>Lambda的标准格式</span><br><span class="line">	(参数类型<span class="number">1</span> 参数名<span class="number">1</span>, 参数类型<span class="number">2</span> 参数名<span class="number">2</span>)-&gt;&#123;</span><br><span class="line">		...方法体的代码...</span><br><span class="line">		<span class="keyword">return</span> 返回值;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>在标准格式的基础上()中的参数类型可以直接省略</span><br><span class="line">	(参数名<span class="number">1</span>, 参数名<span class="number">2</span>)-&gt;&#123;</span><br><span class="line">		...方法体的代码...</span><br><span class="line">		<span class="keyword">return</span> 返回值;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="number">2.</span>如果&#123;&#125;总的语句只有一条语句，则&#123;&#125;可以省略、<span class="keyword">return</span>关键字、以及最后的“;”都可以省略</span><br><span class="line">	(参数名<span class="number">1</span>, 参数名<span class="number">2</span>)-&gt; 结果</span><br><span class="line">	</span><br><span class="line"><span class="number">4.</span>如果()里面只有一个参数，则()可以省略</span><br><span class="line">	(参数名)-&gt;结果</span><br></pre></td></tr></table></figure>
<p>接下来从匿名内部类开始、到Lambda标准格式、再到Lambda简化格式，一步一步来简化一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：使用Lambda简化函数式接口。</span></span><br><span class="line">        <span class="type">double</span>[] prices = &#123;<span class="number">99.8</span>, <span class="number">128</span>, <span class="number">100</span>&#125;;</span><br><span class="line">		<span class="comment">//1.对数组中的每一个元素*0.8: 匿名内部类写法</span></span><br><span class="line">        Arrays.setAll(prices, <span class="keyword">new</span> <span class="title class_">IntToDoubleFunction</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">applyAsDouble</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">                <span class="comment">// value = 0  1  2</span></span><br><span class="line">                <span class="keyword">return</span> prices[value] * <span class="number">0.8</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">		<span class="comment">//2.需求：对数组中的每一个元素*0.8,使用Lambda表达式标准写法</span></span><br><span class="line">        Arrays.setAll(prices, (<span class="type">int</span> value) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> prices[value] * <span class="number">0.8</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">		<span class="comment">//2.使用Lambda表达式简化格式1——省略参数类型</span></span><br><span class="line">        Arrays.setAll(prices, (value) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> prices[value] * <span class="number">0.8</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">		<span class="comment">//4.使用Lambda表达式简化格式2——省略()</span></span><br><span class="line">        Arrays.setAll(prices, value -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> prices[value] * <span class="number">0.8</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//5.使用Lambda表达式简化格式3——省略&#123;&#125;</span></span><br><span class="line">        Arrays.setAll(prices, value -&gt; prices[value] * <span class="number">0.8</span> );</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(prices));</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Student[] students = new Student[4];</span></span><br><span class="line"><span class="string">        students[0] = new Student(&quot;</span>蜘蛛精<span class="string">&quot;, 169.5, 23);</span></span><br><span class="line"><span class="string">        students[1] = new Student(&quot;</span>紫霞<span class="string">&quot;, 162.8, 26);</span></span><br><span class="line"><span class="string">        students[2] = new Student(&quot;</span>紫霞<span class="string">&quot;, 162.8, 26);</span></span><br><span class="line"><span class="string">        students[3] = new Student(&quot;</span>至尊宝<span class="string">&quot;, 167.5, 24);</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">        //1.使用匿名内部类</span></span><br><span class="line"><span class="string">        Arrays.sort(students, new Comparator&lt;Student&gt;() &#123;</span></span><br><span class="line"><span class="string">            @Override</span></span><br><span class="line"><span class="string">            public int compare(Student o1, Student o2) &#123;</span></span><br><span class="line"><span class="string">                return Double.compare(o1.getHeight(), o2.getHeight()); // 升序</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">		//2.使用Lambda表达式表达式——标准格式</span></span><br><span class="line"><span class="string">        Arrays.sort(students, (Student o1, Student o2) -&gt; &#123;</span></span><br><span class="line"><span class="string">                return Double.compare(o1.getHeight(), o2.getHeight()); // 升序</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">		//2.使用Lambda表达式表达式——省略参数类型</span></span><br><span class="line"><span class="string">        Arrays.sort(students, ( o1,  o2) -&gt; &#123;</span></span><br><span class="line"><span class="string">            return Double.compare(o1.getHeight(), o2.getHeight()); // 升序</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">		//4.使用Lambda表达式表达式——省略&#123;&#125;</span></span><br><span class="line"><span class="string">        Arrays.sort(students, ( o1,  o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight()));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        System.out.println(Arrays.toString(students));</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="二、JDK8新特性（方法引用）">二、JDK8新特性（方法引用）</h2>
<p>JDK8的另一个新特性，叫做方法引用。我们知道Lambda是用来简化匿名代码的书写格式的，而方法引用是用来进一步简化Lambda表达式的，它简化的更加过分。</p>
<h3 id="2-1-静态方法引用">2.1 静态方法引用</h3>
<p>我们先学习静态方法的引用，还是用之前Arrays代码来做演示。现在准备好下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Student[] students = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">4</span>];</span><br><span class="line">        students[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">169.5</span>, <span class="number">23</span>);</span><br><span class="line">        students[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>, <span class="number">162.8</span>, <span class="number">26</span>);</span><br><span class="line">        students[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>, <span class="number">162.8</span>, <span class="number">26</span>);</span><br><span class="line">        students[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;至尊宝&quot;</span>, <span class="number">167.5</span>, <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原始写法：对数组中的学生对象，按照年龄升序排序</span></span><br><span class="line">        Arrays.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge() - o2.getAge(); <span class="comment">// 按照年龄升序排序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Lambda简化后的形式</span></span><br><span class="line">        Arrays.sort(students, (o1, o2) -&gt; o1.getAge() - o2.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我想要把下图中Lambda表达式的方法体，用一个静态方法代替</p>
<p><img src="https://s2.loli.net/2024/05/05/C79sdSmgXcaVBRl.webp" alt="1667464274934"></p>
<p>准备另外一个类CompareByData类，用于封装Lambda表达式的方法体代码；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompareByData</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compareByAge</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getAge() - o2.getAge(); <span class="comment">// 升序排序的规则</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们就可以把Lambda表达式的方法体代码，改为下面的样子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(students, (o1, o2) -&gt; CompareByData.compareByAge(o1, o2));</span><br></pre></td></tr></table></figure>
<p>Java为了简化上面Lambda表达式的写法，利用方法引用可以改进为下面的样子。**实际上就是用类名调用方法，但是把参数给省略了。**这就是静态方法引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态方法引用：类名::方法名</span></span><br><span class="line">Arrays.sort(students, CompareByData::compareByAge);</span><br></pre></td></tr></table></figure>
<h3 id="2-2-实例方法引用">2.2 实例方法引用</h3>
<p>实例方法的引用。现在，我想要把下图中Lambda表达式的方法体，用一个实例方法代替。</p>
<p><img src="https://s2.loli.net/2024/05/05/usWYLORK3X1eicG.webp" alt="1667464274934"></p>
<p>在CompareByData类中，再添加一个实例方法，用于封装Lambda表达式的方法体</p>
<p><img src="https://s2.loli.net/2024/05/05/d39eFqnRAIrutyG.webp" alt="1667464896645"></p>
<p>接下来，我们把Lambda表达式的方法体，改用对象调用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CompareByData</span> <span class="variable">compare</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompareByData</span>();</span><br><span class="line">Arrays.sort(students, (o1, o2) -&gt; compare.compareByAgeDesc(o1, o2)); <span class="comment">// 降序</span></span><br></pre></td></tr></table></figure>
<p>最后，再将Lambda表达式的方法体，直接改成方法引用写法。<strong>实际上就是用类名调用方法，但是省略的参数</strong>。这就是实例方法引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CompareByData</span> <span class="variable">compare</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompareByData</span>();</span><br><span class="line">Arrays.sort(students, compare::compareByAgeDesc); <span class="comment">// 降序</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>给小伙伴的寄语：一定要按照老师写的步骤，一步一步来做，你一定能学会的！！！</p>
</blockquote>
<h3 id="2-3-特定类型的方法引用">2.3 特定类型的方法引用</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Java约定：</span><br><span class="line">    如果某个Lambda表达式里只是调用一个实例方法，并且前面参数列表中的第一个参数作为方法的主调，	后面的所有参数都是作为该实例方法的入参时，则就可以使用特定类型的方法引用。</span><br><span class="line">格式：</span><br><span class="line">	类型::方法名</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;boby&quot;</span>, <span class="string">&quot;angela&quot;</span>, <span class="string">&quot;Andy&quot;</span> ,<span class="string">&quot;dlei&quot;</span>, <span class="string">&quot;caocao&quot;</span>, <span class="string">&quot;Babo&quot;</span>, <span class="string">&quot;jack&quot;</span>, <span class="string">&quot;Cici&quot;</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 要求忽略首字符大小写进行排序。</span></span><br><span class="line">        Arrays.sort(names, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">                <span class="comment">// 制定比较规则。o1 = &quot;Andy&quot;  o2 = &quot;angela&quot;</span></span><br><span class="line">                <span class="keyword">return</span> o1.compareToIgnoreCase(o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//lambda表达式写法</span></span><br><span class="line">        Arrays.sort(names, ( o1,  o2) -&gt; o1.compareToIgnoreCase(o2) );</span><br><span class="line">        <span class="comment">//特定类型的方法引用！</span></span><br><span class="line">        Arrays.sort(names, String::compareToIgnoreCase);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(names));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-构造器引用">2.4 构造器引用</h3>
<p>现在，我们准备一个JavaBean类，Car类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Car&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为方法引用是基于Lamdba表达式简化的，所以也要按照Lamdba表达式的使用前提来用，需要一个函数式接口，接口中代码的返回值类型是Car类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">CreateCar</span>&#123;</span><br><span class="line">    Car <span class="title function_">create</span><span class="params">(String name, <span class="type">double</span> price)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，再准备一个测试类，在测试类中创建CreateCar接口的实现类对象，先用匿名内部类创建、再用Lambda表达式创建，最后改用方法引用创建。同学们只关注格式就可以，不要去想为什么（语法就是这么设计的）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、创建这个接口的匿名内部类对象。</span></span><br><span class="line">        <span class="type">CreateCar</span> <span class="variable">cc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateCar</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Car <span class="title function_">create</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>(name, price);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">		<span class="comment">//2、使用匿名内部类改进</span></span><br><span class="line">        <span class="type">CreateCar</span> <span class="variable">cc2</span> <span class="operator">=</span> (name,  price) -&gt; <span class="keyword">new</span> <span class="title class_">Car</span>(name, price);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、使用方法引用改进：构造器引用</span></span><br><span class="line">        <span class="type">CreateCar</span> <span class="variable">cc3</span> <span class="operator">=</span> Car::<span class="keyword">new</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意：以上是创建CreateCar接口实现类对象的几种形式而已，语法一步一步简化。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4、对象调用方法</span></span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> cc2.create(<span class="string">&quot;奔驰&quot;</span>, <span class="number">49.9</span>);</span><br><span class="line">        System.out.println(car);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、正则表达式">三、正则表达式</h2>
<p><strong>正则表达式其实是由一些特殊的符号组成的，它代表的是某种规则。</strong></p>
<blockquote>
<p>正则表达式的作用1：用来校验字符串数据是否合法</p>
<p>正则表达式的作用2：可以从一段文本中查找满足要求的内容</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/05/05/fWiu2ecLE8UCzaT.webp" alt="1667468712516"></p>
<h3 id="3-1-正则表达式初体验">3.1 正则表达式初体验</h3>
<p>以QQ号码为例，来体验一下正则表达式的用法。注意：现在仅仅只是体验而已，我们还没有讲正则表达式的具体写法。</p>
<ul>
<li>不使用正则表达式，校验QQ号码代码是这样的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkQQ</span><span class="params">(String qq)</span>&#123;</span><br><span class="line">        <span class="comment">// 1、判断qq号码是否为null</span></span><br><span class="line">        <span class="keyword">if</span>(qq == <span class="literal">null</span> || qq.startsWith(<span class="string">&quot;0&quot;</span>) || qq.length() &lt; <span class="number">6</span> || qq.length() &gt; <span class="number">20</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、qq至少是不是null,不是以0开头的，满足6-20之间的长度。</span></span><br><span class="line">        <span class="comment">// 判断qq号码中是否都是数字。</span></span><br><span class="line">        <span class="comment">// qq = 2514ghd234</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; qq.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 根据索引提取当前位置处的字符。</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> qq.charAt(i);</span><br><span class="line">            <span class="comment">// 判断ch记住的字符，如果不是数字，qq号码不合法。</span></span><br><span class="line">            <span class="keyword">if</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3、说明qq号码肯定是合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用正则表达式代码是这样的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkQQ1</span><span class="params">(String qq)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qq != <span class="literal">null</span> &amp;&amp; qq.matches(<span class="string">&quot;[1-9]\\d&#123;5,19&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现，使用正则表达式，大大简化的了代码的写法。这个代码现在不用写，体验到正则表达式的优势就可以了。</p>
<h3 id="3-2-正则表达式书写规则">3.2 正则表达式书写规则</h3>
<p>前面我们已经体验到了正则表达式，可以简化校验数据的代码书写。这里需要用到一个方法叫<code>matches(String regex)</code>。这个方法时属于String类的方法。</p>
<p><img src="https://s2.loli.net/2024/05/05/AiNztM4lbKuhp1L.webp" alt="1667469085970"></p>
<p>这个方法是用来匹配一个字符串是否匹配正则表达式的规则，参数需要调用者传递一个正则表达式。但是正则表达式不能乱写，是有特定的规则的。</p>
<p>在API中有一个类叫做Pattern，我们可以到API文档中搜索，关于正则表达式的规则，这个类都告诉我们了。我这里把常用的已经给大家整理好了。</p>
<p><img src="https://s2.loli.net/2024/05/05/4KqT3egM6OYvadl.webp" alt="1667469259345"></p>
<p>我们将这些规则，在代码中演示一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握正则表达式的书写规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、字符类(只能匹配单个字符)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>));    <span class="comment">// [abc]只能匹配a、b、c</span></span><br><span class="line">        System.out.println(<span class="string">&quot;e&quot;</span>.matches(<span class="string">&quot;[abcd]&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;d&quot;</span>.matches(<span class="string">&quot;[^abc]&quot;</span>));   <span class="comment">// [^abc] 不能是abc</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[^abc]&quot;</span>));  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;b&quot;</span>.matches(<span class="string">&quot;[a-zA-Z]&quot;</span>)); <span class="comment">// [a-zA-Z] 只能是a-z A-Z的字符</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>.matches(<span class="string">&quot;[a-zA-Z]&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;k&quot;</span>.matches(<span class="string">&quot;[a-z&amp;&amp;[^bc]]&quot;</span>)); <span class="comment">// ： a到z，除了b和c</span></span><br><span class="line">        System.out.println(<span class="string">&quot;b&quot;</span>.matches(<span class="string">&quot;[a-z&amp;&amp;[^bc]]&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;ab&quot;</span>.matches(<span class="string">&quot;[a-zA-Z0-9]&quot;</span>)); <span class="comment">// false 注意：以上带 [内容] 的规则都只能用于匹配单个字符</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、预定义字符(只能匹配单个字符)  .  \d  \D   \s  \S  \w  \W</span></span><br><span class="line">        System.out.println(<span class="string">&quot;徐&quot;</span>.matches(<span class="string">&quot;.&quot;</span>)); <span class="comment">// .可以匹配任意字符</span></span><br><span class="line">        System.out.println(<span class="string">&quot;徐徐&quot;</span>.matches(<span class="string">&quot;.&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// \转义</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// \n \t</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>));  <span class="comment">// \d: 0-9</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>));  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot; &quot;</span>.matches(<span class="string">&quot;\\s&quot;</span>));   <span class="comment">// \s: 代表一个空白字符</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\s&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\S&quot;</span>));  <span class="comment">// \S: 代表一个非空白字符</span></span><br><span class="line">        System.out.println(<span class="string">&quot; &quot;</span>.matches(<span class="string">&quot;\\S&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>));  <span class="comment">// \w: [a-zA-Z_0-9]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;_&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;徐&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;徐&quot;</span>.matches(<span class="string">&quot;\\W&quot;</span>));  <span class="comment">// [^\w]不能是a-zA-Z_0-9</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\W&quot;</span>));  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;23232&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>)); <span class="comment">// false 注意：以上预定义字符都只能匹配单个字符。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、数量词： ?   *   +   &#123;n&#125;   &#123;n, &#125;  &#123;n, m&#125;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\w?&quot;</span>));   <span class="comment">// ? 代表0次或1次</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>.matches(<span class="string">&quot;\\w?&quot;</span>));    <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.matches(<span class="string">&quot;\\w?&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;abc12&quot;</span>.matches(<span class="string">&quot;\\w*&quot;</span>));   <span class="comment">// * 代表0次或多次</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>.matches(<span class="string">&quot;\\w*&quot;</span>));        <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc12张&quot;</span>.matches(<span class="string">&quot;\\w*&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;abc12&quot;</span>.matches(<span class="string">&quot;\\w+&quot;</span>));   <span class="comment">// + 代表1次或多次</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>.matches(<span class="string">&quot;\\w+&quot;</span>));       <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc12张&quot;</span>.matches(<span class="string">&quot;\\w+&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;a3c&quot;</span>.matches(<span class="string">&quot;\\w&#123;3&#125;&quot;</span>));   <span class="comment">// &#123;3&#125; 代表要正好是n次</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abcd&quot;</span>.matches(<span class="string">&quot;\\w&#123;3&#125;&quot;</span>));  <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abcd&quot;</span>.matches(<span class="string">&quot;\\w&#123;3,&#125;&quot;</span>));     <span class="comment">// &#123;3,&#125; 代表是&gt;=3次</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ab&quot;</span>.matches(<span class="string">&quot;\\w&#123;3,&#125;&quot;</span>));     <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abcde徐&quot;</span>.matches(<span class="string">&quot;\\w&#123;3,&#125;&quot;</span>));     <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc232d&quot;</span>.matches(<span class="string">&quot;\\w&#123;3,9&#125;&quot;</span>));     <span class="comment">// &#123;3, 9&#125; 代表是  大于等于3次，小于等于9次</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、其他几个常用的符号：(?i)忽略大小写 、 或：| 、  分组：()</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.matches(<span class="string">&quot;(?i)abc&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ABC&quot;</span>.matches(<span class="string">&quot;(?i)abc&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;aBc&quot;</span>.matches(<span class="string">&quot;a((?i)b)c&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ABc&quot;</span>.matches(<span class="string">&quot;a((?i)b)c&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求1：要求要么是3个小写字母，要么是3个数字。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.matches(<span class="string">&quot;[a-z]&#123;3&#125;|\\d&#123;3&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ABC&quot;</span>.matches(<span class="string">&quot;[a-z]&#123;3&#125;|\\d&#123;3&#125;&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>.matches(<span class="string">&quot;[a-z]&#123;3&#125;|\\d&#123;3&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A12&quot;</span>.matches(<span class="string">&quot;[a-z]&#123;3&#125;|\\d&#123;3&#125;&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求2：必须是”我爱“开头，中间可以是至少一个”编程“，最后至少是1个”666“</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我爱编程编程666666&quot;</span>.matches(<span class="string">&quot;我爱(编程)+(666)+&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;我爱编程编程66666&quot;</span>.matches(<span class="string">&quot;我爱(编程)+(666)+&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-正则表达式应用案例">3.3 正则表达式应用案例</h3>
<ul>
<li>正则表达式校验手机号码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：校验用户输入的电话、邮箱、时间是否合法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        checkPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkPhone</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请您输入您的电话号码(手机|座机): &quot;</span>);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">            <span class="comment">// 18676769999  010-3424242424 0104644535</span></span><br><span class="line">            <span class="keyword">if</span>(phone.matches(<span class="string">&quot;(1[3-9]\\d&#123;9&#125;)|(0\\d&#123;2,7&#125;-?[1-9]\\d&#123;4,19&#125;)&quot;</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您输入的号码格式正确~~~&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您输入的号码格式不正确~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用正则表达式校验邮箱是否正确</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        checkEmail();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请您输入您的邮箱： &quot;</span>);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * dlei0009@162.com</span></span><br><span class="line"><span class="comment">             * 25143242@qq.com</span></span><br><span class="line"><span class="comment">             * itheima@itcast.com.cn</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span>(email.matches(<span class="string">&quot;\\w&#123;2,&#125;@\\w&#123;2,20&#125;(\\.\\w&#123;2,10&#125;)&#123;1,2&#125;&quot;</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您输入的邮箱格式正确~~~&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您输入的邮箱格式不正确~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-4-正则表达式信息爬取">3.4 正则表达式信息爬取</h3>
<p><strong>正则表达式的第二个作用：在一段文本中查找满足要求的内容</strong></p>
<p>我们还是通过一个案例给大家做演示：案例需求如下</p>
<p><img src="https://s2.loli.net/2024/05/05/juqiDFPvcGU59EJ.webp" alt="1667469722842"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握使用正则表达式查找内容。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需求1：从以下内容中爬取出，手机，邮箱，座机、400电话等信息。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot; 来黑马程序员学习Java，\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        电话：1866668888，18699997777\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        或者联系邮箱：boniu@itcast.cn，\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        座机电话：01036517895，010-98951256\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        邮箱：bozai@itcast.cn，\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        邮箱：dlei0009@162.com，\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        热线电话：400-618-9090 ，400-618-4000，4006184000，4006189090&quot;</span>;</span><br><span class="line">        <span class="comment">// 1、定义爬取规则</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;(1[3-9]\\d&#123;9&#125;)|(0\\d&#123;2,7&#125;-?[1-9]\\d&#123;4,19&#125;)|(\\w&#123;2,&#125;@\\w&#123;2,20&#125;(\\.\\w&#123;2,10&#125;)&#123;1,2&#125;)&quot;</span></span><br><span class="line">                + <span class="string">&quot;|(400-?\\d&#123;3,7&#125;-?\\d&#123;3,7&#125;)&quot;</span>;</span><br><span class="line">        <span class="comment">// 2、把正则表达式封装成一个Pattern对象</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line">        <span class="comment">// 3、通过pattern对象去获取查找内容的匹配器对象。</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(data);</span><br><span class="line">        <span class="comment">// 4、定义一个循环开始爬取信息</span></span><br><span class="line">        <span class="keyword">while</span> (matcher.find())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> matcher.group(); <span class="comment">// 获取到了找到的内容了。</span></span><br><span class="line">            System.out.println(rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-正则表达式搜索、替换">3.5 正则表达式搜索、替换</h3>
<p>正则表达式的另外两个功能，替换、分割的功能。需要注意的是这几个功能需要用到Stirng类中的方法。这两个方法其实我们之前学过，只是当时没有学正则表达式而已。</p>
<p><img src="https://s2.loli.net/2024/05/05/qTMF4cKndIyUL2G.webp" alt="1667469943451"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握使用正则表达式做搜索替换，内容分割。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexTest5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、public String replaceAll(String regex , String newStr)：按照正则表达式匹配的内容进行替换</span></span><br><span class="line">        <span class="comment">// 需求1：请把下面字符串中的不是汉字的部分替换为 “-”</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;古力娜扎ai8888迪丽热巴999aa5566马尔扎哈fbbfsfs42425卡尔扎巴&quot;</span>;</span><br><span class="line">        System.out.println(s1.replaceAll(<span class="string">&quot;\\w+&quot;</span>, <span class="string">&quot;-&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 需求2(拓展)：某语音系统，收到一个口吃的人说的“我我我喜欢编编编编编编编编编编编编程程程！”，需要优化成“我喜欢编程！”。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;我我我喜欢编编编编编编编编编编编编程程程&quot;</span>;</span><br><span class="line">        System.out.println(s2.replaceAll(<span class="string">&quot;(.)\\1+&quot;</span>, <span class="string">&quot;$1&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、public String[] split(String regex)：按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组。</span></span><br><span class="line">        <span class="comment">// 需求1：请把下面字符串中的人名取出来，使用切割来做</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;古力娜扎ai8888迪丽热巴999aa5566马尔扎哈fbbfsfs42425卡尔扎巴&quot;</span>;</span><br><span class="line">        String[] names = s2.split(<span class="string">&quot;\\w+&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(names));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="异常、集合进阶">异常、集合进阶</h1>
<h2 id="一、异常">一、异常</h2>
<h3 id="1-1-认识异常">1.1 认识异常</h3>
<p><img src="https://s2.loli.net/2024/05/05/AqHByNtm9Cx1Wlw.webp" alt="1667313423356"></p>
<blockquote>
<p><strong>先来演示一个运行时异常产生</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>&#125;;</span><br><span class="line"><span class="comment">//5是一个不存在的索引，所以此时产生ArrayIndexOutOfBoundsExcpetion</span></span><br><span class="line">System.out.println(arr[<span class="number">5</span>]); </span><br></pre></td></tr></table></figure>
<p>下图是API中对ArrayIndexOutOfBoundsExcpetion类的继承体系，以及告诉我们它在什么情况下产生。</p>
<p><img src="https://s2.loli.net/2024/05/05/ebJTrVOU1IDdPvs.webp" alt="1667313567748"></p>
<blockquote>
<p><strong>再来演示一个编译时异常</strong></p>
</blockquote>
<p>我们在调用SimpleDateFormat对象的parse方法时，要求传递的参数必须和指定的日期格式一致，否则就会出现异常。 Java比较贴心，它为了更加强烈的提醒方法的调用者，设计了编译时异常，它把异常的提醒提前了，你调用方法是否真的有问题，只要可能有问题就给你报出异常提示（红色波浪线）。</p>
<p><strong>编译时异常的目的：意思就是告诉你，你小子注意了！！，这里小心点容易出错，仔细检查一下</strong></p>
<p><img src="https://s2.loli.net/2024/05/05/KpqoE3HjAeGzMJk.webp" alt="1667313705048"></p>
<p>有人说，我检查过了，我确认我的代码没问题，为了让它不报错，继续将代码写下去。我们这里有两种解决方案。</p>
<ul>
<li>第一种：使用throws在方法上声明，意思就是告诉下一个调用者，这里面可能有异常啊，你调用时注意一下。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：认识异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException&#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;2028-11-11 10:24&quot;</span>);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二种：使用try…catch语句块异常进行处理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">            <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;2028-11-11 10:24&quot;</span>);</span><br><span class="line">            System.out.println(d);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-自定义异常">1.2 自定义异常</h3>
<p>我们通过一个实际场景，来给大家演示自定义异常。</p>
<blockquote>
<p>需求：写一个saveAge(int age)方法，在方法中对参数age进行判断，如果age&lt;0或者&gt;=150就认为年龄不合法，如果年龄不合法，就给调用者抛出一个年龄非法异常。</p>
<p>分析：Java的API中是没有年龄非常这个异常的，所以我们可以自定义一个异常类，用来表示年龄非法异常，然后再方法中抛出自定义异常即可。</p>
</blockquote>
<ul>
<li>先写一个异常类AgeIllegalException（这是自己取的名字，名字取得很奈斯），继承</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、必须让这个类继承自Exception，才能成为一个编译时异常类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgeIllegalException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>再写一个测试类，在测试类中定义一个saveAge(int age)方法，对age判断如果年龄不在0~150之间，就抛出一个AgeIllegalException异常对象给调用者。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 需求：保存一个合法的年</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            saveAge2(<span class="number">225</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;saveAge2底层执行是成功的！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AgeIllegalException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;saveAge2底层执行是出现bug的！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、在方法中对age进行判断，不合法则抛出AgeIllegalException</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(age &gt; <span class="number">0</span> &amp;&amp; age &lt; <span class="number">150</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄被成功保存： &quot;</span> + age);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 用一个异常对象封装这个问题</span></span><br><span class="line">            <span class="comment">// throw 抛出去这个异常对象</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeIllegalRuntimeException</span>(<span class="string">&quot;/age is illegal, your age is &quot;</span> + age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意咯，自定义异常可能是编译时异常，也可以是运行时异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>如果自定义异常类继承Excpetion，则是编译时异常。</span><br><span class="line">	特点：方法中抛出的是编译时异常，必须在方法上使用<span class="keyword">throws</span>声明，强制调用者处理。</span><br><span class="line">	</span><br><span class="line"><span class="number">2.</span>如果自定义异常类继承RuntimeException，则运行时异常。</span><br><span class="line">	特点：方法中抛出的是运行时异常，不需要在方法上用<span class="keyword">throws</span>声明。</span><br></pre></td></tr></table></figure>
<h3 id="1-3-异常处理">1.3 异常处理</h3>
<p>比如有如下的场景：A调用用B，B调用C；C中有异常产生抛给B，B中有异常产生又抛给A；异常到了A这里就不建议再抛出了，因为最终抛出被JVM处理程序就会异常终止，并且给用户看异常信息，用户也看不懂，体验很不好。</p>
<p>此时比较好的做法就是：<strong>1.将异常捕获，将比较友好的信息显示给用户看；2.尝试重新执行，看是是否能修复这个问题。</strong></p>
<p>我们看一个代码，main方法调用test1方法，test1方法调用test2方法，test1和test2方法中多有扔异常。</p>
<ul>
<li>第一种处理方式是，在main方法中对异常进行try…catch捕获处理了，给出友好提示。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您要找的文件不存在！！&quot;</span>);</span><br><span class="line">            e.printStackTrace(); <span class="comment">// 打印出这个异常对象的信息。记录下来。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您要解析的时间有问题了！&quot;</span>);</span><br><span class="line">            e.printStackTrace(); <span class="comment">// 打印出这个异常对象的信息。记录下来。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, ParseException &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;2028-11-11 10:24:11&quot;</span>);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 读取文件的。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/meinv.webp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二种处理方式是：在main方法中对异常进行捕获，并尝试修复</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握异常的处理方式：捕获异常，尝试修复。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 需求：调用一个方法，让用户输入一个合适的价格返回为止。</span></span><br><span class="line">        <span class="comment">// 尝试修复</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(getMoney());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请您输入合法的数字！！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请您输入合适的价格：&quot;</span>);</span><br><span class="line">            <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line">            <span class="keyword">if</span>(money &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> money;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您输入的价格是不合适的！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、集合概述和分类">二、集合概述和分类</h2>
<h3 id="2-1-集合的分类">2.1 集合的分类</h3>
<p><img src="https://s2.loli.net/2024/05/06/LxZ9qnyKrIldkVc.webp" alt="1666154871520"></p>
<ul>
<li>对这些集合进行分类学习，如下图所示：一类是单列集合元素是一个一个的，另一类是双列集合元素是一对一对的。</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/06/nAKpMrJxNW24vZH.webp" alt="1666154948620">Collection单列集合。Collection是单列集合的根接口，Collection接口下面又有两个子接口List接口、Set接口，List和Set下面分别有不同的实现类，如下图所示：</p>
<p><img src="https://s2.loli.net/2024/05/06/juOfRUyVhPKbWG1.webp" alt="1666155169359"></p>
<p>上图中各种集合的特点如下图所示：</p>
<p><img src="https://s2.loli.net/2024/05/06/1GR4x2gHYhzEUM7.webp" alt="1666155218956"></p>
<p>可以自己写代码验证一下，各种集合的特点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单确认一下Collection集合的特点</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//存取顺序一致，可以重复，有索引</span></span><br><span class="line">list.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">System.out.println(list); <span class="comment">//[java1, java2, java1, java2] </span></span><br><span class="line"></span><br><span class="line">HashSet&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(); <span class="comment">//存取顺序不一致，不重复，无索引</span></span><br><span class="line">list.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;java3&quot;</span>);</span><br><span class="line">System.out.println(list); <span class="comment">//[java3, java2, java1] </span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-Collection集合的常用方法">2.2 Collection集合的常用方法</h3>
<ul>
<li>Collection集合的一些常用方法，这些方法所有Collection实现类都可以使用。 这里我们以创建ArrayList为例，来演示</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//1.public boolean add(E e): 添加元素到集合</span></span><br><span class="line">c.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;java3&quot;</span>);</span><br><span class="line">System.out.println(c); <span class="comment">//打印: [java1, java1, java2, java2, java3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.public int size(): 获取集合的大小</span></span><br><span class="line">System.out.println(c.size()); <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.public boolean contains(Object obj): 判断集合中是否包含某个元素</span></span><br><span class="line">System.out.println(c.contains(<span class="string">&quot;java1&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">System.out.println(c.contains(<span class="string">&quot;Java1&quot;</span>)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.pubilc boolean remove(E e): 删除某个元素，如果有多个重复元素只能删除第一个</span></span><br><span class="line">System.out.println(c.remove(<span class="string">&quot;java1&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">System.out.println(c); <span class="comment">//打印: [java1,java2, java2, java3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.public void clear(): 清空集合的元素</span></span><br><span class="line">c.clear(); </span><br><span class="line">System.out.println(c); <span class="comment">//打印：[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.public boolean isEmpty(): 判断集合是否为空 是空返回true 反之返回false</span></span><br><span class="line">System.out.println(c.isEmpty()); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.public Object[] toArray(): 把集合转换为数组</span></span><br><span class="line">Object[] array = c.toArray();</span><br><span class="line">System.out.println(Arrays.toString(array)); <span class="comment">//[java1,java2, java2, java3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//8.如果想把集合转换为指定类型的数组，可以使用下面的代码</span></span><br><span class="line">String[] array1 = c.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[c.size()]);</span><br><span class="line">System.out.println(Arrays.toString(array1)); <span class="comment">//[java1,java2, java2, java3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//9.还可以把一个集合中的元素，添加到另一个集合中</span></span><br><span class="line">Collection&lt;String&gt; c1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">c1.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">c1.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">Collection&lt;String&gt; c2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">c2.add(<span class="string">&quot;java3&quot;</span>);</span><br><span class="line">c2.add(<span class="string">&quot;java4&quot;</span>);</span><br><span class="line">c1.addAll(c2); <span class="comment">//把c2集合中的全部元素，添加到c1集合中去</span></span><br><span class="line">System.out.println(c1); <span class="comment">//[java1, java2, java3, java4]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Collection集合的常用功能有哪些，ArrayList、LinkedList、HashSet、LinkedHashSet、TreeSet集合都可以调用下面的方法。</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/06/Gtd73ixI8Awrbya.webp" alt="1666158266534"></p>
<h2 id="三、Collection遍历方式">三、Collection遍历方式</h2>
<h3 id="3-1-迭代器遍历集合">3.1 迭代器遍历集合</h3>
<p>代码写法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">c.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;小昭&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;素素&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;灭绝&quot;</span>);</span><br><span class="line">System.out.println(c); <span class="comment">//[赵敏, 小昭, 素素, 灭绝]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一步：先获取迭代器对象</span></span><br><span class="line"><span class="comment">//解释：Iterator就是迭代器对象，用于遍历集合的工具)</span></span><br><span class="line">Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：用于判断当前位置是否有元素可以获取</span></span><br><span class="line"><span class="comment">//解释：hasNext()方法返回true，说明有元素可以获取；反之没有</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="comment">//第三步：获取当前位置的元素，然后自动指向下一个元素.</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代器代码的原理如下：</p>
<ul>
<li>当调用iterator()方法获取迭代器时，当前指向第一个元素</li>
<li>hasNext()方法则判断这个位置是否有元素，如果有则返回true，进入循环</li>
<li>调用next()方法获取元素，并将当月元素指向下一个位置，</li>
<li>等下次循环时，则获取下一个元素，依此内推</li>
</ul>
<p>最后，我们再总结一下，使用迭代器遍历集合用到哪些方法</p>
<p><img src="https://s2.loli.net/2024/05/06/LIJ1V96zsyUP7xg.webp" alt="1666162899638"></p>
<h3 id="3-2-增强for遍历集合">3.2 增强for遍历集合</h3>
<p>格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型 变量名:数组或者集合)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，增强for不光可以遍历集合，还可以遍历数组。接下来我们用代码演示一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">c.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;小昭&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;素素&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;灭绝&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.使用增强for遍历集合</span></span><br><span class="line"><span class="keyword">for</span>(String s: c)&#123;</span><br><span class="line">    System.out.println(s); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.再尝试使用增强for遍历数组</span></span><br><span class="line">String[] arr = &#123;<span class="string">&quot;迪丽热巴&quot;</span>, <span class="string">&quot;古力娜扎&quot;</span>, <span class="string">&quot;稀奇哈哈&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(String name: arr)&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-forEach遍历集合">3.3 forEach遍历集合</h3>
<p>在JDK8版本以后还提供了一个forEach方法也可以遍历集合。</p>
<p>我们发现forEach方法的参数是一个Consumer接口，而Consumer是一个函数式接口，所以可以传递Lambda表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">c.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;小昭&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;素素&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;灭绝&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用forEach方法</span></span><br><span class="line"><span class="comment">//由于参数是一个Consumer接口，所以可以传递匿名内部类</span></span><br><span class="line">c.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以使用lambda表达式对匿名内部类进行简化</span></span><br><span class="line">c.forEach(s-&gt;System.out.println(s)); <span class="comment">//[赵敏, 小昭, 素素, 灭绝]</span></span><br></pre></td></tr></table></figure>
<h2 id="四、List系列集合">四、List系列集合</h2>
<ul>
<li>List集合。如下图所示：</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/06/VQBUpA41YHvLWxa.webp" alt="1666165150752"></p>
<h3 id="4-1-List集合的常用方法">4.1 List集合的常用方法</h3>
<p>List集合是索引的，所以多了一些有索引操作的方法，如下图所示：</p>
<p><img src="https://s2.loli.net/2024/05/06/437bHdjvuDaNPCT.webp" alt="1666165187815"></p>
<p>接下来，我们用代码演示一下这几个方法的效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个ArrayList集合对象（有序、有索引、可以重复）</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;蜘蛛精&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;至尊宝&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;至尊宝&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;牛夫人&quot;</span>); </span><br><span class="line">System.out.println(list); <span class="comment">//[蜘蛛精, 至尊宝, 至尊宝, 牛夫人]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.public void add(int index, E element): 在某个索引位置插入元素</span></span><br><span class="line">list.add(<span class="number">2</span>, <span class="string">&quot;紫霞仙子&quot;</span>);</span><br><span class="line">System.out.println(list); <span class="comment">//[蜘蛛精, 至尊宝, 紫霞仙子, 至尊宝, 牛夫人]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.public E remove(int index): 根据索引删除元素, 返回被删除的元素</span></span><br><span class="line">System.out.println(list.remove(<span class="number">2</span>)); <span class="comment">//紫霞仙子</span></span><br><span class="line">System.out.println(list);<span class="comment">//[蜘蛛精, 至尊宝, 至尊宝, 牛夫人]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.public E get(int index): 返回集合中指定位置的元素</span></span><br><span class="line">System.out.println(list.get(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.public E set(int index, E e): 修改索引位置处的元素，修改后，会返回原数据</span></span><br><span class="line">System.out.println(list.set(<span class="number">3</span>,<span class="string">&quot;牛魔王&quot;</span>)); <span class="comment">//牛夫人</span></span><br><span class="line">System.out.println(list); <span class="comment">//[蜘蛛精, 至尊宝, 至尊宝, 牛魔王]</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-List集合的遍历方式">4.2 List集合的遍历方式</h3>
<p>List集合相比于前面的Collection多了一种可以通过索引遍历的方式，所以List集合遍历方式一共有四种：</p>
<ul>
<li>普通for循环（只因为List有索引）</li>
<li>迭代器</li>
<li>增强for</li>
<li>Lambda表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;蜘蛛精&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;至尊宝&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;糖宝宝&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.普通for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; list.size(); i++)&#123;</span><br><span class="line">    <span class="comment">//i = 0, 1, 2</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.增强for遍历</span></span><br><span class="line"><span class="keyword">for</span>(String s : list)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.迭代器遍历</span></span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.lambda表达式遍历</span></span><br><span class="line">list.forEach(s-&gt;System.out.println(s));</span><br></pre></td></tr></table></figure>
<h3 id="4-3-ArrayList底层的原理">4.3 ArrayList底层的原理</h3>
<p>ArrayList集合底层是基于数组结构实现的，也就是说当你往集合容器中存储元素时，底层本质上是往数组中存储元素。 特点如下：</p>
<p><img src="https://s2.loli.net/2024/05/06/tM7r5T8vJbpcGOB.webp" alt="1666166151267"></p>
<p>我们知道数组的长度是固定的，但是集合的长度是可变的，这是怎么做到的呢？原理如下：</p>
<p><img src="https://s2.loli.net/2024/05/06/YiD2Exe1pPAGFw4.webp" alt="1666166661149"></p>
<p>数组扩容，并不是在原数组上扩容（原数组是不可以扩容的），底层是创建一个新数组，然后把原数组中的元素全部复制到新数组中去。</p>
<p><img src="https://s2.loli.net/2024/05/06/xEImToBNFa4p8gw.webp" alt="1666166956907"></p>
<h3 id="4-4-LinkedList底层原理">4.4 LinkedList底层原理</h3>
<p>LinkedList底层是链表结构，链表结构是由一个一个的节点组成，一个节点由数据值、下一个元素的地址组成。如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/06/nK8M4S7ZgsmQceC.webp" alt="1666167170415"></p>
<p>假如，现在要在B节点和D节点中间插入一个元素，只需要把B节点指向D节点的地址断掉，重新指向新的节点地址就可以了。如下图所示：</p>
<p><img src="https://s2.loli.net/2024/05/06/WPmxD2wkALZc3Yd.webp" alt="1666167298885"></p>
<p>假如，现在想要把D节点删除，只需要让C节点指向E节点的地址，然后把D节点指向E节点的地址断掉。此时D节点就会变成垃圾，会把垃圾回收器清理掉。</p>
<p><img src="https://s2.loli.net/2024/05/06/vXW6eCOExV1yfBg.webp" alt="1666167419164"></p>
<p>上面的链表是单向链表，它的方向是从头节点指向尾节点的，只能从左往右查找元素，这样查询效率比较慢；还有一种链表叫做双向链表，不光可以从做往右找，还可以从右往左找。如下图所示：</p>
<p><img src="https://s2.loli.net/2024/05/06/tg78d3Q2N6xyeLv.webp" alt="1666167523139"></p>
<p>LinkedList集合是基于双向链表实现了，所以相对于ArrayList新增了一些可以针对头尾进行操作的方法，如下图示所示：</p>
<p><img src="https://s2.loli.net/2024/05/06/OMljVbTFYIwxEgS.webp" alt="1666167572387"></p>
<h3 id="4-5-LinkedList集合的应用场景">4.5 LinkedList集合的应用场景</h3>
<p>LinkedList集合有什么用呢？可以用它来<strong>设计栈结构、队列结构</strong>。</p>
<ul>
<li>
<p>我们先来认识一下队列结构，队列结构你可以认为是一个上端开口，下端也开口的管子的形状。元素从上端入队列，从下端出队列。</p>
</li>
<li>
<p>入队列可以调用LinkedList集合的addLast方法，出队列可以调用removeFirst()方法.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个队列：先进先出、后进后出</span></span><br><span class="line">LinkedList&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//入对列</span></span><br><span class="line">queue.addLast(<span class="string">&quot;第1号人&quot;</span>);</span><br><span class="line">queue.addLast(<span class="string">&quot;第2号人&quot;</span>);</span><br><span class="line">queue.addLast(<span class="string">&quot;第3号人&quot;</span>);</span><br><span class="line">queue.addLast(<span class="string">&quot;第4号人&quot;</span>);</span><br><span class="line">System.out.println(queue);</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队列</span></span><br><span class="line">System.out.println(queue.removeFirst());	<span class="comment">//第4号人</span></span><br><span class="line">System.out.println(queue.removeFirst());	<span class="comment">//第3号人</span></span><br><span class="line">System.out.println(queue.removeFirst());	<span class="comment">//第2号人</span></span><br><span class="line">System.out.println(queue.removeFirst());	<span class="comment">//第1号人</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>接下来，我们再用LinkedList集合来模拟一下栈结构的效果。还是先来认识一下栈结构长什么样。栈结构可以看做是一个上端开头，下端闭口的水杯的形状。</p>
<p>元素永远是<code>上端进，也从上端出</code>，先进入的元素会压在最底下，所以<strong>栈结构的特点是先进后出，后进先出</strong></p>
</li>
</ul>
<p>接着，我们就用LinkedList来模拟下栈结构，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个栈对象</span></span><br><span class="line">LinkedList&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//压栈(push) 等价于 addFirst()</span></span><br><span class="line">stack.push(<span class="string">&quot;第1颗子弹&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;第2颗子弹&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;第3颗子弹&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;第4颗子弹&quot;</span>);</span><br><span class="line">System.out.println(stack); <span class="comment">//[第4颗子弹, 第3颗子弹, 第2颗子弹,第1颗子弹]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//弹栈(pop) 等价于 removeFirst()</span></span><br><span class="line">System.out.println(statck.pop()); <span class="comment">//第4颗子弹</span></span><br><span class="line">System.out.println(statck.pop()); <span class="comment">//第3颗子弹</span></span><br><span class="line">System.out.println(statck.pop()); <span class="comment">//第2颗子弹</span></span><br><span class="line">System.out.println(statck.pop()); <span class="comment">//第1颗子弹</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//弹栈完了，集合中就没有元素了</span></span><br><span class="line">System.out.println(list); <span class="comment">//[]</span></span><br></pre></td></tr></table></figure>
<h2 id="五、Set系列集合">五、Set系列集合</h2>
<h3 id="5-1-认识Set集合的特点">5.1 认识Set集合的特点</h3>
<p>Set集合是属于Collection体系下的另一个分支，它的特点如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/06/W6bqhFkcyDXAMtu.webp" alt="1666169984705"></p>
<p>下面我们用代码简单演示一下，每一种Set集合的特点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Set&lt;Integer&gt; set = new HashSet&lt;&gt;();	//无序、无索引、不重复</span></span><br><span class="line"><span class="comment">//Set&lt;Integer&gt; set = new LinkedHashSet&lt;&gt;(); //有序、无索引、不重复</span></span><br><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(); <span class="comment">//可排序(升序)、无索引、不重复</span></span><br><span class="line">set.add(<span class="number">666</span>);</span><br><span class="line">set.add(<span class="number">555</span>);</span><br><span class="line">set.add(<span class="number">555</span>);</span><br><span class="line">set.add(<span class="number">888</span>);</span><br><span class="line">set.add(<span class="number">888</span>);</span><br><span class="line">set.add(<span class="number">777</span>);</span><br><span class="line">set.add(<span class="number">777</span>);</span><br><span class="line">System.out.println(set); <span class="comment">//[555, 666, 777, 888]</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-HashSet集合底层原理">5.2 HashSet集合底层原理</h3>
<p>HashSet集合底层是基于<code>哈希表</code>实现的，哈希表根据JDK版本的不同，也是有点区别的</p>
<ul>
<li>JDK8以前：<code>哈希表 = 数组+链表</code></li>
<li>JDK8以后：<code>哈希表 = 数组+链表+红黑树</code></li>
</ul>
<p><img src="https://s2.loli.net/2024/05/06/IO4noYmcbZzU5KT.webp" alt="1666170451762"></p>
<p>我们发现往HashSet集合中存储元素时，底层调用了元素的两个方法：一个是hashCode方法获取元素的hashCode值（哈希值）；另一个是调用了元素的equals方法，用来比较新添加的元素和集合中已有的元素是否相同。</p>
<ul>
<li>只有新添加元素的hashCode值和集合中以后元素的hashCode值相同、新添加的元素调用equals方法和集合中已有元素比较结果为true, 才认为元素重复。</li>
<li>如果hashCode值相同，equals比较不同，则以链表的形式连接在数组的同一个索引为位置（如上图所示）</li>
</ul>
<p>在JDK8开始后，为了提高性能，当链表的长度超过8时，就会把链表转换为红黑树，如下图所示：</p>
<p><img src="https://s2.loli.net/2024/05/06/EgrBUCVMI8qG4a7.webp" alt="1666171011761"></p>
<h3 id="5-3-HashSet去重原理">5.3 HashSet去重原理</h3>
<p>HashSet存储元素的原理，依赖于两个方法：</p>
<ul>
<li>一个是hashCode方法用来确定在底层数组中存储的位置</li>
<li>另一个是用equals方法判断新添加的元素是否和集合中已有的元素相同。</li>
</ul>
<p>要想保证在HashSet集合中没有重复元素，我们需要重写元素类的hashCode和equals方法。比如以下面的Student类为例，假设把Student类的对象作为HashSet集合的元素，想要让学生的姓名和年龄相同，就认为元素重复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height; <span class="comment">//身高</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//无参数构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//全参数构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> height)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">        <span class="built_in">this</span>.height=height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...get、set、toString()方法自己补上..</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//按快捷键生成hashCode和equals方法</span></span><br><span class="line">    <span class="comment">//alt+insert 选择 hashCode and equals</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (age != student.age) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (Double.compare(student.height, height) != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="literal">null</span> ? name.equals(student.name) : student.name == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="type">long</span> temp;</span><br><span class="line">        result = name != <span class="literal">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + age;</span><br><span class="line">        temp = Double.doubleToLongBits(height);</span><br><span class="line">        result = <span class="number">31</span> * result + (<span class="type">int</span>) (temp ^ (temp &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，写一个测试类，往HashSet集合中存储Student对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Set&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;至尊宝&quot;</span>,<span class="number">20</span>, <span class="number">169.6</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>,<span class="number">23</span>, <span class="number">169.6</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>,<span class="number">23</span>, <span class="number">169.6</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛魔王&quot;</span>,<span class="number">48</span>, <span class="number">169.6</span>);</span><br><span class="line">        </span><br><span class="line">        students.add(s1);</span><br><span class="line">        students.add(s2);</span><br><span class="line">        students.add(s3);</span><br><span class="line">        students.add(s4);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(Student s : students)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果如下，我们发现存了两个蜘蛛精，当时实际打印出来只有一个，而且是无序的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;name=<span class="string">&#x27;牛魔王&#x27;</span>, age=<span class="number">48</span>, height=<span class="number">169.6</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;至尊宝&#x27;</span>, age=<span class="number">20</span>, height=<span class="number">169.6</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;蜘蛛精&#x27;</span>, age=<span class="number">23</span>, height=<span class="number">169.6</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-LinkedHashSet底层原理">5.4 LinkedHashSet底层原理</h3>
<p>LinkedHashSet它底层采用的是也是哈希表结构，只不过额外新增了一个<code>双向链表</code>来维护元素的存取顺序。如下下图所示：</p>
<p><img src="https://s2.loli.net/2024/05/06/Tj4wirF1ZfA26qc.webp" alt="1666171776819"></p>
<p>每次添加元素，就和上一个元素用双向链表连接一下。第一个添加的元素是双向链表的头节点，最后一个添加的元素是双向链表的尾节点。</p>
<p>把上个案例中的集合改成LinkedHashSet集合，我们观察效果怎样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Set&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;至尊宝&quot;</span>,<span class="number">20</span>, <span class="number">169.6</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>,<span class="number">23</span>, <span class="number">169.6</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>,<span class="number">23</span>, <span class="number">169.6</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛魔王&quot;</span>,<span class="number">48</span>, <span class="number">169.6</span>);</span><br><span class="line">        </span><br><span class="line">        students.add(s1);</span><br><span class="line">        students.add(s2);</span><br><span class="line">        students.add(s3);</span><br><span class="line">        students.add(s4);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(Student s : students)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;name=<span class="string">&#x27;至尊宝&#x27;</span>, age=<span class="number">20</span>, height=<span class="number">169.6</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;蜘蛛精&#x27;</span>, age=<span class="number">23</span>, height=<span class="number">169.6</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;牛魔王&#x27;</span>, age=<span class="number">48</span>, height=<span class="number">169.6</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-5-TreeSet集合">5.5 TreeSet集合</h3>
<p>TreeSet集合的特点是可以对元素进行排序，但是必须指定元素的排序规则。</p>
<p>如果往集合中存储String类型的元素，或者Integer类型的元素，它们本身就具备排序规则，所以直接就可以排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; set1= <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">set1.add(<span class="number">8</span>);</span><br><span class="line">set1.add(<span class="number">6</span>);</span><br><span class="line">set1.add(<span class="number">4</span>);</span><br><span class="line">set1.add(<span class="number">3</span>);</span><br><span class="line">set1.add(<span class="number">7</span>);</span><br><span class="line">set1.add(<span class="number">1</span>);</span><br><span class="line">set1.add(<span class="number">5</span>);</span><br><span class="line">set1.add(<span class="number">2</span>);</span><br><span class="line">System.out.println(set1); <span class="comment">//[1,2,3,4,5,6,7,8]</span></span><br><span class="line"></span><br><span class="line">Set&lt;Integer&gt; set2= <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">set2.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">set2.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">set2.add(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">set2.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">set2.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">set2.add(<span class="string">&quot;f&quot;</span>);</span><br><span class="line">set2.add(<span class="string">&quot;g&quot;</span>);</span><br><span class="line">System.out.println(set1); <span class="comment">//[a,b,c,d,e,f,g]</span></span><br></pre></td></tr></table></figure>
<p>如果往TreeSet集合中存储自定义类型的元素，比如说Student类型，则需要我们自己指定排序规则，否则会出现异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建TreeSet集合，元素为Student类型</span></span><br><span class="line">Set&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建4个Student对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;至尊宝&quot;</span>,<span class="number">20</span>, <span class="number">169.6</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>,<span class="number">23</span>, <span class="number">169.8</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>,<span class="number">23</span>, <span class="number">169.6</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛魔王&quot;</span>,<span class="number">48</span>, <span class="number">169.6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加Studnet对象到集合</span></span><br><span class="line">students.add(s1);</span><br><span class="line">students.add(s2);</span><br><span class="line">students.add(s3);</span><br><span class="line">students.add(s4);</span><br><span class="line">System.out.println(students); </span><br></pre></td></tr></table></figure>
<p>此时运行代码，会直接报错。原因是TreeSet不知道按照什么条件对Student对象来排序。</p>
<p><img src="https://s2.loli.net/2024/05/06/aBZGfvWtNnmFwy6.webp" alt="1666172629095"></p>
<p>我们想要告诉TreeSet集合按照指定的规则排序，有两种办法：</p>
<blockquote>
<p>第一种：让元素的类实现Comparable接口，重写compareTo方法</p>
</blockquote>
<blockquote>
<p>第二种：在创建TreeSet集合时，通过构造方法传递Compartor比较器对象</p>
</blockquote>
<ul>
<li>**排序方式1：**我们先来演示第一种排序方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：先让Student类，实现Comparable接口</span></span><br><span class="line"><span class="comment">//注意：Student类的对象是作为TreeSet集合的元素的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height;</span><br><span class="line">	<span class="comment">//无参数构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//全参数构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> height)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">        <span class="built_in">this</span>.height=height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...get、set、toString()方法自己补上..</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二步：重写compareTo方法</span></span><br><span class="line">    <span class="comment">//按照年龄进行比较，只需要在方法中让this.age和o.age相减就可以。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    原理：</span></span><br><span class="line"><span class="comment">    在往TreeSet集合中添加元素时，add方法底层会调用compareTo方法，根据该方法的</span></span><br><span class="line"><span class="comment">    结果是正数、负数、还是零，决定元素放在后面、前面还是不存。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="comment">//this：表示将要添加进去的Student对象</span></span><br><span class="line">        <span class="comment">//o: 表示集合中已有的Student对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age-o.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，再运行测试类，结果如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;name=<span class="string">&#x27;至尊宝&#x27;</span>, age=<span class="number">20</span>, height=<span class="number">169.6</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;紫霞&#x27;</span>, age=<span class="number">20</span>, height=<span class="number">169.8</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;蜘蛛精&#x27;</span>, age=<span class="number">23</span>, height=<span class="number">169.6</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;牛魔王&#x27;</span>, age=<span class="number">48</span>, height=<span class="number">169.6</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>**排序方式2：**接下来演示第二种排序方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建TreeSet集合时，传递比较器对象排序</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原理：当调用add方法时，底层会先用比较器，根据Comparator的compare方是正数、负数、还是零，决定谁在后，谁在前，谁不存。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//下面代码中是按照学生的年龄升序排序</span></span><br><span class="line">Set&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">        <span class="comment">//需求：按照学生的身高排序</span></span><br><span class="line">        <span class="keyword">return</span> Double.compare(o1,o2); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建4个Student对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;至尊宝&quot;</span>,<span class="number">20</span>, <span class="number">169.6</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>,<span class="number">23</span>, <span class="number">169.8</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>,<span class="number">23</span>, <span class="number">169.6</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛魔王&quot;</span>,<span class="number">48</span>, <span class="number">169.6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加Studnet对象到集合</span></span><br><span class="line">students.add(s1);</span><br><span class="line">students.add(s2);</span><br><span class="line">students.add(s3);</span><br><span class="line">students.add(s4);</span><br><span class="line">System.out.println(students); </span><br></pre></td></tr></table></figure>
<h3 id="5-6-总结Collection集合">5.6 总结Collection集合</h3>
<p><img src="https://s2.loli.net/2024/05/06/PFDrofKe8pzZCVN.webp" alt="1666174020172"></p>
<h3 id="5-7-并发修改异常">5.7 并发修改异常</h3>
<ul>
<li>补充说明一下，那就是在使用迭代器遍历集合时，可能存在并发修改异常。</li>
</ul>
<p>我们先把这个异常用代码演示出来，再解释一下为什么会有这个异常产生</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;王麻子&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;小李子&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;李爱花&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;张全蛋&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;晓李&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;李玉刚&quot;</span>);</span><br><span class="line">System.out.println(list); <span class="comment">// [王麻子, 小李子, 李爱花, 张全蛋, 晓李, 李玉刚]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需求：找出集合中带&quot;李&quot;字的姓名，并从集合中删除</span></span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> it.next();</span><br><span class="line">    <span class="keyword">if</span>(name.contains(<span class="string">&quot;李&quot;</span>))&#123;</span><br><span class="line">        list.remove(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，会出现下面的异常。这就是并发修改异常</p>
<p><img src="https://s2.loli.net/2024/05/06/oiHD4VZgUPyXOfz.webp" alt="1666174432223"></p>
<p>为什么会出现这个异常呢？那是因为迭代器遍历机制，规定迭代器遍历集合的同时，不允许集合自己去增删元素，否则就会出现这个异常。</p>
<p>怎么解决这个问题呢？不使用集合的删除方法，而是使用迭代器的删除方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;王麻子&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;小李子&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;李爱花&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;张全蛋&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;晓李&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;李玉刚&quot;</span>);</span><br><span class="line">System.out.println(list); <span class="comment">// [王麻子, 小李子, 李爱花, 张全蛋, 晓李, 李玉刚]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需求：找出集合中带&quot;李&quot;字的姓名，并从集合中删除</span></span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> it.next();</span><br><span class="line">    <span class="keyword">if</span>(name.contains(<span class="string">&quot;李&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">//list.remove(name);</span></span><br><span class="line">        it.remove(); <span class="comment">//当前迭代器指向谁，就删除谁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<h2 id="六、Collection的其他操作">六、Collection的其他操作</h2>
<p>为了更加方便的对Collection集合进行操作，今天我们还要学习一个操作Collection集合的工具类，叫做Collections。但是Collections工具类中需要用到一个没有学过的小知识点，叫做可变参数，所以必须先学习这个前置知识可变参数，再学习Collections工具类。</p>
<h3 id="6-1-可变参数">6.1 可变参数</h3>
<p>关于可变参数我们首先要知道它是什么，然后要知道它的本质。搞清楚这两个问题，可变参数就算你学明白了。</p>
<blockquote>
<ul>
<li>
<p><strong>可变参数是一种特殊的形式参数，定义在方法、构造器的形参列表处，它可以让方法接收多个同类型的实际参数。</strong></p>
</li>
<li>
<p><strong>可变参数在方法内部，本质上是一个数组</strong></p>
</li>
</ul>
</blockquote>
<p>接下来，我们编写代码来演示一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//不传递参数，下面的nums长度则为0, 打印元素是[]</span></span><br><span class="line">        test();	</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//传递3个参数，下面的nums长度为3，打印元素是[10, 20, 30]</span></span><br><span class="line">        test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//传递一个数组，下面数组长度为4，打印元素是[10,20,30,40] </span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;</span><br><span class="line">        test(arr); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>...nums)</span>&#123;</span><br><span class="line">        <span class="comment">//可变参数在方法内部，本质上是一个数组</span></span><br><span class="line">        System.out.println(nums.length);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后还有一些错误写法，需要让大家写代码时注意一下，不要这么写哦！！！</p>
<blockquote>
<ul>
<li>
<p><strong>一个形参列表中，只能有一个可变参数；否则会报错</strong></p>
</li>
<li>
<p><strong>一个形参列表中如果多个参数，可变参数需要写在最后；否则会报错</strong></p>
</li>
</ul>
</blockquote>
<p><img src="https://s2.loli.net/2024/05/06/t4PawjUv2hbIcE8.webp" alt="1667194652653"></p>
<p><img src="https://s2.loli.net/2024/05/06/Xq1xTO5JEz9HPGY.webp" alt="1667194696892"></p>
<h3 id="6-2-Collections工具类">6.2 Collections工具类</h3>
<p>有了可变参数的基础，我们再学习Collections这个工具类就好理解了，因为这个工具类的方法中会用到可变参数。</p>
<p>注意Collections并不是集合，它比Collection多了一个s，一般后缀为s的类很多都是工具类。这里的Collections是用来操作Collection的工具类。它提供了一些好用的静态方法，如下</p>
<p><img src="https://s2.loli.net/2024/05/06/PYLQcjxgCfVToX7.webp" alt="1667195108724"></p>
<p>我们把这些方法用代码来演示一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//1.public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T...e)</span></span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(names, <span class="string">&quot;张三&quot;</span>,<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;李四&quot;</span>, <span class="string">&quot;张麻子&quot;</span>);</span><br><span class="line">        System.out.println(names);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.public static void shuffle(List&lt;?&gt; list)：对集合打乱顺序</span></span><br><span class="line">        Collections.shuffle(names);</span><br><span class="line">        System.out.println(names);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.public static &lt;T&gt; void short(List&lt;T list): 对List集合排序</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们往集合中存储的元素要么是Stirng类型，要么是Integer类型，他们本来就有一种自然顺序所以可以直接排序。但是如果我们往List集合中存储Student对象，这个时候想要对List集合进行排序自定义比较规则的。指定排序规则有两种方式，如下：</p>
<blockquote>
<p><strong>排序方式1：让元素实现Comparable接口，重写compareTo方法</strong></p>
</blockquote>
<p>比如现在想要往集合中存储Studdent对象，首先需要准备一个Student类，实现Comparable接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//排序时：底层会自动调用此方法，this和o表示需要比较的两个对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span>&#123;</span><br><span class="line">        <span class="comment">//需求：按照年龄升序排序</span></span><br><span class="line">        <span class="comment">//如果返回正数：说明左边对象的年龄&gt;右边对象的年龄</span></span><br><span class="line">        <span class="comment">//如果返回负数：说明左边对象的年龄&lt;右边对象的年龄，</span></span><br><span class="line">        <span class="comment">//如果返回0：说明左边对象的年龄和右边对象的年龄相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age - o.age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...getter、setter、constructor..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再使用<code>Collections.sort(list集合)</code>对List集合排序，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.public static &lt;T&gt; void short(List&lt;T list): 对List集合排序</span></span><br><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>,<span class="number">23</span>,<span class="number">169.7</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>,<span class="number">22</span>,<span class="number">169.8</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>,<span class="number">22</span>,<span class="number">169.8</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;至尊宝&quot;</span>,<span class="number">26</span>,<span class="number">169.5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原理：sort方法底层会遍历students集合中的每一个元素，采用排序算法，将任意两个元素两两比较；</span></span><br><span class="line"><span class="comment">	每次比较时，会用一个Student对象调用compareTo方法和另一个Student对象进行比较；</span></span><br><span class="line"><span class="comment">	根据compareTo方法返回的结果是正数、负数，零来决定谁大，谁小，谁相等，重新排序元素的位置</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	注意：这些都是sort方法底层自动完成的，想要完全理解，必须要懂排序算法才行；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Collections.sort(students);	</span><br><span class="line">System.out.println(students);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>排序方式2：使用调用sort方法是，传递比较器</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原理：sort方法底层会遍历students集合中的每一个元素，采用排序算法，将任意两个元素两两比较；</span></span><br><span class="line"><span class="comment">	每次比较，会将比较的两个元素传递给Comparator比较器对象的compare方法的两个参数o1和o2,</span></span><br><span class="line"><span class="comment">	根据compare方法的返回结果是正数，负数，或者0来决定谁大，谁小，谁相等，重新排序元素的位置</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	注意：这些都是sort方法底层自动完成的，不需要我们完全理解，想要理解它必须要懂排序算法才行.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Collections.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);	</span><br><span class="line">System.out.println(students);</span><br></pre></td></tr></table></figure>
<h2 id="七、Map集合">七、Map集合</h2>
<h3 id="7-1-Map概述体系">7.1 Map概述体系</h3>
<p>首先我们还是先认识一下什么是双列集合。</p>
<p>所谓双列集合，就是说集合中的元素是一对一对的。Map集合中的每一个元素是以<code>key=value</code>的形式存在的，一个<code>key=value</code>就称之为一个键值对，而且在Java中有一个类叫Entry类，Entry的对象用来表示键值对对象。</p>
<p>所有的Map集合有如下的特点：<strong>键不能重复，值可以重复，每一个键只能找到自己对应的值。</strong></p>
<p><img src="https://s2.loli.net/2024/05/06/X8BG4vqe7aiFpds.webp" alt="1667308368751"></p>
<p>下面我们先写一个Map集合，保存几个键值对，体验一下Map集合的特点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 一行经典代码。 按照键 无序，不重复，无索引。</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(); <span class="comment">// 有序，不重复，无索引。</span></span><br><span class="line">        map.put(<span class="string">&quot;手表&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">&quot;手表&quot;</span>, <span class="number">220</span>); <span class="comment">// 后面重复的数据会覆盖前面的数据（键）</span></span><br><span class="line">        map.put(<span class="string">&quot;手机&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Java&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, String&gt; map1 = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(); <span class="comment">// 可排序，不重复，无索引</span></span><br><span class="line">        map1.put(<span class="number">23</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map1.put(<span class="number">23</span>, <span class="string">&quot;MySQL&quot;</span>);</span><br><span class="line">        map1.put(<span class="number">19</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        map1.put(<span class="number">20</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        System.out.println(map1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Map集合也有很多种，在Java中使用不同的类来表示的，每一种Map集合其键的特点是有些差异的，值是键的一个附属值，所以我们只关注键的特点就可以了。</p>
<p><img src="https://s2.loli.net/2024/05/06/pYMg2mIxKSZhGOy.webp" alt="1667308506610"></p>
<h3 id="7-2-Map集合的常用方法">7.2 Map集合的常用方法</h3>
<p>由于Map是所有双列集合的父接口，所以我们只需要学习Map接口中每一个方法是什么含义，那么所有的Map集合方法你就都会用了。</p>
<p><img src="https://s2.loli.net/2024/05/06/ZNC8tej6JT23lQS.webp" alt="1667308854001"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.添加元素: 无序，不重复，无索引。</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;手表&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">&quot;手表&quot;</span>, <span class="number">220</span>);</span><br><span class="line">        map.put(<span class="string">&quot;手机&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Java&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">// map = &#123;null=null, 手表=220, Java=2, 手机=2&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.public int size():获取集合的大小</span></span><br><span class="line">        System.out.println(map.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、public void clear():清空集合</span></span><br><span class="line">        <span class="comment">//map.clear();</span></span><br><span class="line">        <span class="comment">//System.out.println(map);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.public boolean isEmpty(): 判断集合是否为空，为空返回true ,反之！</span></span><br><span class="line">        System.out.println(map.isEmpty());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.public V get(Object key)：根据键获取对应值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> map.get(<span class="string">&quot;手表&quot;</span>);</span><br><span class="line">        System.out.println(v1);</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;手机&quot;</span>)); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;张三&quot;</span>)); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. public V remove(Object key)：根据键删除整个元素(删除键会返回键的值)</span></span><br><span class="line">        System.out.println(map.remove(<span class="string">&quot;手表&quot;</span>));</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.public  boolean containsKey(Object key): 判断是否包含某个键 ，包含返回true ,反之</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="string">&quot;手表&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="string">&quot;手机&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="string">&quot;java&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="string">&quot;Java&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8.public boolean containsValue(Object value): 判断是否包含某个值。</span></span><br><span class="line">        System.out.println(map.containsValue(<span class="number">2</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(map.containsValue(<span class="string">&quot;2&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9.public Set&lt;K&gt; keySet(): 获取Map集合的全部键。</span></span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        System.out.println(keys);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 10.public Collection&lt;V&gt; values(); 获取Map集合的全部值。</span></span><br><span class="line">        Collection&lt;Integer&gt; values = map.values();</span><br><span class="line">        System.out.println(values);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 11.把其他Map集合的数据倒入到自己集合中来。(拓展)</span></span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">&quot;java1&quot;</span>,  <span class="number">10</span>);</span><br><span class="line">        map1.put(<span class="string">&quot;java2&quot;</span>,  <span class="number">20</span>);</span><br><span class="line">        Map&lt;String, Integer&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map2.put(<span class="string">&quot;java3&quot;</span>,  <span class="number">10</span>);</span><br><span class="line">        map2.put(<span class="string">&quot;java2&quot;</span>,  <span class="number">222</span>);</span><br><span class="line">        map1.putAll(map2); <span class="comment">// putAll：把map2集合中的元素全部倒入一份到map1集合中去。</span></span><br><span class="line">        System.out.println(map1);</span><br><span class="line">        System.out.println(map2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-2-1-Map集合遍历方式1">7.2.1 Map集合遍历方式1</h4>
<p>Map集合一共有三种遍历方式，我们先来看第一种</p>
<p><img src="https://s2.loli.net/2024/05/06/XITmfR3ibVa1EOg.webp" alt="1667308962740"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：掌握Map集合的遍历方式1：键找值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 准备一个Map集合。</span></span><br><span class="line">        Map&lt;String, Double&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">162.5</span>);</span><br><span class="line">        map.put(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">169.8</span>);</span><br><span class="line">        map.put(<span class="string">&quot;紫霞&quot;</span>, <span class="number">165.8</span>);</span><br><span class="line">        map.put(<span class="string">&quot;至尊宝&quot;</span>, <span class="number">169.5</span>);</span><br><span class="line">        map.put(<span class="string">&quot;牛魔王&quot;</span>, <span class="number">183.6</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">// map = &#123;蜘蛛精=169.8, 牛魔王=183.6, 至尊宝=169.5, 紫霞=165.8&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、获取Map集合的全部键</span></span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="comment">// System.out.println(keys);</span></span><br><span class="line">        <span class="comment">// [蜘蛛精, 牛魔王, 至尊宝, 紫霞]</span></span><br><span class="line">        <span class="comment">//         key</span></span><br><span class="line">        <span class="comment">// 2、遍历全部的键，根据键获取其对应的值</span></span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            <span class="comment">// 根据键获取对应的值</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;=====&gt;&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-2-2-Map集合遍历方式2">7.2.2 Map集合遍历方式2</h4>
<p>Map集合的第二种遍历方式，这种遍历方式更加符合面向对象的思维。</p>
<p>前面我们给大家介绍过，Map集合是用来存储键值对的，而每一个键值对实际上是一个Entry对象。</p>
<p><strong>这里Map集合的第二种方式，是直接获取每一个Entry对象，把Entry存储扫Set集合中去，再通过Entry对象获取键和值。</strong></p>
<p><img src="https://s2.loli.net/2024/05/06/FZ5JdlCbUYOQ4KD.webp" alt="1667309587178"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握Map集合的第二种遍历方式：键值对。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Double&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">169.8</span>);</span><br><span class="line">        map.put(<span class="string">&quot;紫霞&quot;</span>, <span class="number">165.8</span>);</span><br><span class="line">        map.put(<span class="string">&quot;至尊宝&quot;</span>, <span class="number">169.5</span>);</span><br><span class="line">        map.put(<span class="string">&quot;牛魔王&quot;</span>, <span class="number">183.6</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">// map = &#123;蜘蛛精=169.8, 牛魔王=183.6, 至尊宝=169.5, 紫霞=165.8&#125;</span></span><br><span class="line">        <span class="comment">// entries = [(蜘蛛精=169.8), (牛魔王=183.6), (至尊宝=169.5), (紫霞=165.8)]</span></span><br><span class="line">        <span class="comment">// entry = (蜘蛛精=169.8)</span></span><br><span class="line">        <span class="comment">// entry = (牛魔王=183.6)</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 1、调用Map集合提供entrySet方法，把Map集合转换成键值对类型的Set集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Double&gt; entry : entries) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">double</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;----&gt;&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-2-3-Map集合遍历方式3">7.2.3 Map集合遍历方式3</h4>
<p>Map集合的第三种遍历方式，需要用到下面的一个方法forEach，而这个方法是JDK8版本以后才有的。调用起来非常简单，最好是结合的lambda表达式一起使用。</p>
<p><img src="https://s2.loli.net/2024/05/06/C1JR2Xhvk7pVEms.webp" alt="1667309230571"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握Map集合的第二种遍历方式：键值对。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Double&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">169.8</span>);</span><br><span class="line">        map.put(<span class="string">&quot;紫霞&quot;</span>, <span class="number">165.8</span>);</span><br><span class="line">        map.put(<span class="string">&quot;至尊宝&quot;</span>, <span class="number">169.5</span>);</span><br><span class="line">        map.put(<span class="string">&quot;牛魔王&quot;</span>, <span class="number">183.6</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">// map = &#123;蜘蛛精=169.8, 牛魔王=183.6, 至尊宝=169.5, 紫霞=165.8&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//遍历map集合，传递匿名内部类</span></span><br><span class="line">        map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;String, Double&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String k, Double v)</span> &#123;</span><br><span class="line">                System.out.println(k + <span class="string">&quot;----&gt;&quot;</span> + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">		<span class="comment">//遍历map集合，传递Lambda表达式</span></span><br><span class="line">        map.forEach(( k,  v) -&gt; &#123;</span><br><span class="line">            System.out.println(k + <span class="string">&quot;----&gt;&quot;</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-HashMap">7.3 HashMap</h3>
<p>HashMap集合的底层原理。前面我们学习过HashSet的底层原理，实际上HashMap底层原理和HashSet是一样的。为什么这么说呢？因为我们往HashSet集合中添加元素时，实际上是把元素作为添加添加到了HashMap集合中。</p>
<p>下面是Map集合的体系结构，HashMap集合的特点是由键决定的： <strong>它的键是无序、不能重复，而且没有索引的</strong>。再各种Map集合中也是用得最多的一种集合。</p>
<p><img src="https://s2.loli.net/2024/05/06/EgSRl94OrytQVZB.webp" alt="1667641305473"></p>
<p>刚才我们说，HashSet底层就是HashMap，我们可以看源码验证这一点，如下图所示，我们可以看到，创建HashSet集合时，底层帮你创建了HashMap集合；往HashSet集合中添加添加元素时，底层却是调用了Map集合的put方法把元素作为了键来存储。所以实际上根本没有什么HashSet集合，把HashMap的集合的值忽略不看就是HashSet集合。</p>
<p><img src="https://s2.loli.net/2024/05/06/uehVqA64DnPLQUf.webp" alt="1667641783744"></p>
<p>HashSet的原理我们之前已经学过了，所以HashMap是一样的，底层是哈希表结构。</p>
<p><img src="https://s2.loli.net/2024/05/06/3GL6KqWJ97sxOUn.webp" alt="1667644579895"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">HashMap底层数据结构: 哈希表结构</span><br><span class="line">	JDK8之前的哈希表 = 数组+链表</span><br><span class="line">	JDK8之后的哈希表 = 数组+链表+红黑树</span><br><span class="line">	哈希表是一种增删改查数据，性能相对都较好的数据结构</span><br><span class="line">	</span><br><span class="line">往HashMap集合中键值对数据时，底层步骤如下</span><br><span class="line">	第<span class="number">1</span>步：当你第一次往HashMap集合中存储键值对时，底层会创建一个长度为<span class="number">16</span>的数组</span><br><span class="line">	第<span class="number">2</span>步：把键然后将键和值封装成一个对象，叫做Entry对象</span><br><span class="line">	第<span class="number">3</span>步：再根据Entry对象的键计算hashCode值（和值无关）</span><br><span class="line">	第<span class="number">4</span>步：利用hashCode值和数组的长度做一个类似求余数的算法，会得到一个索引位置</span><br><span class="line">	第<span class="number">5</span>步：判断这个索引的位置是否为<span class="literal">null</span>，如果为<span class="literal">null</span>,就直接将这个Entry对象存储到这个索引位置</span><br><span class="line">		   如果不为<span class="literal">null</span>，则还需要进行第<span class="number">6</span>步的判断</span><br><span class="line">	第<span class="number">6</span>步：继续调用equals方法判断两个对象键是否相同</span><br><span class="line">		  如果equals返回<span class="literal">false</span>，则以链表的形式往下挂</span><br><span class="line">		  如果equals方法<span class="literal">true</span>,则认为键重复，此时新的键值对会替换就的键值对。</span><br><span class="line">	</span><br><span class="line">HashMap底层需要注意这几点：</span><br><span class="line">	<span class="number">1.</span>底层数组默认长度为<span class="number">16</span>，如果数组中有超过<span class="number">12</span>个位置已经存储了元素，则会对数组进行扩容<span class="number">2</span>倍</span><br><span class="line">	  数组扩容的加载因子是<span class="number">0.75</span>，意思是：<span class="number">16</span>*<span class="number">0.75</span>=<span class="number">12</span> 	</span><br><span class="line">   	</span><br><span class="line">    <span class="number">2.</span>数组的同一个索引位置有多个元素、并且在<span class="number">8</span>个元素以内(包括<span class="number">8</span>)，则以链表的形式存储</span><br><span class="line">    	JDK7版本：链表采用头插法（新元素往链表的头部添加）</span><br><span class="line">    	JDK8版本：链表采用尾插法（新元素我那个链表的尾部添加）</span><br><span class="line">    	</span><br><span class="line">    <span class="number">3.</span>数组的同一个索引位置有多个元素、并且超过了<span class="number">8</span>个，则以红黑树形式存储</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>从HashMap底层存储键值对的过程中我们发现：决定键是否重复依赖与两个方法，一个是hashCode方法、一个是equals方法。有两个键计算得到的hashCode值相同，并且两个键使用equals比较为true，就认为键重复。</p>
<p><strong>所以，往Map集合中存储自定义对象作为键，为了保证键的唯一性，我们应该重写hashCode方法和equals方法。</strong></p>
<p>比如有如下案例：往HashMap集合中存储Student对象作为键，学生的家庭住址当做值。要求，当学生对象的姓名和年龄相同时就认为键重复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this  o</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age - o.age; <span class="comment">// 年龄升序排序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp; Double.compare(student.height, height) == <span class="number">0</span> &amp;&amp; Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...get,set方法自己补全....</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, height=&quot;</span> + height +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写一个测试类，在测试类中，创建HashMap集合，键是Student类型，值是Stirng类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握Map集合下的实现类：HashMap集合的底层原理。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1HashMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;Student, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">25</span>, <span class="number">168.5</span>), <span class="string">&quot;盘丝洞&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">25</span>, <span class="number">168.5</span>), <span class="string">&quot;水帘洞&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;至尊宝&quot;</span>, <span class="number">23</span>, <span class="number">163.5</span>), <span class="string">&quot;水帘洞&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛魔王&quot;</span>, <span class="number">28</span>, <span class="number">183.5</span>), <span class="string">&quot;牛头山&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面存储的键，有两个蜘蛛精，但是打印出只会有最后一个。</p>
</blockquote>
<h3 id="7-4-LinkedHashMap">7.4 LinkedHashMap</h3>
<ul>
<li>LinkedHashMap集合的特点也是由键决定的：<strong>有序的、不重复、无索引</strong>。</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/06/tuyZ5SWmor4Kwvg.webp" alt="1667646792308"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握LinkedHashMap的底层原理。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2LinkedHashMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();    //  按照键 无序，不重复，无索引。</span></span><br><span class="line">        LinkedHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(); <span class="comment">//  按照键 有序，不重复，无索引。</span></span><br><span class="line">        map.put(<span class="string">&quot;手表&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">&quot;手表&quot;</span>, <span class="number">220</span>);</span><br><span class="line">        map.put(<span class="string">&quot;手机&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Java&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面代码发现，如果是LinedHashMap集合键存储和取出的顺序是一样的</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">手表=220</span>,<span class="string">手机=2</span>,<span class="string">Java=2</span>,<span class="literal">null</span><span class="string">=null</span>&#125;</span><br></pre></td></tr></table></figure>
<p>如果是HashMap，键存储和取出的顺序是不一致的</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="literal">null</span><span class="string">=null</span>,<span class="string">手机=2</span>,<span class="string">手表=220</span>,<span class="string">Java=2</span>,&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>LinkedHashMap的底层原理，和LinkedHashSet底层原理是一样的。底层多个一个双向链表来维护键的存储顺序。</li>
</ul>
<p>​      取元素时，先取头节点元素，然后再依次取下一个几点，一直到尾结点。所以是有序的。</p>
<p><img src="https://s2.loli.net/2024/05/06/J3s16W9Q7zn8TEo.webp" alt="1667647222054"></p>
<h3 id="7-5-TreeMap">7.5 TreeMap</h3>
<ul>
<li>TreeMap集合的特点也是由键决定的，默认按照键的升序排列，键不重复，也是无索引的。</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/06/aT56ePJ2koOKGBE.webp" alt="1667647400490"></p>
<ul>
<li>
<p>TreeMap集合的底层原理和TreeSet也是一样的，底层都是红黑树实现的。所以可以对键进行排序。</p>
<p>比如往TreeMap集合中存储Student对象作为键，排序方法有两种。直接看代码吧</p>
</li>
</ul>
<p>**排序方式1：**写一个Student类，让Student类实现Comparable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：先让Student类，实现Comparable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height;</span><br><span class="line">	<span class="comment">//无参数构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//全参数构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> height)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">        <span class="built_in">this</span>.height=height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...get、set、toString()方法自己补上..</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//按照年龄进行比较，只需要在方法中让this.age和o.age相减就可以。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    原理：</span></span><br><span class="line"><span class="comment">    在往TreeSet集合中添加元素时，add方法底层会调用compareTo方法，根据该方法的</span></span><br><span class="line"><span class="comment">    结果是正数、负数、还是零，决定元素放在后面、前面还是不存。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="comment">//this：表示将要添加进去的Student对象</span></span><br><span class="line">        <span class="comment">//o: 表示集合中已有的Student对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age-o.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**排序方式2：**在创建TreeMap集合时，直接传递Comparator比较器对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握TreeMap集合的使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3TreeMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;Student, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Double.compare(o1.getHeight(), o2.getHeight());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//        Map&lt;Student, String&gt; map = new TreeMap&lt;&gt;(( o1,  o2) -&gt;   Double.compare(o2.getHeight(), o1.getHeight()));</span></span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">25</span>, <span class="number">168.5</span>), <span class="string">&quot;盘丝洞&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">25</span>, <span class="number">168.5</span>), <span class="string">&quot;水帘洞&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;至尊宝&quot;</span>, <span class="number">23</span>, <span class="number">163.5</span>), <span class="string">&quot;水帘洞&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛魔王&quot;</span>, <span class="number">28</span>, <span class="number">183.5</span>), <span class="string">&quot;牛头山&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式都可以对TreeMap集合中的键排序。<strong>注意：只有TreeMap的键才能排序，HashMap键不能排序。</strong></p>
<h1 id="Stream流、File类">Stream流、File类</h1>
<h2 id="一、JDK8新特性（Stream流）">一、JDK8新特性（Stream流）</h2>
<h3 id="1-1-Stream流体验">1.1 Stream流体验</h3>
<p>案例需求：有一个List集合，元素有<code>&quot;张三丰&quot;,&quot;张无忌&quot;,&quot;周芷若&quot;,&quot;赵敏&quot;,&quot;张强&quot;</code>，找出姓张，且是3个字的名字，存入到一个新集合中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(names, <span class="string">&quot;张三丰&quot;</span>,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;周芷若&quot;</span>,<span class="string">&quot;赵敏&quot;</span>,<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">System.out.println(names);</span><br></pre></td></tr></table></figure>
<ul>
<li>用传统方式来做，代码是这样的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出姓张，且是3个字的名字，存入到一个新集合中去。</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">    <span class="keyword">if</span>(name.startsWith(<span class="string">&quot;张&quot;</span>) &amp;&amp; name.length() == <span class="number">3</span>)&#123;</span><br><span class="line">        list.add(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<ul>
<li>用Stream流来做，代码是这样的（ps: 是不是想流水线一样，一句话就写完了）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list2 = names.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).filter(a -&gt; a.length()==<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(list2);</span><br></pre></td></tr></table></figure>
<p>学习Stream流我们接下来，会按照下面的步骤来学习。</p>
<p><img src="https://s2.loli.net/2024/05/07/teRuipImfSswlQM.webp" alt="1667649164429"></p>
<h3 id="1-2-Stream流的创建">1.2 Stream流的创建</h3>
<p>如何创建Stream流、或者叫获取Stream流。</p>
<p><img src="https://s2.loli.net/2024/05/07/rhG2WQqpcD3RFTs.webp" alt="1667649331568"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主要掌握下面四点：</span><br><span class="line">	<span class="number">1</span>、如何获取List集合的Stream流？</span><br><span class="line">	<span class="number">2</span>、如何获取Set集合的Stream流？</span><br><span class="line">	<span class="number">3</span>、如何获取Map集合的Stream流？</span><br><span class="line">	<span class="number">4</span>、如何获取数组的Stream流？</span><br></pre></td></tr></table></figure>
<p>直接上代码演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握Stream流的创建。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、如何获取List集合的Stream流？</span></span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(names, <span class="string">&quot;张三丰&quot;</span>,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;周芷若&quot;</span>,<span class="string">&quot;赵敏&quot;</span>,<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; stream = names.stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、如何获取Set集合的Stream流？</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(set, <span class="string">&quot;刘德华&quot;</span>,<span class="string">&quot;张曼玉&quot;</span>,<span class="string">&quot;蜘蛛精&quot;</span>,<span class="string">&quot;马德&quot;</span>,<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; stream1 = set.stream();</span><br><span class="line">        stream1.filter(s -&gt; s.contains(<span class="string">&quot;德&quot;</span>)).forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、如何获取Map集合的Stream流？</span></span><br><span class="line">        Map&lt;String, Double&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">172.3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">168.3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;马尔扎哈&quot;</span>, <span class="number">166.3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;卡尔扎巴&quot;</span>, <span class="number">168.3</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        Stream&lt;String&gt; ks = keys.stream();</span><br><span class="line"></span><br><span class="line">        Collection&lt;Double&gt; values = map.values();</span><br><span class="line">        Stream&lt;Double&gt; vs = values.stream();</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = map.entrySet();</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, Double&gt;&gt; kvs = entries.stream();</span><br><span class="line">        kvs.filter(e -&gt; e.getKey().contains(<span class="string">&quot;巴&quot;</span>))</span><br><span class="line">                .forEach(e -&gt; System.out.println(e.getKey()+ <span class="string">&quot;--&gt;&quot;</span> + e.getValue()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、如何获取数组的Stream流？</span></span><br><span class="line">        String[] names2 = &#123;<span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;东方不败&quot;</span>, <span class="string">&quot;唐大山&quot;</span>, <span class="string">&quot;独孤求败&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; s1 = Arrays.stream(names2);</span><br><span class="line">        Stream&lt;String&gt; s2 = Stream.of(names2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1-3-Stream流中间方法">1.3 Stream流中间方法</h3>
<p>Stream流中间操作的方法。</p>
<p><strong>中间方法指的是：调用完方法之后其结果是一个新的Stream流，于是可以继续调用方法，这样一来就可以支持链式编程</strong>（或者叫流式编程）。</p>
<p><img src="https://s2.loli.net/2024/05/07/6kH4zlUjCaRSedF.webp" alt="1667649379223"></p>
<p><img src="https://s2.loli.net/2024/05/07/BQzAty1aV6XrucU.webp" alt="1667649509262"></p>
<p>代码演示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握Stream流提供的常见中间方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; scores = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(scores, <span class="number">88.5</span>, <span class="number">100.0</span>, <span class="number">60.0</span>, <span class="number">99.0</span>, <span class="number">9.5</span>, <span class="number">99.6</span>, <span class="number">25.0</span>);</span><br><span class="line">        <span class="comment">// 需求1：找出成绩大于等于60分的数据，并升序后，再输出。</span></span><br><span class="line">        scores.stream().filter(s -&gt; s &gt;= <span class="number">60</span>).sorted().forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">26</span>, <span class="number">172.5</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">26</span>, <span class="number">172.5</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>, <span class="number">23</span>, <span class="number">167.6</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;白晶晶&quot;</span>, <span class="number">25</span>, <span class="number">169.0</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛魔王&quot;</span>, <span class="number">35</span>, <span class="number">183.3</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛夫人&quot;</span>, <span class="number">34</span>, <span class="number">168.5</span>);</span><br><span class="line">        Collections.addAll(students, s1, s2, s3, s4, s5, s6);</span><br><span class="line">        <span class="comment">// 需求2：找出年龄大于等于23,且年龄小于等于30岁的学生，并按照年龄降序输出.</span></span><br><span class="line">        students.stream().filter(s -&gt; s.getAge() &gt;= <span class="number">23</span> &amp;&amp; s.getAge() &lt;= <span class="number">30</span>)</span><br><span class="line">                .sorted((o1, o2) -&gt; o2.getAge() - o1.getAge())</span><br><span class="line">                .forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求3：取出身高最高的前3名学生，并输出。</span></span><br><span class="line">        students.stream().sorted((o1, o2) -&gt; Double.compare(o2.getHeight(), o1.getHeight()))</span><br><span class="line">                .limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求4：取出身高倒数的2名学生，并输出。   s1 s2 s3 s4 s5 s6</span></span><br><span class="line">        students.stream().sorted((o1, o2) -&gt; Double.compare(o2.getHeight(), o1.getHeight()))</span><br><span class="line">                .skip(students.size() - <span class="number">2</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求5：找出身高超过168的学生叫什么名字，要求去除重复的名字，再输出。</span></span><br><span class="line">        students.stream().filter(s -&gt; s.getHeight() &gt; <span class="number">168</span>).map(Student::getName)</span><br><span class="line">               .distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// distinct去重复，自定义类型的对象（希望内容一样就认为重复，重写hashCode,equals）</span></span><br><span class="line">        students.stream().filter(s -&gt; s.getHeight() &gt; <span class="number">168</span>)</span><br><span class="line">                .distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; st1 = Stream.of(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; st2 = Stream.of(<span class="string">&quot;张三2&quot;</span>, <span class="string">&quot;李四2&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; allSt = Stream.concat(st1, st2);</span><br><span class="line">        allSt.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-Stream流终结方法">1.4 Stream流终结方法</h3>
<p>Stream流的终结方法。这些方法的特点是，调用完方法之后，其结果就不再是Stream流了，所以不支持链式编程。</p>
<p><img src="https://s2.loli.net/2024/05/07/EMIiWLeSKQFzj1C.webp" alt="1667649788535"></p>
<p>下面的几个终结方法:</p>
<p><img src="https://s2.loli.net/2024/05/07/mFv9ux4eZgz6od2.webp" alt="1667649867150"></p>
<p>话不多说，直接上代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：Stream流的终结方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">26</span>, <span class="number">172.5</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">26</span>, <span class="number">172.5</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>, <span class="number">23</span>, <span class="number">167.6</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;白晶晶&quot;</span>, <span class="number">25</span>, <span class="number">169.0</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛魔王&quot;</span>, <span class="number">35</span>, <span class="number">183.3</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛夫人&quot;</span>, <span class="number">34</span>, <span class="number">168.5</span>);</span><br><span class="line">        Collections.addAll(students, s1, s2, s3, s4, s5, s6);</span><br><span class="line">        <span class="comment">// 需求1：请计算出身高超过168的学生有几人。</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> students.stream().filter(s -&gt; s.getHeight() &gt; <span class="number">168</span>).count();</span><br><span class="line">        System.out.println(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求2：请找出身高最高的学生对象，并输出。</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> students.stream().max((o1, o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight())).get();</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求3：请找出身高最矮的学生对象，并输出。</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">ss</span> <span class="operator">=</span> students.stream().min((o1, o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight())).get();</span><br><span class="line">        System.out.println(ss);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求4：请找出身高超过170的学生对象，并放到一个新集合中去返回。</span></span><br><span class="line">        <span class="comment">// 流只能收集一次。</span></span><br><span class="line">        List&lt;Student&gt; students1 = students.stream().filter(a -&gt; a.getHeight() &gt; <span class="number">170</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(students1);</span><br><span class="line"></span><br><span class="line">        Set&lt;Student&gt; students2 = students.stream().filter(a -&gt; a.getHeight() &gt; <span class="number">170</span>).collect(Collectors.toSet());</span><br><span class="line">        System.out.println(students2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求5：请找出身高超过170的学生对象，并把学生对象的名字和身高，存入到一个Map集合返回。</span></span><br><span class="line">        Map&lt;String, Double&gt; map =</span><br><span class="line">                students.stream().filter(a -&gt; a.getHeight() &gt; <span class="number">170</span>)</span><br><span class="line">                        .distinct().collect(Collectors.toMap(a -&gt; a.getName(), a -&gt; a.getHeight()));</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Object[] arr = students.stream().filter(a -&gt; a.getHeight() &gt; 170).toArray();</span></span><br><span class="line">        Student[] arr = students.stream().filter(a -&gt; a.getHeight() &gt; <span class="number">170</span>).toArray(len -&gt; <span class="keyword">new</span> <span class="title class_">Student</span>[len]);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、File类">二、File类</h2>
<blockquote>
<p>**但是需要我们注意：**File对象只能对文件进行操作，不能操作文件中的内容。</p>
</blockquote>
<h3 id="2-1-File对象的创建">2.1 File对象的创建</h3>
<p>学习File类和其他类一样，第一步是创建File类的对象。 想要创建对象，我们得看File类有哪些构造方法。</p>
<p><img src="https://s2.loli.net/2024/05/07/R9FJ7YacMlmv6Dp.webp" alt="1667651303731"></p>
<p>下面我们演示一下，File类创建对象的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需求我们注意的是：路径中<span class="string">&quot;\&quot;要写成&quot;</span>\\<span class="string">&quot;， 路径中&quot;</span>/<span class="string">&quot;可以直接用</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握File创建对象，代表具体文件的方案。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个File对象，指代某个具体的文件。</span></span><br><span class="line">        <span class="comment">// 路径分隔符</span></span><br><span class="line">        <span class="comment">// File f1 = new File(&quot;D:/resource/ab.txt&quot;);</span></span><br><span class="line">        <span class="comment">// File f1 = new File(&quot;D:\\resource\\ab.txt&quot;);</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:&quot;</span> + File.separator +<span class="string">&quot;resource&quot;</span> + File.separator + <span class="string">&quot;ab.txt&quot;</span>);</span><br><span class="line">        System.out.println(f1.length()); <span class="comment">// 文件大小</span></span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource&quot;</span>);</span><br><span class="line">        System.out.println(f2.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：File对象可以指代一个不存在的文件路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/aaaa.txt&quot;</span>);</span><br><span class="line">        System.out.println(f3.length());</span><br><span class="line">        System.out.println(f3.exists()); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我现在要定位的文件是在模块中，应该怎么定位呢？</span></span><br><span class="line">        <span class="comment">// 绝对路径：带盘符的</span></span><br><span class="line">        <span class="comment">// File f4 = new File(&quot;D:\\code\\javasepromax\\file-io-app\\src\\itheima.txt&quot;);</span></span><br><span class="line">        <span class="comment">// 相对路径（重点）：不带盘符，默认是直接去工程下寻找文件的。</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app\\src\\itheima.txt&quot;</span>);</span><br><span class="line">        System.out.println(f4.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-File判断和获取方法">2.2 File判断和获取方法</h3>
<p>File对象封装的路径是存在还是不存在，是文件还是文件夹其实是不清楚的。好在File类提供了方法可以帮我们做判断。</p>
<p><img src="https://s2.loli.net/2024/05/07/IZGmXtHfQoc2xpP.webp" alt="1667659321570"></p>
<p>话不多少，直接上代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：掌握File提供的判断文件类型、获取文件信息功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 1.创建文件对象，指代某个文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/ab.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//File f1 = new File(&quot;D:/resource/&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、public boolean exists()：判断当前文件对象，对应的文件路径是否存在，存在返回true.</span></span><br><span class="line">        System.out.println(f1.exists());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、public boolean isFile() : 判断当前文件对象指代的是否是文件，是文件返回true，反之。</span></span><br><span class="line">        System.out.println(f1.isFile());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、public boolean isDirectory()  : 判断当前文件对象指代的是否是文件夹，是文件夹返回true，反之。</span></span><br><span class="line">        System.out.println(f1.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了判断功能还有一些获取功能，看代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/ab.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.public String getName()：获取文件的名称（包含后缀）</span></span><br><span class="line">System.out.println(f1.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.public long length()：获取文件的大小，返回字节个数</span></span><br><span class="line">System.out.println(f1.length());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.public long lastModified()：获取文件的最后修改时间。</span></span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> f1.lastModified();</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(sdf.format(time));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.public String getPath()：获取创建文件对象时，使用的路径</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\resource\\ab.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app\\src\\itheima.txt&quot;</span>);</span><br><span class="line">System.out.println(f2.getPath());</span><br><span class="line">System.out.println(f3.getPath());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9.public String getAbsolutePath()：获取绝对路径</span></span><br><span class="line">System.out.println(f2.getAbsolutePath());</span><br><span class="line">System.out.println(f3.getAbsolutePath());</span><br></pre></td></tr></table></figure>
<h3 id="2-3-创建和删除方法">2.3 创建和删除方法</h3>
<p>File类提供了创建和删除文件的方法，话不多少，看代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握File创建和删除文件相关的方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、public boolean createNewFile()：创建一个新文件（文件内容为空），创建成功返回true,反之。</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/itheima2.txt&quot;</span>);</span><br><span class="line">        System.out.println(f1.createNewFile());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、public boolean mkdir()：用于创建文件夹，注意：只能创建一级文件夹</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/aaa&quot;</span>);</span><br><span class="line">        System.out.println(f2.mkdir());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、public boolean mkdirs()：用于创建文件夹，注意：可以创建多级文件夹</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/bbb/ccc/ddd/eee/fff/ggg&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdirs());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、public boolean delete()：删除文件，或者空文件，注意：不能删除非空文件夹。</span></span><br><span class="line">        System.out.println(f1.delete());</span><br><span class="line">        System.out.println(f2.delete());</span><br><span class="line">        <span class="type">File</span> <span class="variable">f4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource&quot;</span>);</span><br><span class="line">        System.out.println(f4.delete());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>mkdir(): 只能创建单级文件夹、</span><br><span class="line"><span class="number">2.</span>mkdirs(): 才能创建多级文件夹</span><br><span class="line"><span class="number">3.</span>delete(): 文件可以直接删除，但是文件夹只能删除空的文件夹，文件夹有内容删除不了。</span><br></pre></td></tr></table></figure>
<h3 id="2-4-遍历文件夹方法">2.4 遍历文件夹方法</h3>
<p><img src="https://s2.loli.net/2024/05/07/JN4buCykFGna9hI.webp" alt="1667659732559"></p>
<p>话不多少上代码，演示一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握File提供的遍历文件夹的方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、public String[] list()：获取当前目录下所有的&quot;一级文件名称&quot;到一个字符串数组中去返回。</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\course\\待研发内容&quot;</span>);</span><br><span class="line">        String[] names = f1.list();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、public File[] listFiles():（重点）获取当前目录下所有的&quot;一级文件对象&quot;到一个文件对象数组中去返回（重点）</span></span><br><span class="line">        File[] files = f1.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/aaa&quot;</span>);</span><br><span class="line">        File[] files1 = f.listFiles();</span><br><span class="line">        System.out.println(Arrays.toString(files1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意几个问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>当主调是文件时，或者路径不存在时，返回<span class="literal">null</span></span><br><span class="line"><span class="number">2.</span>当主调是空文件夹时，返回一个长度为<span class="number">0</span>的数组</span><br><span class="line"><span class="number">3.</span>当主调是一个有内容的文件夹时，将里面所有一级文件和文件夹路径放在File数组中，并把数组返回</span><br><span class="line"><span class="number">4.</span>当主调是一个文件夹，且里面有隐藏文件时，将里面所有文件和文件夹的路径放在FIle数组中，包含隐藏文件</span><br><span class="line"><span class="number">5.</span>当主调是一个文件夹，但是没有权限访问时，返回<span class="literal">null</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-递归文件搜索">2.5 递归文件搜索</h3>
<p>案例需求：在<code>D:\\</code>判断下搜索QQ.exe这个文件，然后直接输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>先调用文件夹的listFiles方法，获取文件夹的一级内容，得到一个数组</span><br><span class="line"><span class="number">2.</span>然后再遍历数组，获取数组中的File对象</span><br><span class="line"><span class="number">3.</span>因为File对象可能是文件也可能是文件夹，所以接下来就需要判断</span><br><span class="line">	判断File对象如果是文件，就获取文件名，如果文件名是`QQ.exe`则打印，否则不打印</span><br><span class="line">	判断File对象如果是文件夹，就递归执行<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>步骤</span><br><span class="line">所以：把<span class="number">1</span>，<span class="number">2</span>,<span class="number">3</span>步骤写成方法，递归调用即可。</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握文件搜索的实现。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">          searchFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/&quot;</span>) , <span class="string">&quot;QQ.exe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 去目录下搜索某个文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dir  目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 要搜索的文件名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchFile</span><span class="params">(File dir, String fileName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、把非法的情况都拦截住</span></span><br><span class="line">        <span class="keyword">if</span>(dir == <span class="literal">null</span> || !dir.exists() || dir.isFile())&#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 代表无法搜索</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、dir不是null,存在，一定是目录对象。</span></span><br><span class="line">        <span class="comment">// 获取当前目录下的全部一级文件对象。</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、判断当前目录下是否存在一级文件对象，以及是否可以拿到一级文件对象。</span></span><br><span class="line">        <span class="keyword">if</span>(files != <span class="literal">null</span> &amp;&amp; files.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 4、遍历全部一级文件对象。</span></span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                <span class="comment">// 5、判断文件是否是文件,还是文件夹</span></span><br><span class="line">                <span class="keyword">if</span>(f.isFile())&#123;</span><br><span class="line">                    <span class="comment">// 是文件，判断这个文件名是否是我们要找的</span></span><br><span class="line">                    <span class="keyword">if</span>(f.getName().contains(fileName))&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;找到了：&quot;</span> + f.getAbsolutePath());</span><br><span class="line">                        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">                        runtime.exec(f.getAbsolutePath());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 是文件夹，继续重复这个过程（递归）</span></span><br><span class="line">                    searchFile(f, fileName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符集、IO流-一">字符集、IO流(一)</h1>
<h2 id="一、字符集">一、字符集</h2>
<h3 id="1-1-字符集的来历">1.1 字符集的来历</h3>
<p>我们知道计算机是美国人发明的，由于计算机能够处理的数据只能是0和1组成的二进制数据，为了让计算机能够处理字符，于是美国人就把他们会用到的每一个字符进行了编码（<strong>所谓编码，就是为一个字符编一个二进制数据</strong>），如下图所示：</p>
<p><img src="https://s2.loli.net/2024/05/07/cAbBt8KyQ6TUqYg.webp" alt="1667738471094"></p>
<p>美国人常用的字符有英文字母、标点符号、数字以及一些特殊字符，这些字符一共也不到128个，所以他们用1个字节来存储1字符就够了。 美国人把他们用到的字符和字符对应的编码总结成了一张码表，这张码表叫做ASCII码表（也叫ASCII字符集）。</p>
<p>其实计算机只在美国用是没有问题的，但是计算机慢慢的普及到全世界，当普及到中国的时候，在计算机中想要存储中文，那ASCII字符集就不够用了，因为中文太多了，随便数一数也有几万个字符。</p>
<p>于是中国人为了在计算机中存储中文，也编了一个中国人用的字符集叫做GBK字符集，这里面包含2万多个汉字字符，<strong>GBK中一个汉字采用两个字节来存储</strong>，为了能够显示英文字母，GBK字符集也兼容了ASCII字符集，<strong>在GBK字符集中一个字母还是采用一个字节来存储</strong>。</p>
<h3 id="1-2-汉字和字母的编码特点">1.2 汉字和字母的编码特点</h3>
<p><strong>需要我们注意汉字和字母的编码特点：</strong></p>
<ul>
<li>
<ol>
<li>如果是存储字母，采用1个字节来存储，一共8位，其中第1位是0</li>
<li>如果是存储汉字，采用2个字节来存储，一共16位，其中第1位是1</li>
</ol>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/07/uBk8p32QRvJMqZ6.webp" alt="1667739473545"></p>
<p><strong>当读取文件中的字符时，通过识别读取到的第1位是0还是1来判断是字母还是汉字</strong></p>
<ul>
<li>如果读取到第1位是0，就认为是一个字母，此时往后读1个字节。</li>
<li>如果读取到第1位是1，就认为是一个汉字，此时往后读2个字节。</li>
</ul>
<h3 id="1-3-Unicode字符集">1.3 Unicode字符集</h3>
<p>为了解决各个国家字符集互不兼容的问题，由国际化标准组织牵头，设计了一套全世界通用的字符集，叫做Unicode字符集。在Unicode字符集中包含了世界上所有国家的文字，一个字符采用4个自己才存储。</p>
<p>在Unicode字符集中，采用一个字符4个字节的编码方案，又造成另一个问题：如果是说英语的国家，他们只需要用到26大小写字母，加上一些标点符号就够了，本身一个字节就可以表示完，用4个字节就有点浪费。</p>
<p>于是又对Unicode字符集中的字符进行了重新编码，一共设计了三种编码方案。分别是UTF-32、UTF-16、UTF-8;  <strong>其中比较常用的编码方案是UTF-8</strong></p>
<p>下面我们详细介绍一下UTF-8这种编码方案的特点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>UTF-<span class="number">8</span>是一种可变长的编码方案，工分为<span class="number">4</span>个长度区</span><br><span class="line"><span class="number">2.</span>英文字母、数字占<span class="number">1</span>个字节兼容(ASCII编码)</span><br><span class="line"><span class="number">3.</span>汉字字符占<span class="number">3</span>个字节</span><br><span class="line"><span class="number">4.</span>极少数字符占<span class="number">4</span>个字节</span><br></pre></td></tr></table></figure>
<h3 id="1-4-字符集小结">1.4 字符集小结</h3>
<p>最后，我们将前面介绍过的字符集小结一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ASCII字符集：《美国信息交换标准代码》，包含英文字母、数字、标点符号、控制字符</span><br><span class="line">	特点：<span class="number">1</span>个字符占<span class="number">1</span>个字节</span><br><span class="line"></span><br><span class="line">GBK字符集：中国人自己的字符集，兼容ASCII字符集，还包含<span class="number">2</span>万多个汉字</span><br><span class="line">	特点：<span class="number">1</span>个字母占用<span class="number">1</span>个字节；<span class="number">1</span>个汉字占用<span class="number">2</span>个字节</span><br><span class="line"></span><br><span class="line">Unicode字符集：包含世界上所有国家的文字，有三种编码方案，最常用的是UTF-<span class="number">8</span></span><br><span class="line">    UTF-<span class="number">8</span>编码方案：英文字母、数字占<span class="number">1</span>个字节兼容(ASCII编码)、汉字字符占<span class="number">3</span>个字节</span><br></pre></td></tr></table></figure>
<h3 id="1-5-编码和解码">1.5 编码和解码</h3>
<p>搞清楚字符集的知识之后，我们接下来再带着同学们使用Java代码完成编码和解码的操作。</p>
<p>其实String类类中就提供了相应的方法，可以完成编码和解码的操作。</p>
<ul>
<li>编码：把字符串按照指定的字符集转换为字节数组</li>
<li>解码：把字节数组按照指定的字符集转换为字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握如何使用Java代码完成对字符的编码和解码。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;a我b&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = data.getBytes(); <span class="comment">// 默认是按照平台字符集（UTF-8）进行编码的。</span></span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照指定字符集进行编码。</span></span><br><span class="line">        <span class="type">byte</span>[] bytes1 = data.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bytes1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、解码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes); <span class="comment">// 按照平台默认编码（UTF-8）解码</span></span><br><span class="line">        System.out.println(s1);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes1, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、IO流（字节流）">二、IO流（字节流）</h2>
<h3 id="2-1-IO流概述">2.1 IO流概述</h3>
<p>IO流的作用：就是可以对文件或者网络中的数据进行读、写的操作。如下图所示</p>
<ul>
<li>把数据从磁盘、网络中读取到程序中来，用到的是输入流。</li>
<li>把程序中的数据写入磁盘、网络中，用到的是输出流。</li>
<li><strong>简单记：输入流（读数据）、输出流（写数据）</strong></li>
</ul>
<p><img src="https://s2.loli.net/2024/05/07/GaHN96QArDvoZm5.webp" alt="1667822945208"></p>
<p>IO流在Java中有很多种，不同的流来干不同的事情。Java把各种流用不同的类来表示，这些流的继承体系如下图所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IO流分为两大派系：</span><br><span class="line">	<span class="number">1.</span>字节流：字节流又分为字节输入流、字节输出流</span><br><span class="line">	<span class="number">2.</span>字符流：字符流由分为字符输入流、字符输出流</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/05/07/cDMTgNSnyQjedqJ.webp" alt="1667823186345"></p>
<h3 id="2-2-FileInputStream读取一个字节">2.2 FileInputStream读取一个字节</h3>
<ul>
<li>字节流中的字节输入流，用InputStream来表示。但是InputStream是抽象类，我们用的是它的子类，叫FileInputStream。</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/07/oJmcZl1C6hdz3f4.webp" alt="1667823371395"></p>
<p>需要用到的方法如下图所示：有构造方法、成员方法</p>
<p><img src="https://s2.loli.net/2024/05/07/XV2RFcu5JGdhvCf.webp" alt="1667823417184"></p>
<p>使用FileInputStream读取文件中的字节数据，步骤如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一步：创建FileInputStream文件字节输入流管道，与源文件接通。</span><br><span class="line">第二步：调用read()方法开始读取文件的字节数据。</span><br><span class="line">第三步：调用close()方法释放资源</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握文件字节输入流，每次读取一个字节。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建文件字节输入流管道，与源文件接通。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>((<span class="string">&quot;file-io-app\\src\\itheima01.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开始读取文件的字节数据。</span></span><br><span class="line">        <span class="comment">// public int read():每次读取一个字节返回，如果没有数据了，返回-1.</span></span><br><span class="line">        <span class="type">int</span> b; <span class="comment">// 用于记住读取的字节。</span></span><br><span class="line">        <span class="keyword">while</span> ((b = is.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、流使用完毕之后，必须关闭！释放系统资源！</span></span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意一个问题：由于一个中文在UTF-8编码方案中是占3个字节，采用一次读取一个字节的方式，读一个字节就相当于读了1/3个汉字，此时将这个字节转换为字符，是会有乱码的。</p>
<h3 id="2-3-FileInputStream读取多个字节">2.3 FileInputStream读取多个字节</h3>
<p>为了提高效率，我们可以使用另一个read(byte[] bytes)的重载方法，可以一次读取多个字节，至于一次读多少个字节，就在于你传递的数组有多大。</p>
<p>使用FileInputStream一次读取多个字节的步骤如下</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">第一步：创建FileInputStream文件字节输入流管道，与源文件接通。</span></span><br><span class="line"><span class="string">第二步：调用read(byte[]</span> <span class="string">bytes)方法开始读取文件的字节数据。</span></span><br><span class="line"><span class="string">第三步：调用close()方法释放资源</span></span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握使用FileInputStream每次读取多个字节。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个字节输入流对象代表字节输入流管道与源文件接通。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app\\src\\itheima02.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开始读取文件中的字节数据：每次读取多个字节。</span></span><br><span class="line">        <span class="comment">//  public int read(byte b[]) throws IOException</span></span><br><span class="line">        <span class="comment">//  每次读取多个字节到字节数组中去，返回读取的字节数量，读取完毕会返回-1.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、使用循环改造。</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> len; <span class="comment">// 记住每次读取了多少个字节。  abc 66</span></span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 注意：读取多少，倒出多少。</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> , len);</span><br><span class="line">            System.out.print(rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 性能得到了明显的提升！！</span></span><br><span class="line">        <span class="comment">// 这种方案也不能避免读取汉字输出乱码的问题！！</span></span><br><span class="line"></span><br><span class="line">        is.close(); <span class="comment">// 关闭流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>需要我们注意的是：<strong>read(byte[] bytes)它的返回值，表示当前这一次读取的字节个数。</strong></li>
</ul>
<p>假设有一个a.txt文件如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcde</span><br></pre></td></tr></table></figure>
<p>每次读取过程如下</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">也就是说，并不是每次读取的时候都把数组装满，比如数组是</span> <span class="string">byte[]</span> <span class="string">bytes</span> <span class="string">=</span> <span class="string">new</span> <span class="string">byte[3];</span></span><br><span class="line"><span class="string">第一次调用read(bytes)读取了3个字节(分别是97,98,99)，并且往数组中存，此时返回值就是3</span></span><br><span class="line"><span class="string">第二次调用read(bytes)读取了2个字节(分别是99,100),并且往数组中存，此时返回值是2</span></span><br><span class="line"><span class="string">第三次调用read(bytes)文件中后面已经没有数据了，此时返回值为-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>还需要注意一个问题：采用一次读取多个字节的方式，也是可能有乱码的。因为也有可能读取到半个汉字的情况。</li>
</ul>
<h3 id="2-4-FileInputStream读取全部字节">2.4 FileInputStream读取全部字节</h3>
<p>我们可以一次性读取文件中的全部字节，然后把全部字节转换为一个字符串，就不会有乱码了。</p>
<p><img src="https://s2.loli.net/2024/05/07/DM7fY4mOuK1PapS.webp" alt="1667830119965"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、一次性读取完文件的全部字节到一个字节数组中去。</span></span><br><span class="line"><span class="comment">// 创建一个字节输入流管道与源文件接通</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app\\src\\itheima03.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、准备一个字节数组，大小与文件的大小正好一样大。</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app\\src\\itheima03.txt&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> f.length();</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) size];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(buffer);</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、关闭流</span></span><br><span class="line">is.close(); </span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/05/07/mkIGBU9wrZcd6jJ.webp" alt="1667830186936"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、一次性读取完文件的全部字节到一个字节数组中去。</span></span><br><span class="line"><span class="comment">// 创建一个字节输入流管道与源文件接通</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app\\src\\itheima03.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、调用方法读取所有字节，返回一个存储所有字节的字节数组。</span></span><br><span class="line"><span class="type">byte</span>[] buffer = is.readAllBytes();</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、关闭流</span></span><br><span class="line">is.close(); </span><br></pre></td></tr></table></figure>
<p>最后，还是要注意一个问题：<strong>一次读取所有字节虽然可以解决乱码问题，但是文件不能过大，如果文件过大，可能导致内存溢出。</strong></p>
<h3 id="2-5-FileOutputStream写字节">2.5 FileOutputStream写字节</h3>
<p>往文件中写数据需要用到OutputStream下面的一个子类FileOutputStream。写输入的流程如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/07/3cSlyoxePHAhLWu.webp" alt="1667830581838"></p>
<p>使用FileOutputStream往文件中写数据的步骤如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一步：创建FileOutputStream文件字节输出流管道，与目标文件接通。</span><br><span class="line">第二步：调用wirte()方法往文件中写数据</span><br><span class="line">第三步：调用close()方法释放资源</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握文件字节输出流FileOutputStream的使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个字节输出流管道与目标文件接通。</span></span><br><span class="line">        <span class="comment">// 覆盖管道：覆盖之前的数据</span></span><br><span class="line"><span class="comment">//        OutputStream os =</span></span><br><span class="line"><span class="comment">//                new FileOutputStream(&quot;file-io-app/src/itheima04out.txt&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 追加数据的管道</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app/src/itheima04out.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开始写字节数据出去了</span></span><br><span class="line">        os.write(<span class="number">97</span>); <span class="comment">// 97就是一个字节，代表a</span></span><br><span class="line">        os.write(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// &#x27;b&#x27;也是一个字节</span></span><br><span class="line">        <span class="comment">// os.write(&#x27;磊&#x27;); // [ooo] 默认只能写出去一个字节</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="string">&quot;我爱你中国abc&quot;</span>.getBytes();</span><br><span class="line">        os.write(bytes);</span><br><span class="line"></span><br><span class="line">        os.write(bytes, <span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 换行符</span></span><br><span class="line">        os.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        os.close(); <span class="comment">// 关闭流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-字节流复制文件">2.6 字节流复制文件</h3>
<p>比如：我们要复制一张图片，从磁盘<code>D:/resource/meinv.webp</code>的一个位置，复制到<code>C:/data/meinv.webp</code>位置。</p>
<p>复制文件的思路如下图所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>需要创建一个FileInputStream流与源文件接通，创建FileOutputStream与目标文件接通</span><br><span class="line"><span class="number">2.</span>然后创建一个数组，使用FileInputStream每次读取一个字节数组的数据，存如数组中</span><br><span class="line"><span class="number">3.</span>然后再使用FileOutputStream把字节数组中的有效元素，写入到目标文件中</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：使用字节流完成对文件的复制操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyTest5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 需求：复制照片。</span></span><br><span class="line">        <span class="comment">// 1、创建一个字节输入流管道与源文件接通</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/resource/meinv.webp&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、创建一个字节输出流管道与目标文件接通。</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:/data/meinv.webp&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="number">10</span> / <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 3、创建一个字节数组，负责转移字节数据。</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 1KB.</span></span><br><span class="line">        <span class="comment">// 4、从字节输入流中读取字节数据，写出去到字节输出流中。读多少写出去多少。</span></span><br><span class="line">        <span class="type">int</span> len; <span class="comment">// 记住每次读取了多少个字节。</span></span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        os.close();</span><br><span class="line">        is.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;复制完成！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、IO流资源释放">三、IO流资源释放</h2>
<p><img src="https://s2.loli.net/2024/05/07/FU9BuQrDZ56zMWb.webp" alt="1667831281147"></p>
<p>我们现在知道这个问题了，那这个问题怎么解决呢？ 在JDK7以前，和JDK7以后分别给出了不同的处理方案。</p>
<h3 id="3-1-JDK7以前的资源释放">3.1 JDK7以前的资源释放</h3>
<p>在JDK7版本以前，我们可以使用try…catch…finally语句来处理。格式如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//有可能产生异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类 e)&#123;</span><br><span class="line">    <span class="comment">//处理异常的代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//释放资源的代码</span></span><br><span class="line">    <span class="comment">//finally里面的代码有一个特点，不管异常是否发生，finally里面的代码都会执行。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改造上面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="number">10</span> / <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 1、创建一个字节输入流管道与源文件接通</span></span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app\\src\\itheima03.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 2、创建一个字节输出流管道与目标文件接通。</span></span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app\\src\\itheima03copy.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="number">10</span> / <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、创建一个字节数组，负责转移字节数据。</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 1KB.</span></span><br><span class="line">            <span class="comment">// 4、从字节输入流中读取字节数据，写出去到字节输出流中。读多少写出去多少。</span></span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记住每次读取了多少个字节。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成！！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放资源的操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(os != <span class="literal">null</span>) os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(is != <span class="literal">null</span>) is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码写到这里，有很多同学就已经看不下去了。是的，我也看不下去，本来几行代码就写完了的，加上try…catch…finally之后代码多了十几行，而且阅读性并不高。难受…</p>
<h3 id="3-2-JDK7以后的资源释放">3.2 JDK7以后的资源释放</h3>
<p>try…catch…finally处理异常，并释放资源代码比较繁琐。</p>
<p>Java在JDK7版本为我们提供了一种简化的释放资源的操作，它会自动释放资源。代码写起来也相当简单。</p>
<p>格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(资源对象<span class="number">1</span>; 资源对象<span class="number">2</span>;)&#123;</span><br><span class="line">    使用资源的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类 e)&#123;</span><br><span class="line">    处理异常的代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：注意到没有，这里没有释放资源的代码。它会自动是否资源</span></span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握释放资源的方式：try-with-resource</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">    	<span class="keyword">try</span> (</span><br><span class="line">          <span class="comment">// 1、创建一个字节输入流管道与源文件接通</span></span><br><span class="line">          <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/resource/meinv.webp&quot;</span>);</span><br><span class="line">          <span class="comment">// 2、创建一个字节输出流管道与目标文件接通。</span></span><br><span class="line">          <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:/data/meinv.webp&quot;</span>);</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="comment">// 3、创建一个字节数组，负责转移字节数据。</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 1KB.</span></span><br><span class="line">            <span class="comment">// 4、从字节输入流中读取字节数据，写出去到字节输出流中。读多少写出去多少。</span></span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记住每次读取了多少个字节。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(conn);</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="IO流（二）">IO流（二）</h1>
<h2 id="一、字符流">一、字符流</h2>
<h3 id="1-1-FileReader类">1.1 FileReader类</h3>
<p>先类学习字符流中的FileReader类，这是字符输入流，用来将文件中的字符数据读取到程序中来。</p>
<p><img src="https://s2.loli.net/2024/05/07/jyE6a7nLIUCsQzZ.webp" alt="1667914646397"></p>
<p>FileReader读取文件的步骤如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一步：创建FileReader对象与要读取的源文件接通</span><br><span class="line">第二步：调用read()方法读取文件中的字符</span><br><span class="line">第三步：调用close()方法关闭流</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/05/07/AxPzIenOg6oiFfq.webp" alt="1667914727332"></p>
<p>需要用到的方法：先通过构造器创建对象，再通过read方法读取数据（<strong>注意：两个read方法的返回值，含义不一样</strong>）</p>
<p><img src="https://s2.loli.net/2024/05/07/O7nAmJ3tRg6zkrx.webp" alt="1667915012716"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握文件字符输入流。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建一个文件字符输入流管道与源文件接通</span></span><br><span class="line">                <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;io-app2\\src\\itheima01.txt&quot;</span>);</span><br><span class="line">                )&#123;</span><br><span class="line">            <span class="comment">// 2、一个字符一个字符的读（性能较差）</span></span><br><span class="line"><span class="comment">//            int c; // 记住每次读取的字符编号。</span></span><br><span class="line"><span class="comment">//            while ((c = fr.read()) != -1)&#123;</span></span><br><span class="line"><span class="comment">//                System.out.print((char) c);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">// 每次读取一个字符的形式，性能肯定是比较差的。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、每次读取多个字符。（性能是比较不错的！）</span></span><br><span class="line">            <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">3</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记住每次读取了多少个字符。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = fr.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 读取多少倒出多少</span></span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-FileWriter类">1.2 FileWriter类</h3>
<p>FileWriter，它可以将程序中的字符数据写入文件。</p>
<p><img src="https://s2.loli.net/2024/05/07/yef6XMdnjQ79Pba.webp" alt="1667915174777"></p>
<p>FileWriter往文件中写字符数据的步骤如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一步：创建FileWirter对象与要读取的目标文件接通</span><br><span class="line">第二步：调用write(字符数据/字符数组/字符串)方法读取文件中的字符</span><br><span class="line">第三步：调用close()方法关闭流</span><br></pre></td></tr></table></figure>
<p>需要用到的方法如下：构造器是用来创建FileWriter对象的，有了对象才能调用write方法写数据到文件。</p>
<p><img src="https://s2.loli.net/2024/05/07/trAjlSsJ91w2x8f.webp" alt="1667915265102"></p>
<p>接下来，用代码演示一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握文件字符输出流：写字符数据出去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriterTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 0、创建一个文件字符输出流管道与目标文件接通。</span></span><br><span class="line">                <span class="comment">// 覆盖管道</span></span><br><span class="line">                <span class="comment">// Writer fw = new FileWriter(&quot;io-app2/src/itheima02out.txt&quot;);</span></span><br><span class="line">                <span class="comment">// 追加数据的管道</span></span><br><span class="line">                <span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;io-app2/src/itheima02out.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                )&#123;</span><br><span class="line">            <span class="comment">// 1、public void write(int c):写一个字符出去</span></span><br><span class="line">            fw.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            fw.write(<span class="number">97</span>);</span><br><span class="line">            <span class="comment">//fw.write(&#x27;磊&#x27;); // 写一个字符出去</span></span><br><span class="line">            fw.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、public void write(String c)写一个字符串出去</span></span><br><span class="line">            fw.write(<span class="string">&quot;我爱你中国abc&quot;</span>);</span><br><span class="line">            fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、public void write(String c ,int pos ,int len):写字符串的一部分出去</span></span><br><span class="line">            fw.write(<span class="string">&quot;我爱你中国abc&quot;</span>, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">            fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、public void write(char[] buffer):写一个字符数组出去</span></span><br><span class="line">            <span class="type">char</span>[] buffer = &#123;<span class="string">&#x27;黑&#x27;</span>, <span class="string">&#x27;马&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">            fw.write(buffer);</span><br><span class="line">            fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5、public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去</span></span><br><span class="line">            fw.write(buffer, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">            fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-FileWriter写的注意事项">1.3 FileWriter写的注意事项</h3>
<p><strong>FileWriter写完数据之后，必须刷新或者关闭，写出去的数据才能生效。</strong></p>
<p>比如：下面的代码只调用了写数据的方法，没有关流的方法。当你打开目标文件时，是看不到任何数据的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建FileWriter对象</span></span><br><span class="line"><span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;io-app2/src/itheima03out.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.写字符数据出去</span></span><br><span class="line">fw.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">fw.write(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">fw.write(<span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>而下面的代码，加上了flush()方法之后，数据就会立即到目标文件中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建FileWriter对象</span></span><br><span class="line"><span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;io-app2/src/itheima03out.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.写字符数据出去</span></span><br><span class="line">fw.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">fw.write(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">fw.write(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.刷新</span></span><br><span class="line">fw.flush(); </span><br></pre></td></tr></table></figure>
<p>下面的代码，调用了close()方法，数据也会立即到文件中去。因为close()方法在关闭流之前，会将内存中缓存的数据先刷新到文件，再关流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建FileWriter对象</span></span><br><span class="line"><span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;io-app2/src/itheima03out.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.写字符数据出去</span></span><br><span class="line">fw.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">fw.write(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">fw.write(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.关闭流</span></span><br><span class="line">fw.close(); <span class="comment">//会先刷新，再关流</span></span><br></pre></td></tr></table></figure>
<p>但是需要注意的是，关闭流之后，就不能在对流进行操作了。否则会出异常</p>
<p><img src="https://s2.loli.net/2024/05/07/k8EzSBYO4tIwvMU.webp" alt="1667915749299"></p>
<h2 id="二、缓冲流">二、缓冲流</h2>
<p>缓冲流有四种，如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/07/nRrBjIxMG5OF7Qs.webp" alt="1667915902693"></p>
<p><strong>缓冲流的作用</strong>：可以对原始流进行包装，提高原始流读写数据的性能。</p>
<h3 id="2-1-缓冲字节流">2.1 缓冲字节流</h3>
<p>我们先来学习字节缓冲流是如何提高读写数据的性能的，原理如下图所示。是因为在缓冲流的底层自己封装了一个长度为8KB（8129byte）的字节数组，但是缓冲流不能单独使用，它需要依赖于原始流。</p>
<ul>
<li>**读数据时：**它先用原始字节输入流一次性读取8KB的数据存入缓冲流内部的数组中（ps: 先一次多囤点货），再从8KB的字节数组中读取一个字节或者多个字节（把消耗屯的货）。</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/07/X4suCM7EJdr1q2z.webp" alt="1667916051946"></p>
<ul>
<li><strong>写数据时：</strong> 它是先把数据写到缓冲流内部的8BK的数组中（ps: 先攒一车货），等数组存满了，再通过原始的字节输出流，一次性写到目标文件中去（把囤好的货，一次性运走）。</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/07/obJhs2FiTwPHEal.webp" alt="1667916766340"></p>
<p>在创建缓冲字节流对象时，需要封装一个原始流对象进来。构造方法如下</p>
<p><img src="https://s2.loli.net/2024/05/07/oyhLBFA5kWE4pHJ.webp" alt="1667916924862"></p>
<p>如果我们用缓冲流复制文件，代码写法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedInputStreamTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;io-app2/src/itheima01.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// 1、定义一个字节缓冲输入流包装原始的字节输入流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(is);</span><br><span class="line"></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;io-app2/src/itheima01_bak.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// 2、定义一个字节缓冲输出流包装原始的字节输出流</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(os);</span><br><span class="line">        )&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                bos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-字符缓冲流">2.2 字符缓冲流</h3>
<p>接下来，我们学习另外两个缓冲流——字符缓冲流。它的原理和字节缓冲流是类似的，它底层也会有一个8KB的数组，但是这里是字符数组。字符缓冲流也不能单独使用，它需要依赖于原始字符流一起使用。</p>
<p><img src="https://s2.loli.net/2024/05/07/E6pVN2gIYHDBJQs.webp" alt="1667918228776"></p>
<ul>
<li>**BufferedReader读数据时：**它先原始字符输入流一次性读取8KB的数据存入缓冲流内部的数组中（ps: 先一次多囤点货），再从8KB的字符数组中读取一个字符或者多个字符（把消耗屯的货）。</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/07/yeULN16hv2tKgq5.webp" alt="1667918633907"></p>
<p>创建BufferedReader对象需要用到BufferedReader的构造方法，内部需要封装一个原始的字符输入流，我们可以传入FileReader.</p>
<p><img src="https://s2.loli.net/2024/05/07/ZnaiA8lPXKjs9MB.webp" alt="1667919020690"></p>
<p>而且BufferedReader还要特有的方法，一次可以读取文本文件中的一行</p>
<p><img src="https://s2.loli.net/2024/05/07/M6nwCkoDGrvE5y2.webp" alt="1667919061356"></p>
<p>使用BufferedReader读取数据的代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReaderTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;io-app2\\src\\itheima04.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// 创建一个字符缓冲输入流包装原始的字符输入流</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr);</span><br><span class="line">        )&#123;</span><br><span class="line"><span class="comment">//            char[] buffer = new char[3];</span></span><br><span class="line"><span class="comment">//            int len;</span></span><br><span class="line"><span class="comment">//            while ((len = br.read(buffer)) != -1)&#123;</span></span><br><span class="line"><span class="comment">//                System.out.print(new String(buffer, 0, len));</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            System.out.println(br.readLine());</span></span><br><span class="line"><span class="comment">//            System.out.println(br.readLine());</span></span><br><span class="line"><span class="comment">//            System.out.println(br.readLine());</span></span><br><span class="line"><span class="comment">//            System.out.println(br.readLine());</span></span><br><span class="line"></span><br><span class="line">            String line; <span class="comment">// 记住每次读取的一行数据</span></span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>BufferedWriter写数据时：</strong> 它是先把数据写到字符缓冲流内部的8BK的数组中（ps: 先攒一车货），等数组存满了，再通过原始的字符输出流，一次性写到目标文件中去（把囤好的货，一次性运走）。如下图所示</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/07/BspVdgaEOiZf8yM.webp" alt="1667918775445"></p>
<p>创建BufferedWriter对象时需要用到BufferedWriter的构造方法，而且内部需要封装一个原始的字符输出流，我们这里可以传递FileWriter。</p>
<p><img src="https://s2.loli.net/2024/05/07/zcOTExLMVYUwoft.webp" alt="1667919195054"></p>
<p>而且BufferedWriter新增了一个功能，可以用来写一个换行符</p>
<p><img src="https://s2.loli.net/2024/05/07/bXfM5CJRvksAeHZ.webp" alt="1667919243053"></p>
<p>接下来，用代码演示一下，使用BufferedWriter往文件中写入字符数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedWriterTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;io-app2/src/itheima05out.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 创建一个字符缓冲输出流管道包装原始的字符输出流</span></span><br><span class="line">                <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line">        )&#123;</span><br><span class="line"></span><br><span class="line">            bw.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            bw.write(<span class="number">97</span>);</span><br><span class="line">            bw.write(<span class="string">&#x27;磊&#x27;</span>);</span><br><span class="line">            bw.newLine();</span><br><span class="line"></span><br><span class="line">            bw.write(<span class="string">&quot;我爱你中国abc&quot;</span>);</span><br><span class="line">            bw.newLine();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-缓冲流性能分析">2.3 缓冲流性能分析</h3>
<p>我们说缓冲流内部多了一个数组，可以提高原始流的读写性能。讲到这一定有同学有这么一个疑问，它和我们使用原始流，自己加一个8BK数组不是一样的吗？ 缓冲流就一定能提高性能吗？先告诉同学们答案，<strong>缓冲流不一定能提高性能</strong>。</p>
<blockquote>
<p>下面我们用一个比较大文件（889MB）复制，做性能测试，分别使用下面四种方式来完成文件复制，并记录文件复制的时间。</p>
</blockquote>
<p>① 使用低级流一个字节一个字节的复制</p>
<p>② 使用低级流按照字节数组的形式复制</p>
<p>③ 使用缓冲流一个字节一个字节的复制</p>
<p>④ 使用缓冲流按照字节数组的形式复制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">低级流一个字节复制: 慢得简直让人无法忍受</span><br><span class="line">低级流按照字节数组复制(数组长度<span class="number">1024</span>): <span class="number">12.</span>117s</span><br><span class="line">缓冲流一个字节复制: <span class="number">11.</span>058s</span><br><span class="line">缓冲流按照字节数组复制(数组长度<span class="number">1024</span>): <span class="number">2.</span>163s</span><br><span class="line">【注意：这里的测试只能做一个参考，和电脑性能也有直接关系】</span><br></pre></td></tr></table></figure>
<p>经过上面的测试，我们可以得出一个结论：<strong>默认情况下，采用一次复制1024个字节，缓冲流完胜。</strong></p>
<blockquote>
<p>但是，缓冲流就一定性能高吗？我们采用一次复制8192个字节试试</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">低级流按照字节数组复制(数组长度<span class="number">8192</span>): <span class="number">2.</span>535s</span><br><span class="line">缓冲流按照字节数组复制(数组长度<span class="number">8192</span>): <span class="number">2.</span>088s</span><br></pre></td></tr></table></figure>
<p>经过上面的测试，我们可以得出一个结论：**一次读取8192个字节时，低级流和缓冲流性能相当。**相差的那几毫秒可以忽略不计。</p>
<blockquote>
<p>继续把数组变大，看一看缓冲流就一定性能高吗？现在采用一次读取1024*32个字节数据试试</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">低级流按照字节数组复制(数组长度<span class="number">8192</span>): <span class="number">1.</span>128s</span><br><span class="line">缓冲流按照字节数组复制(数组长度<span class="number">8192</span>): <span class="number">1.</span>133s</span><br></pre></td></tr></table></figure>
<p>经过上面的测试，我们可以得出一个结论：**数组越大性能越高，低级流和缓冲流性能相当。**相差的那几秒可以忽略不计。</p>
<blockquote>
<p>继续把数组变大，看一看缓冲流就一定性能高吗？现在采用一次读取1024*6个字节数据试试</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">低级流按照字节数组复制(数组长度<span class="number">8192</span>): <span class="number">1.</span>039s</span><br><span class="line">缓冲流按照字节数组复制(数组长度<span class="number">8192</span>): <span class="number">1.</span>151s</span><br></pre></td></tr></table></figure>
<p>此时你会发现，当数组大到一定程度，性能已经提高了多少了，甚至缓冲流的性能还没有低级流高。</p>
<p>最终总结一下：**缓冲流的性能不一定比低级流高，其实低级流自己加一个数组，性能其实是不差。**只不过缓冲流帮你加了一个相对而言大小比较合理的数组 。</p>
<h2 id="三、转换流">三、转换流</h2>
<p>前面我们学习过FileReader读取文件中的字符，但是同学们注意了，FileReader默认只能读取UTF-8编码格式的文件。如果使用FileReader读取GBK格式的文件，可能存在乱码，因为FileReader它遇到汉字默认是按照3个字节来读取的，而GBK格式的文件一个汉字是占2个字节，这样就会导致乱码。</p>
<p>Java给我们提供了另外两种流InputStreamReader，OutputStreamWriter，这两个流我们把它叫做转换流。它们可以将字节流转换为字符流，并且可以指定编码方案。</p>
<h3 id="3-1-InputStreamReader类">3.1 InputStreamReader类</h3>
<p>接下来，我们先学习InputStreamReader类，你看这个类名就比较有意思，前面是InputStream表示字节输入流，后面是Reader表示字符输入流，合在一起意思就是表示可以把InputStream转换为Reader，最终InputStreamReader其实也是Reader的子类，所以也算是字符输入流。</p>
<p>InputStreamReader也是不能单独使用的，它内部需要封装一个InputStream的子类对象，再指定一个编码表，如果不指定编码表，默认会按照UTF-8形式进行转换。</p>
<blockquote>
<p>需求：我们可以先准备一个GBK格式的文件，然后使用下面的代码进行读取，看是是否有乱码。</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/05/07/wJgCGFVcYktnSOL.webp" alt="1667922646132"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReaderTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、得到文件的原始字节流（GBK的字节流形式）</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;io-app2/src/itheima06.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// 2、把原始的字节输入流按照指定的字符集编码转换成字符输入流</span></span><br><span class="line">                <span class="type">Reader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">                <span class="comment">// 3、把字符输入流包装成缓冲字符输入流</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">                )&#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完之后，你会发现没有乱码。</p>
<h3 id="3-2-OutputStreamWriter类">3.2 OutputStreamWriter类</h3>
<p>接下来，我们先学习OutputStreamWriter类，你看这个类名也比较有意思，前面是OutputStream表示字节输出流，后面是Writer表示字符输出流，合在一起意思就是表示可以把OutputStream转换为Writer，最终OutputStreamWriter其实也是Writer的子类，所以也算是字符输出流。</p>
<p>OutputStreamReader也是不能单独使用的，它内部需要封装一个OutputStream的子类对象，再指定一个编码表，如果不指定编码表，默认会按照UTF-8形式进行转换。</p>
<blockquote>
<p>需求：我们可以先准备一个GBK格式的文件，使用下面代码往文件中写字符数据。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriterTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 指定写出去的字符编码。</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建一个文件字节输出流</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;io-app2/src/itheima07out.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// 2、把原始的字节输出流，按照指定的字符集编码转换成字符输出转换流。</span></span><br><span class="line">                <span class="type">Writer</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(os, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">                <span class="comment">// 3、把字符输出流包装成缓冲字符输出流</span></span><br><span class="line">                <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br><span class="line">                )&#123;</span><br><span class="line">            bw.write(<span class="string">&quot;我是中国人abc&quot;</span>);</span><br><span class="line">            bw.write(<span class="string">&quot;我爱你中国123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、打印流">四、打印流</h2>
<h3 id="4-1-打印流基本使用">4.1 打印流基本使用</h3>
<p>打印流，这里所说的打印其实就是写数据的意思，它和普通的write方法写数据还不太一样，一般会使用打印流特有的方法叫<code>print(数据)</code>或者<code>println(数据)</code>，它打印啥就输出啥。</p>
<p>打印流有两个，一个是字节打印流PrintStream，一个是字符打印流PrintWriter，如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/07/K3DQ8OsYCAM7num.webp" alt="1667923225787"></p>
<p><strong>PrintStream和PrintWriter的用法是一样的，所以这里就一块演示了。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建一个打印流管道</span></span><br><span class="line"><span class="comment">//                PrintStream ps =</span></span><br><span class="line"><span class="comment">//                        new PrintStream(&quot;io-app2/src/itheima08.txt&quot;, Charset.forName(&quot;GBK&quot;));</span></span><br><span class="line"><span class="comment">//                PrintStream ps =</span></span><br><span class="line"><span class="comment">//                        new PrintStream(&quot;io-app2/src/itheima08.txt&quot;);</span></span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">ps</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;io-app2/src/itheima08.txt&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">                )&#123;</span><br><span class="line">                ps.print(<span class="number">97</span>);	<span class="comment">//文件中显示的就是:97</span></span><br><span class="line">                ps.print(<span class="string">&#x27;a&#x27;</span>); <span class="comment">//文件中显示的就是:a</span></span><br><span class="line">                ps.println(<span class="string">&quot;我爱你中国abc&quot;</span>);	<span class="comment">//文件中显示的就是:我爱你中国abc</span></span><br><span class="line">                ps.println(<span class="literal">true</span>);<span class="comment">//文件中显示的就是:true</span></span><br><span class="line">                ps.println(<span class="number">99.5</span>);<span class="comment">//文件中显示的就是99.5</span></span><br><span class="line"></span><br><span class="line">                ps.write(<span class="number">97</span>); <span class="comment">//文件中显示a，发现和前面println方法的区别了吗？</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-重定向输出语句">4.2 重定向输出语句</h3>
<p><code>System.out.println()</code>这句话表示打印输出，但是至于为什么能够输出，其实我们一直不清楚。</p>
<p>以前是因为知识储备还不够，无法解释，到现在就可以给同学们揭晓谜底了，因为System里面有一个静态变量叫out，out的数据类型就是PrintStream，它就是一个打印流，而且这个打印流的默认输出目的地是控制台，所以我们调用<code>System.out.pirnln()</code>就可以往控制台打印输出任意类型的数据，而且打印啥就输出啥。</p>
<p>而且System还提供了一个方法，可以修改底层的打印流，这样我们就可以重定向打印语句的输出目的地了。我们玩一下, 直接上代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老骥伏枥&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;志在千里&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> ( <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;io-app2/src/itheima09.txt&quot;</span>); )&#123;</span><br><span class="line">            <span class="comment">// 把系统默认的打印流对象改成自己设置的打印流</span></span><br><span class="line">            System.setOut(ps);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;烈士暮年&quot;</span>);	</span><br><span class="line">            System.out.println(<span class="string">&quot;壮心不已&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时打印语句，将往文件中打印数据，而不在控制台。</p>
<h2 id="五、数据流">五、数据流</h2>
<p>比如，我们想把数据和数据的类型一并写到文件中去，读取的时候也将数据和数据类型一并读出来。这就可以用到数据流，有两个DataInputStream和DataOutputStream.</p>
<p><img src="https://s2.loli.net/2024/05/07/enZoO4t91RrU3Sj.webp" alt="1667924066920"></p>
<h3 id="5-1-DataOutputStream类">5.1 DataOutputStream类</h3>
<p>我们先学习DataOutputStream类，它也是一种包装流，创建DataOutputStream对象时，底层需要依赖于一个原始的OutputStream流对象。然后调用它的wirteXxx方法，写的是特定类型的数据。</p>
<p><img src="https://s2.loli.net/2024/05/07/eh4UBuaj9CrTSZg.webp" alt="1667924147403"></p>
<p>代码如下：往文件中写整数、小数、布尔类型数据、字符串数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataOutputStreamTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建一个数据输出流包装低级的字节输出流</span></span><br><span class="line">                <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;io-app2/src/itheima10out.txt&quot;</span>));</span><br><span class="line">                )&#123;</span><br><span class="line">            dos.writeInt(<span class="number">97</span>);</span><br><span class="line">            dos.writeDouble(<span class="number">99.5</span>);</span><br><span class="line">            dos.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">            dos.writeUTF(<span class="string">&quot;黑马程序员666！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-DataInputStream类">5.2 DataInputStream类</h3>
<p>学习完DataOutputStream后，再学习DataIntputStream类，它也是一种包装流，创建DataInputStream对象时，底层需要依赖于一个原始的InputStream流对象。然后调用它的readXxx()方法就可以读取特定类型的数据。</p>
<p><img src="https://s2.loli.net/2024/05/07/XavCIoz5YrlubmA.webp" alt="1667924375953"></p>
<p>代码如下：读取文件中特定类型的数据（整数、小数、字符串等）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataInputStreamTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;io-app2/src/itheima10out.txt&quot;</span>));</span><br><span class="line">                )&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">            System.out.println(i);</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> dis.readDouble();</span><br><span class="line">            System.out.println(d);</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line">            System.out.println(b);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">            System.out.println(rs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、序列化流">六、序列化流</h2>
<p>各位同学同学，还有最后一个流要学习，叫做序列化流。序列化流是干什么用的呢？ 我们知道字节流是以字节为单位来读写数据、字符流是按照字符为单位来读写数据、而对象流是以对象为单位来读写数据。也就是把对象当做一个整体，可以写一个对象到文件，也可以从文件中把对象读取出来。</p>
<p><img src="https://s2.loli.net/2024/05/07/VkCLycofADuJptm.webp" alt="1667924794181"></p>
<p>这里有一个新词 序列化，第一次听同学们可能还比较陌生，我来给同学们解释一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">序列化：意思就是把对象写到文件或者网络中去。（简单记：写对象）</span><br><span class="line">反序列化：意思就是把对象从文件或者网络中读取出来。（简单记：读对象）</span><br></pre></td></tr></table></figure>
<h3 id="6-1-ObjectOutputStraem类">6.1 ObjectOutputStraem类</h3>
<p>接下来，先学习ObjectOutputStream流，它也是一个包装流，不能单独使用，需要结合原始的字节输出流使用。</p>
<p>代码如下：将一个User对象写到文件中去</p>
<ul>
<li>第一步：先准备一个User类，必须让其实现Serializable接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：对象如果需要序列化，必须实现序列化接口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String loginName;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// transient 这个成员变量将不参与序列化。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String passWord;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String loginName, String userName, <span class="type">int</span> age, String passWord)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loginName = loginName;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.passWord = passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;loginName=&#x27;&quot;</span> + loginName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, userName=&#x27;&quot;</span> + userName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, passWord=&#x27;&quot;</span> + passWord + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二步：再创建ObjectOutputStream流对象，调用writeObject方法对象到文件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1ObjectOutputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 2、创建一个对象字节输出流包装原始的字节 输出流。</span></span><br><span class="line">                <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;io-app2/src/itheima11out.txt&quot;</span>));</span><br><span class="line">                )&#123;</span><br><span class="line">            <span class="comment">// 1、创建一个Java对象。</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">32</span>, <span class="string">&quot;666888xyz&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、序列化对象到文件中去</span></span><br><span class="line">            oos.writeObject(u);</span><br><span class="line">            System.out.println(<span class="string">&quot;序列化对象成功！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：写到文件中的对象，是不能用记事本打开看的。因为对象本身就不是文本数据，打开是乱码</strong></p>
<p><img src="https://s2.loli.net/2024/05/07/bRkKA1SP8YNvwMV.webp" alt="1667925212261"></p>
<p>怎样才能读懂文件中的对象是什么呢？这里必须用反序列化，自己写代码读。</p>
<h3 id="6-2-ObjectInputStream类">6.2 ObjectInputStream类</h3>
<p>接下来，学习ObjectInputStream流，它也是一个包装流，不能单独使用，需要结合原始的字节输入流使用。</p>
<p>接着前面的案例，文件中已经有一个Student对象，现在要使用ObjectInputStream读取出来。称之为反序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2ObjectInputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="comment">// 1、创建一个对象字节输入流管道，包装 低级的字节输入流与源文件接通</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;io-app2/src/itheima11out.txt&quot;</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User) ois.readObject();</span><br><span class="line">            System.out.println(u);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七、补充知识：IO框架">七、补充知识：IO框架</h2>
<p>我们只学习了IO流对文件复制，能不能复制文件夹呀？</p>
<p>当然是可以咯，但是如果让我们自己写复制文件夹的代码需要用到递归，还是比较麻烦的。为了简化对IO操作，<strong>由apache开源基金组织提供了一组有关IO流小框架，可以提高IO流的开发效率。</strong></p>
<p>这个框架的名字叫commons-io：其本质是别人写好的一些字节码文件（class文件），打包成了一个jar包。我们只需要把jar包引入到我们的项目中，就可以直接用了。</p>
<p>这里给同学们介绍一个jar包中提供的工具类叫FileUtils，它的部分功能如下，很方便，你一看名字就知道怎么用了。</p>
<p><img src="https://s2.loli.net/2024/05/07/JvBcyRGVIEzTN8s.webp" alt="1667925627850"></p>
<p>在写代码之前，先需要引入jar包，具体步骤如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>在模块的目录下，新建一个lib文件夹</span><br><span class="line"><span class="number">2.</span>把jar包复制粘贴到lib文件夹下</span><br><span class="line"><span class="number">3.</span>选择lib下的jar包，右键点击Add As Library，然后就可以用了。</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsIOTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.复制文件</span></span><br><span class="line">        FileUtils.copyFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;io-app2\\src\\itheima01.txt&quot;</span>), <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;io-app2/src/a.txt&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.复制文件夹</span></span><br><span class="line">        FileUtils.copyDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\resource\\私人珍藏&quot;</span>), <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\resource\\私人珍藏3&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.删除文件夹</span></span><br><span class="line">        FileUtils.deleteDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\resource\\私人珍藏3&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java提供的原生的一行代码搞定很多事情</span></span><br><span class="line">         Files.copy(Path.of(<span class="string">&quot;io-app2\\src\\itheima01.txt&quot;</span>), Path.of(<span class="string">&quot;io-app2\\src\\b.txt&quot;</span>));</span><br><span class="line">        System.out.println(Files.readString(Path.of(<span class="string">&quot;io-app2\\src\\itheima01.txt&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="特殊文件、日志技术">特殊文件、日志技术</h1>
<h2 id="一、属性文件">一、属性文件</h2>
<h3 id="1-1-特殊文件概述">1.1 特殊文件概述</h3>
<p>在以后的Java开发过程中还会遇到一些特殊的文本文件，这些文件是有一些格式要求的，方便程序对文件中的数据进行处理。</p>
<p>比如，后面我们会用到两种特殊的文本文件，一种是properties文件，还有一种是xml文件。如下图所示。</p>
<p><img src="https://s2.loli.net/2024/05/07/t4cZ26droAjU7qK.webp" alt="1667991153379"></p>
<ul>
<li>后缀为.properties的文件，称之为属性文件，它可以很方便的存储一些类似于键值对的数据。经常当做软件的配置文件使用。</li>
<li>而xml文件能够表示更加复杂的数据关系，比如要表示多个用户的用户名、密码、家乡、性别等。在后面，也经常当做软件的配置文件使用。</li>
</ul>
<h3 id="1-2-Properties属性文件">1.2 Properties属性文件</h3>
<p>接下来，我们先学习Properties这种属性文件。首先我们要掌握属性文件的格式：</p>
<ol>
<li>属性文件后缀以<code>.properties</code>结尾</li>
<li>属性文件里面的每一行都是一个键值对，键和值中间用=隔开。比如: <code>admin=123456</code></li>
<li><code>#</code>表示这样是注释信息，是用来解释这一行配置是什么意思。</li>
<li>每一行末尾不要习惯性加分号，以及空格等字符；不然会把分号，空格会当做值的一部分。</li>
<li>键不能重复，值可以重复</li>
</ol>
<p>如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/07/QAw8X6Crfzl9Knm.webp" alt="1667992083258"></p>
<p>接下来，我们学习如何读取属性文件中的数据。这里需要给同学们，介绍一个来叫Properties.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>Properties是什么？</span><br><span class="line">	Properties是Map接口下面的一个实现类，所以Properties也是一种双列集合，用来存储键值对。	  但是一般不会把它当做集合来使用。</span><br><span class="line">	</span><br><span class="line"><span class="number">2.</span>Properties核心作用？</span><br><span class="line">	Properties类的对象，用来表示属性文件，可以用来读取属性文件中的键值对。</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>使用Properties读取属性文件中的键值对</strong>，需要用到的方法如下。</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/07/UhsPaRgKLT7Nxtw.webp" alt="1667992486134"></p>
<p>实用Properties读取属性文件的步骤如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、创建一个Properties的对象出来（键值对集合，空容器）</span><br><span class="line"><span class="number">2</span>、调用load(字符输入流/字节输入流)方法，开始加载属性文件中的键值对数据到properties对象中去</span><br><span class="line"><span class="number">3</span>、调用getProperty(键)方法，根据键取值</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握使用Properties类读取属性文件中的键值对信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个Properties的对象出来（键值对集合，空容器）</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        System.out.println(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开始加载属性文件中的键值对数据到properties对象中去</span></span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;properties-xml-log-app\\src\\users.properties&quot;</span>));</span><br><span class="line">        System.out.println(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、根据键取值</span></span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;赵敏&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;张无忌&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、遍历全部的键和值。</span></span><br><span class="line">        <span class="comment">//获取键的集合</span></span><br><span class="line">        Set&lt;String&gt; keys = properties.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            <span class="comment">//再根据键获取值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;----&gt;&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        properties.forEach((k, v) -&gt; &#123;</span><br><span class="line">            System.out.println(k + <span class="string">&quot;----&gt;&quot;</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>使用Properties往属性文件中写键值对</strong>，需要用到的方法如下</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/07/PfyAag3MzV7tuCp.webp" alt="1667993320872"></p>
<p>往Properties属性文件中写键值对的步骤如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、先准备一个.properties属性文件，按照格式写几个键值对</span><br><span class="line"><span class="number">1</span>、创建Properties对象出来，</span><br><span class="line"><span class="number">2</span>、调用setProperty存储一些键值对数据</span><br><span class="line"><span class="number">3</span>、调用store(字符输出流/字节输出流, 注释)，将Properties集合中的键和值写到文件中</span><br><span class="line">	注意：第二个参数是注释，必须得加；</span><br></pre></td></tr></table></figure>
<p>先准备一个<code>users.properties</code>属性文件，如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/07/VIm1FTDnH4qGbUz.webp" alt="1667993682237"></p>
<p>接下来，编写代码读取上面的属性文件。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建Properties对象出来，先用它存储一些键值对数据</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;minmin&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;殷素素&quot;</span>, <span class="string">&quot;cuishan&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;susu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、把properties对象中的键值对数据存入到属性文件中去</span></span><br><span class="line">        properties.store(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;properties-xml-log-app/src/users2.properties&quot;</span>)</span><br><span class="line">                         , <span class="string">&quot;i saved many users!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，<code>user2.properties</code> 配置文件打开效果如下图所示。</p>
<p><img src="https://s2.loli.net/2024/05/07/4XHZfgwuczG2mjN.webp" alt="1667993581146"></p>
<h2 id="二、XML文件">二、XML文件</h2>
<h3 id="2-1-XML文件概述">2.1 XML文件概述</h3>
<p><strong>首先，我们来认识一下，什么是XML？</strong></p>
<p>XML是可扩展的标记语言，意思是它是由一些标签组成的，而这些标签是自己定义的。本质上一种数据格式，可以用来表示复杂的数据关系。</p>
<p>XML文件有如下的特点：</p>
<ul>
<li>XML中的<code>&lt;标签名&gt;</code> 称为一个标签或者一个元素，一般是成对出现的。</li>
<li>XML中的标签名可以自己定义（可扩展），但是必须要正确的嵌套</li>
<li>XML中只能有一个根标签。</li>
<li>XML标准中可以有属性</li>
<li>XML必须第一行有一个文档声明，格式是固定的<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code></li>
<li>XML文件必须是以.xml为后缀结尾</li>
</ul>
<p>如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/07/jh1Rc5dG9L7pFYA.webp" alt="1667993965682"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注释：以上抬头声明必须放在第一行，必须有 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  根标签只能有一个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">desc</span>=<span class="string">&quot;第一个用户&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张无忌<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">地址</span>&gt;</span>光明顶<span class="tag">&lt;/<span class="name">地址</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>minmin<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">people</span>&gt;</span>很多人<span class="tag">&lt;/<span class="name">people</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>敏敏<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>女<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">地址</span>&gt;</span>光明顶<span class="tag">&lt;/<span class="name">地址</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>wuji<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面XML文件中的数据格式是最为常见的，标签有属性、文本、还有合理的嵌套。XML文件中除了写以上的数据格式之外，还有一些特殊的字符不能直接写。</p>
<ul>
<li>
<p>像 <code>&lt;,&gt;,&amp; </code>等这些符号不能出现在标签的文本中，因为标签格式本身就有&lt;&gt;，会和标签格式冲突。</p>
<p>如果标签文本中有这些特殊字符，需要用一些占位符代替。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt;  表示 &lt;</span><br><span class="line">&amp;gt;  表示 &gt;</span><br><span class="line">&amp;amp; 表示 &amp;</span><br><span class="line">&amp;apos; 表示 &#x27;</span><br><span class="line">&amp;quot; 表示 &quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span> 3 <span class="symbol">&amp;lt;</span> 2 <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> 5 <span class="symbol">&amp;gt;</span> 4 <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果在标签文本中，出现大量的特殊字符，不想使用特殊字符，此时可以用CDATA区，格式如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data1</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">   		3 &lt; 2 &amp;&amp; 5 &gt; 4</span><br><span class="line">    ]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">data1</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>XML在实际开发中有什么作用？</strong></p>
<p><img src="https://s2.loli.net/2024/05/07/jJm2TNYLCBx7fny.webp" alt="1667995490654"></p>
<h3 id="2-2-XML解析1">2.2 XML解析1</h3>
<p>使用程序读取XML文件中的数据，称之为XML解析。这里并不需要我们自己写IO流代码去读取xml文件中的数据。其实有很多开源的，好用的XML解析框架，最知名的是DOM4J（第三方开发的）</p>
<p><img src="https://s2.loli.net/2024/05/07/C2GfUSWK3vhwPpd.webp" alt="1667996374837"></p>
<p>由于DOM4J是第三方提供的，所以需要把第三方提供的Jar包导入到自己的项目中来，才可以使用。具体步骤如下：</p>
<p><img src="https://s2.loli.net/2024/05/07/WfclRMu2g9Loxhi.webp" alt="1667996538290"></p>
<p>DOM4J解析XML文件的思想是：文档对象模型（意思是把整个XML文档、每一个标签、每一个属性都等都当做对象来看待）。Dowument对象表示真个XML文档、Element对象表示标签（元素）、Attribute对象表示属性、标签中的内容就是文本</p>
<p><img src="https://s2.loli.net/2024/05/07/w34UXfltcVbnuix.webp" alt="1667996650787"></p>
<p>DOM4J解析XML需要用到的方法如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/07/8qABUlL567ziVZW.webp" alt="1667996750188"></p>
<p>XML解析的过程，是从根元素开始，从外层往里层解析。 我们先把Document对象，和根元素获取出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个Dom4J框架提供的解析器对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用saxReader对象把需要解析的XML文件读成一个Document对象。</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span></span><br><span class="line">                saxReader.read(<span class="string">&quot;properties-xml-log-app\\src\\helloworld.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、从文档对象中解析XML文件的全部数据了</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        System.out.println(root.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/05/07/rjGRAZCoS1yJOmW.webp" alt="1667996995326"></p>
<h3 id="2-3-XML解析2">2.3 XML解析2</h3>
<p>获取到XML文件的根元素之后，接下来，就可以用根元素在获取到它里面的子元素（包括子标签、表属性等）。需要用到的方法如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/07/ETmFwMoLbXUsfBn.webp" alt="1667997211327"></p>
<p>接下来，把上面的方法先一个一个的演示一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个Dom4J框架提供的解析器对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用saxReader对象把需要解析的XML文件读成一个Document对象。</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span></span><br><span class="line">                saxReader.read(<span class="string">&quot;properties-xml-log-app\\src\\helloworld.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、从文档对象中解析XML文件的全部数据了</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        System.out.println(root.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、获取根元素下的全部一级子元素。</span></span><br><span class="line">        <span class="comment">// List&lt;Element&gt; elements = root.elements();</span></span><br><span class="line">        List&lt;Element&gt; elements = root.elements(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">            System.out.println(element.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、获取当前元素下的某个子元素。</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">people</span> <span class="operator">=</span> root.element(<span class="string">&quot;people&quot;</span>);</span><br><span class="line">        System.out.println(people.getText());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果下面有很多子元素user，默认获取第一个。</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">user</span> <span class="operator">=</span> root.element(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(user.elementText(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、获取元素的属性信息呢？</span></span><br><span class="line">        System.out.println(user.attributeValue(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        <span class="type">Attribute</span> <span class="variable">id</span> <span class="operator">=</span> user.attribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        System.out.println(id.getName());</span><br><span class="line">        System.out.println(id.getValue());</span><br><span class="line"></span><br><span class="line">        List&lt;Attribute&gt; attributes = user.attributes();</span><br><span class="line">        <span class="keyword">for</span> (Attribute attribute : attributes) &#123;</span><br><span class="line">            System.out.println(attribute.getName() + <span class="string">&quot;=&quot;</span> + attribute.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7、如何获取全部的文本内容:获取当前元素下的子元素文本值</span></span><br><span class="line">        System.out.println(user.elementText(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        System.out.println(user.elementText(<span class="string">&quot;地址&quot;</span>));</span><br><span class="line">        System.out.println(user.elementTextTrim(<span class="string">&quot;地址&quot;</span>)); <span class="comment">// 取出文本去除前后空格</span></span><br><span class="line">        System.out.println(user.elementText(<span class="string">&quot;password&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Element</span> <span class="variable">data</span> <span class="operator">=</span> user.element(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        System.out.println(data.getText());</span><br><span class="line">        System.out.println(data.getTextTrim()); <span class="comment">// 取出文本去除前后空格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-XML文件写入">2.4 XML文件写入</h3>
<p>我们自己使用StringBuilder按照标签的格式拼接，然后再使用BufferedWriter写到XML文件中去就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、使用一个StringBuilder对象来拼接XML格式的数据。</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot; ?&gt;\r\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;&lt;book&gt;\r\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;\t&lt;name&gt;&quot;</span>).append(<span class="string">&quot;从入门到跑路&quot;</span>).append(<span class="string">&quot;&lt;/name&gt;\r\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;\t&lt;author&gt;&quot;</span>).append(<span class="string">&quot;dlei&quot;</span>).append(<span class="string">&quot;&lt;/author&gt;\r\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;\t&lt;price&gt;&quot;</span>).append(<span class="number">999.99</span>).append(<span class="string">&quot;&lt;/price&gt;\r\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;&lt;/book&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;properties-xml-log-app/src/book.xml&quot;</span>));</span><br><span class="line">                )&#123;</span><br><span class="line">            bw.write(sb.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-XML约束（了解）">2.5 XML约束（了解）</h3>
<p>各位小伙伴，关于XML还有最后一个知识需要大家了解一下。这个知识叫做约束XML文件的编写，我讲这个知识的目的是因为同学们以后在开发过程中会遇到这个知识，但是这个代码不需要大家写，了解一下就可以了。</p>
<p><strong>首先，说一些什么是XML约束？</strong></p>
<p>XML约束指的是限制XML文件中的标签或者属性，只能按照规定的格式写。</p>
<p>比如我在项目中，想约束一个XML文件中的标签只能写&lt;书&gt;、&lt;书名&gt;、&lt;作者&gt;、&lt;售价&gt;这几个标签，如果写其他标签就报错。</p>
<ul>
<li>
<p>DTD约束案例</p>
<p>如下图所示book.xml中引入了DTD约束文件，book.xml文件中的标签就受到DTD文件的约束</p>
<p><img src="https://s2.loli.net/2024/05/07/zUBjwl83teSgWV9.webp" alt="1668001621567"></p>
<p>DTD文件解释</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!ELEMENT 书架(书+)&gt;</span>   表示根标签是<span class="tag">&lt;<span class="name">书架</span>&gt;</span>，并且书架中有子标签<span class="tag">&lt;<span class="name">书</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT 书(书名、作者、售价)&gt;</span> 表示书是一个标签，且书中有子标签<span class="tag">&lt;<span class="name">书名</span>&gt;</span>、<span class="tag">&lt;<span class="name">作者</span>&gt;</span>、<span class="tag">&lt;<span class="name">售价</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT 书名(<span class="keyword">#PCDATA</span>)&gt;</span>	表示<span class="tag">&lt;<span class="name">书名</span>&gt;</span>是一个标签，且<span class="tag">&lt;<span class="name">书名</span>&gt;</span>里面是普通文本</span><br><span class="line"><span class="meta">&lt;!ELEMENT 作者(<span class="keyword">#PCDATA</span>)&gt;</span>	表示<span class="tag">&lt;<span class="name">作者</span>&gt;</span>是一个标签，且<span class="tag">&lt;<span class="name">作者</span>&gt;</span>里面是普通文本</span><br><span class="line"><span class="meta">&lt;!ELEMENT 售价(<span class="keyword">#PCDATA</span>)&gt;</span>	表示<span class="tag">&lt;<span class="name">售价</span>&gt;</span>是一个标签，且<span class="tag">&lt;<span class="name">售价</span>&gt;</span>里面是普通文本</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Schame约束案例</p>
<p>如下图所示，左边的book2.xml文件就受到右边schame文件（.xsd结尾的文件）的约束。</p>
<p><img src="https://s2.loli.net/2024/05/07/QM3oHrNpKPSjR2B.webp" alt="1668001745089"></p>
</li>
</ul>
<h2 id="三、日志技术">三、日志技术</h2>
<h3 id="3-1-日志概述">3.1 日志概述</h3>
<p>想搞清楚什么是日志，其实可以通过下面几个问题来了解的。</p>
<ul>
<li>系统系统能记住某些数据被谁操作，比如被谁删除了？</li>
<li>想分析用户浏览系统的具体情况，比如挖掘用户的具体喜好？</li>
<li>当系统在开发中或者上线后出现了Bug，崩溃了，该通过什么去分析，定位Bug?</li>
</ul>
<p>而日志就可以帮我们解决以上的问题。所以日志就好比生活中的日记，日记可以记录生活中的点点滴滴；而程序中的日志，通常就是一个文件，里面记录了程序运行过程中产生的各种数据。</p>
<p>日志技术有如下好处</p>
<ol>
<li>日志可以将系统执行的信息，方便的记录到指定位置，可以是控制台、可以是文件、可以是数据库中。</li>
<li>日志可以随时以开关的形式控制启停，无需侵入到源代码中去修改。</li>
</ol>
<h3 id="3-2-日志的体系">3.2 日志的体系</h3>
<p>大家注意了在行内，其实有很多日志框架给开发者使用。所谓日志框架就是由一些牛人或者第三方公司已经做好的实现代码，后来者就可以直接拿过去使用。</p>
<p>日志框架有很多种，比如有JUL（java.util.logging）、Log4j、logback等。但是这些日志框架如果使用的API方法都不一样的话，使用者的学习成本就很高。为了降低程序员的学习压力，行内提供了一套日志接口，然后所有的日志框架都按照日志接口的API来实现就可以了。</p>
<p>这样程序员只要会一套日志框架，那么其他的也就可以通过用，甚至可以在多套日志框架之间来回切换。比较常用的日志框架，和日志接口的关系如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/07/AaZtEHLq5svxF8O.webp" alt="1668044513873"></p>
<p><strong>这里推荐使用Logback日志框架，也在行业中最为广泛使用的。</strong></p>
<p><strong>Logback日志分为哪几个模块</strong></p>
<p><img src="https://s2.loli.net/2024/05/07/GD85c9nBMK4mhEr.webp" alt="1668044711404"></p>
<h3 id="3-3-Logback快速入门">3.3 Logback快速入门</h3>
<p>接下来，快速使用一下Logback日志框架，使用Logback记录几条日志信息到文件中去和将日志信息打印在控制台上。</p>
<p>由于Logback是第三方提供的技术，所以首先需要啊将Jar包引入到项目中，具体步骤如下</p>
<ol>
<li>
<p>在资料中找到<code>slftj-api.jar、logback-core.jar、logback-classes.jar</code> 这三个jar包，复制一下</p>
</li>
<li>
<p>在当前模块下面新建一个lib文件夹，把刚刚复制的三个jar包都粘贴到此处</p>
</li>
<li>
<p>从资料中找到<code>logback.xml</code>配置文件，将此文件复制粘贴到src目录下（必须是src目录）</p>
</li>
<li>
<p>然后就可以开始写代码了，在代码中创建一个日志记录日对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;当前类名&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>开始记录日志，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogBackTest</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个Logger日志对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;LogBackTest&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//while (true) &#123;</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;chu法方法开始执行~~~&quot;</span>);</span><br><span class="line">                chu(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">                LOGGER.info(<span class="string">&quot;chu法方法执行成功~~~&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;chu法方法执行失败了，出现了bug~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">chu</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        LOGGER.debug(<span class="string">&quot;参数a:&quot;</span> + a);</span><br><span class="line">        LOGGER.debug(<span class="string">&quot;参数b:&quot;</span> + b);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;结果是：&quot;</span> + c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>当我们运行程序时，就可以看到控制台记录的日志</p>
<p><img src="https://s2.loli.net/2024/05/07/jbCUm9ldaDWHqBt.webp" alt="1668045391911"></p>
<p>同时在文件中，也有一份这样的日志信息。文件在哪里内，从配置文件中去找</p>
<p><img src="https://s2.loli.net/2024/05/07/ToQvFdtBV6GSuEs.webp" alt="1668045471304"></p>
<p>打开<code>D:/log/itheima-data.log</code>看一下文件中是否有记录日志吧！！</p>
<h3 id="3-4-日志配置文件">3.4 日志配置文件</h3>
<p>Logback提供了一个核心配置文件logback.xml，日志框架在记录日志时会读取配置文件中的配置信息，从而记录日志的形式。具体可以做哪些配置呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 可以配置日志输出的位置是文件、还是控制台</span><br><span class="line"><span class="number">2.</span> 可以配置日志输出的格式</span><br><span class="line"><span class="number">3.</span> 还可以配置日志关闭和开启、以及哪些日志输出哪些日志不输出。</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>如下图所示，控制日志往文件中输出，还是往控制台输出</strong></li>
</ul>
<p><img src="https://s2.loli.net/2024/05/07/eahpiHGbjCgZ2TM.webp" alt="1668045955362"></p>
<ul>
<li><strong>如下图所示，控制打开和关闭日志</strong></li>
</ul>
<p><img src="https://s2.loli.net/2024/05/07/BqvmLt1rGFpfwVY.webp" alt="1668046078574"></p>
<ul>
<li>
<p><strong>如下图所示，控制日志的输出的格式</strong></p>
<p>日志格式是由一些特殊的符号组成，可以根据需要删减不想看到的部分。比如不想看到线程名那就不要[%thread]。但是不建议同学们更改这些格式，因为这些都是日志很基本的信息。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/07/GXqAewkd8r7DNvl.webp" alt="1668046216355"></p>
<h3 id="3-5-配置日志级别">3.5 配置日志级别</h3>
<p><img src="https://s2.loli.net/2024/05/07/La2eihAnEx3NWls.webp" alt="1668046420402"></p>
<ul>
<li>在哪里配置日志级别呢？如下图所示</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/07/xiRkETUth1qIAwn.webp" alt="1668046551345"></p>
<ul>
<li>
<p>Logback只输出大于或者等于核心配置文件配置的日志级别信息。小于配置级别的日志信息，不被记录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">配置的是trace，则trace、debug、info、warn、error级别的日志都被输出</span><br><span class="line">配置的是debug, 则debug、info、warn、error级别的日志被输出</span><br><span class="line">配置的是info,则info、warn、error级别的日志被输出</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="多线程">多线程</h1>
<h2 id="一、多线程">一、多线程</h2>
<p><strong>线程其实是程序中的一条执行路径。</strong></p>
<p>我们之前写过的程序，其实都是单线程程序，如下图代码，如果前面的for循环没有执行完，for循环下面的代码是不会执行的。</p>
<p><img src="https://s2.loli.net/2024/05/07/HFqZmPixg4vRIe1.webp" alt="1668046984412"></p>
<p><strong>怎样的程序才是多线程程序呢？</strong> 如下图所示，12306网站就是支持多线程的，因为同时可以有很多人一起进入网站购票，而且每一个人互不影响。再比如百度网盘，可以同时下载或者上传多个文件。这些程序中其实就有多条执行路径，每一条执行执行路径就是一条线程，所以这样的程序就是多线程程序。</p>
<p><img src="https://s2.loli.net/2024/05/07/1tIhqPxXlHM6Ema.webp" alt="1668047091631"></p>
<h3 id="1-1-线程创建方式1">1.1 线程创建方式1</h3>
<p>Java为开发者提供了一个类叫做Thread，此类的对象用来表示线程。创建线程并执行线程的步骤如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>定义一个子类继承Thread类，并重写run方法</span><br><span class="line"><span class="number">2.</span>创建Thread的子类对象</span><br><span class="line"><span class="number">3.</span>调用start方法启动线程（启动线程后，会自动执行run方法中的代码）</span><br></pre></td></tr></table></figure>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">// 2、必须重写Thread类的run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 描述线程的执行任务。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程MyThread输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再定义一个测试类，在测试类中创建MyThread线程对象，并启动线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest1</span> &#123;</span><br><span class="line">    <span class="comment">// main方法是由一条默认的主线程负责执行。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3、创建MyThread线程类的对象代表一个线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">// 4、启动线程（自动执行run方法的）</span></span><br><span class="line">        t.start(); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程main输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果如下图所示，我们会发现MyThread和main线程在相互抢夺CPU的执行权（<strong>注意：哪一个线程先执行，哪一个线程后执行，目前我们是无法控制的，每次输出结果都会不一样</strong>）</p>
<p><img src="https://s2.loli.net/2024/05/07/aYR4UzKByMcnQpq.webp" alt="1668047848218"></p>
<p><strong>最后我们还需要注意一点</strong>：不能直接去调用run方法，如果直接调用run方法就不认为是一条线程启动了，而是把Thread当做一个普通对象，此时run方法中的执行的代码会成为主线程的一部分。此时执行结果是这样的。</p>
<p><img src="https://s2.loli.net/2024/05/07/NJx7ueWgVrKwpMG.webp" alt="1668048108548"></p>
<h3 id="1-2-线程创建方式2">1.2 线程创建方式2</h3>
<p>接下来我们学习线程的第二种创建方式。Java为开发者提供了一个Runnable接口，该接口中只有一个run方法，意思就是通过Runnable接口的实现类对象专门来表示线程要执行的任务。具体步骤如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>先写一个Runnable接口的实现类，重写run方法(这里面就是线程要执行的代码)</span><br><span class="line"><span class="number">2.</span>再创建一个Runnable实现类的对象</span><br><span class="line"><span class="number">3.</span>创建一个Thread对象，把Runnable实现类的对象传递给Thread</span><br><span class="line"><span class="number">4.</span>调用Thread对象的start()方法启动线程（启动后会自动执行Runnable里面的run方法）</span><br></pre></td></tr></table></figure>
<p>代码如下：先准备一个Runnable接口的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、定义一个任务类，实现Runnable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">// 2、重写runnable的run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程要执行的任务。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程输出 ===》&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再写一个测试类，在测试类中创建线程对象，并执行线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3、创建任务对象。</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">// 4、把任务对象交给一个线程对象处理。</span></span><br><span class="line">        <span class="comment">//  public Thread(Runnable target)</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(target).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程main输出 ===》&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面代码，结果如下图所示**（注意：没有出现下面交替执行的效果，也是正常的）**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">主线程main输出 ===》<span class="number">1</span></span><br><span class="line">主线程main输出 ===》<span class="number">2</span></span><br><span class="line">主线程main输出 ===》<span class="number">3</span></span><br><span class="line">子线程输出 ===》<span class="number">1</span></span><br><span class="line">子线程输出 ===》<span class="number">2</span></span><br><span class="line">子线程输出 ===》<span class="number">3</span></span><br><span class="line">子线程输出 ===》<span class="number">4</span></span><br><span class="line">子线程输出 ===》<span class="number">5</span></span><br><span class="line">主线程main输出 ===》<span class="number">4</span></span><br><span class="line">主线程main输出 ===》<span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="1-3-线程创建方式2—匿名内部类">1.3 线程创建方式2—匿名内部类</h3>
<p>刚刚我们学习的第二种线程的创建方式，需要写一个Runnable接口的实现类，然后再把Runnable实现类的对象传递给Thread对象。</p>
<p><strong>现在我不想写Runnable实现类，于是可以直接创建Runnable接口的匿名内部类对象，传递给Thread对象。</strong></p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest2_2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、直接创建Runnable接口的匿名内部类形式（任务对象）</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程1输出：&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(target).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简化形式1：</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程2输出：&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简化形式2：</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程3输出：&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程main输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-线程的创建方式3">1.4 线程的创建方式3</h3>
<p>接下来，我们学习线程的第三种创建方式。已经有两种了为什么还有要第三种呢？ 这样，我们先分析一下前面两种都存在的一个问题。然后再引出第三种可以解决这个问题。</p>
<ul>
<li>
<p>假设线程执行完毕之后有一些数据需要返回，前面两种方式重写的run方法均没有返回结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">    ...线程执行的代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>JDK5提供了Callable接口和FutureTask类来创建线程，它最大的优点就是有返回值。</p>
<p>在Callable接口中有一个call方法，重写call方法就是线程要执行的代码，它是有返回值的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">    ...线程执行的代码...</span><br><span class="line">    <span class="keyword">return</span> 结果;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>第三种创建线程的方式，步骤如下</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>先定义一个Callable接口的实现类，重写call方法</span><br><span class="line"><span class="number">2.</span>创建Callable实现类的对象</span><br><span class="line"><span class="number">3.</span>创建FutureTask类的对象，将Callable对象传递给FutureTask</span><br><span class="line"><span class="number">4.</span>创建Thread对象，将Future对象传递给Thread</span><br><span class="line"><span class="number">5.</span>调用Thread的start()方法启动线程(启动后会自动执行call方法)</span><br><span class="line">   等call()方法执行完之后，会自动将返回值结果封装到FutrueTask对象中</span><br><span class="line">   </span><br><span class="line"><span class="number">6.</span>调用FutrueTask对的get()方法获取返回结果</span><br></pre></td></tr></table></figure>
<p>代码如下：先准备一个Callable接口的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、让子类继承Thread线程类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">// 2、必须重写Thread类的run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 描述线程的执行任务。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程MyThread输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再定义一个测试类，在测试类中创建线程并启动线程，还要获取返回结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 3、创建一个Callable的对象</span></span><br><span class="line">        Callable&lt;String&gt; call = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 4、把Callable的对象封装成一个FutureTask对象（任务对象）</span></span><br><span class="line">        <span class="comment">// 未来任务对象的作用？</span></span><br><span class="line">        <span class="comment">// 1、是一个任务对象，实现了Runnable对象.</span></span><br><span class="line">        <span class="comment">// 2、可以在线程执行完毕之后，用未来任务对象调用get方法获取线程执行完毕后的结果。</span></span><br><span class="line">        FutureTask&lt;String&gt; f1  = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call);</span><br><span class="line">        <span class="comment">// 5、把任务对象交给一个Thread对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(f1).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Callable&lt;String&gt; call2 = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>);</span><br><span class="line">        FutureTask&lt;String&gt; f2  = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call2);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(f2).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、获取线程执行完毕后返回的结果。</span></span><br><span class="line">        <span class="comment">// 注意：如果执行到这儿，假如上面的线程还没有执行完毕</span></span><br><span class="line">        <span class="comment">// 这里的代码会暂停，等待上面线程执行完毕后才会获取结果。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> f1.get();</span><br><span class="line">        System.out.println(rs);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs2</span> <span class="operator">=</span> f2.get();</span><br><span class="line">        System.out.println(rs2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、多线程常用方法">二、多线程常用方法</h2>
<p><img src="https://s2.loli.net/2024/05/07/7jSkTeWsbl8J3RO.webp" alt="1668051403591"></p>
<p>下面我们演示一下<code>getName()</code>、<code>setName(String name)</code>、<code>currentThread()</code>、<code>sleep(long time)</code>这些方法的使用效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">//1.执行父类Thread(String name)构造器，为当前线程设置名字了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//2.currentThread() 哪个线程执行它，它就会得到哪个线程对象。</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//3.getName() 获取线程名称</span></span><br><span class="line">            System.out.println(t.getName() + <span class="string">&quot;输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再测试类中，创建线程对象，并启动线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.setName(String name) <span class="comment">//设置线程名称;</span></span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(t1.getName());  <span class="comment">//Thread-0</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;2号线程&quot;</span>);</span><br><span class="line">        <span class="comment">// t2.setName(&quot;2号线程&quot;);</span></span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(t2.getName()); <span class="comment">// Thread-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程对象的名字</span></span><br><span class="line">        <span class="comment">// 哪个线程执行它，它就会得到哪个线程对象。</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">m</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        m.setName(<span class="string">&quot;最牛的线程&quot;</span>);</span><br><span class="line">        System.out.println(m.getName()); <span class="comment">// main</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(m.getName() + <span class="string">&quot;线程输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上面代码，效果如下图所示，我们发现每一条线程都有自己了名字了。</p>
<p><img src="https://s2.loli.net/2024/05/07/7lqcHZ23vYBewtC.webp" alt="1668052028054"></p>
<p><strong>最后再演示一下join这个方法是什么效果。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// join方法作用：让当前调用这个方法的线程先执行完。</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;1号线程&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.join();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;2号线程&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;3号线程&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        t3.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行效果是1号线程先执行完，再执行2号线程；2号线程执行完，再执行3号线程；3号线程执行完就结束了。</p>
<p><img src="../../../../BaiduNetdiskDownload/%E5%85%A8%E9%83%A8%E8%AE%B2%E4%B9%89/day11-%E5%A4%9A%E7%BA%BF%E7%A8%8B/assets/1668052307537.webp" alt="1668052307537"></p>
<p>我们再尝试，把join()方法去掉，再看执行效果。此时你会发现2号线程没有执行完1号线程就执行了**（效果是多次运行才出现的，根据个人电脑而异，可能有同学半天也出现不了也是正常的）**</p>
<p><img src="https://s2.loli.net/2024/05/07/Wso45SDJkgjYC1d.webp" alt="1668052414444"></p>
<h2 id="三、线程安全问题">三、线程安全问题</h2>
<h3 id="3-1-线程安全问题概述">3.1 线程安全问题概述</h3>
<ul>
<li><strong>首先，什么是线程安全问题呢？</strong></li>
</ul>
<p><strong>线程安全问题指的是，多个线程同时操作同一个共享资源的时候，可能会出现业务安全问题。</strong></p>
<p>下面通过一个取钱的案例给同学们演示一下。案例需求如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">场景：小明和小红是一对夫妻，他们有一个共享账户，余额是<span class="number">10</span>万元，小红和小明同时来取钱，并且<span class="number">2</span>人各自都在取钱<span class="number">10</span>万元，可能出现什么问题呢？</span><br></pre></td></tr></table></figure>
<p>如下图所示，小明和小红假设都是一个线程，本类每个线程都应该执行完三步操作，才算是完成的取钱的操作。但是真实执行过程可能是下面这样子的</p>
<p>​	① 小红线程只执行了判断余额是否足够（条件为true），然后CPU的执行权就被小红线程抢走了。</p>
<p>​	② 小红线程也执行了判断了余额是否足够（条件也是true）, 然后CPU执行权又被小明线程抢走了。</p>
<p>​	③ 小明线程由于刚才已经判断余额是否足够了，直接执行第2步，吐出了10万元钱，此时共享账户月为0。然后CPU执行权又被小红线程抢走。</p>
<p>​	④ 小红线程由于刚刚也已经判断余额是否足够了，直接执行第2步，吐出了10万元钱，此时共享账户月为-10万。</p>
<p><img src="https://s2.loli.net/2024/05/07/TKzVguC25pIWOcE.webp" alt="1668059112092"></p>
<p><strong>你会发现，在这个取钱案例中，两个人把共享账户的钱都取了10万，但问题是只有10万块钱啊！！！</strong></p>
<p>以上取钱案例中的问题，就是线程安全问题的一种体现。</p>
<h3 id="3-2-线程安全问题的代码演示">3.2 线程安全问题的代码演示</h3>
<p>先定义一个共享的账户类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cardId; <span class="comment">// 卡号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money; <span class="comment">// 余额。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小明 小红同时过来的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">// 先搞清楚是谁来取钱？</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">// 1、判断余额是否足够</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱&quot;</span> + money + <span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.money -= money;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱：余额不足~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(String cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义一个是取钱的线程类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Account acc;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawThread</span><span class="params">(Account acc, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.acc = acc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 取钱(小明，小红)</span></span><br><span class="line">        acc.drawMoney(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，再写一个测试类，在测试类中创建两个线程对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="comment">// 1、创建一个账户对象，代表两个人的共享账户。</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;ICBC-110&quot;</span>, <span class="number">100000</span>);</span><br><span class="line">        <span class="comment">// 2、创建两个线程，分别代表小明 小红，再去同一个账户对象中取钱10万。</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc, <span class="string">&quot;小明&quot;</span>).start(); <span class="comment">// 小明</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc, <span class="string">&quot;小红&quot;</span>).start(); <span class="comment">// 小红</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，执行效果如下。你会发现两个人都取了10万块钱，余额为-10完了。</p>
<p><img src="https://s2.loli.net/2024/05/07/Hx5pgNniUr8EbA9.webp" alt="1668059997020"></p>
<h3 id="3-3-线程同步方案">3.3 线程同步方案</h3>
<p>为了解决前面的线程安全问题，我们可以使用线程同步思想。同步最常见的方案就是加锁，<strong>意思是每次只允许一个线程加锁，加锁后才能进入访问，访问完毕后自动释放锁，然后其他线程才能再加锁进来。</strong></p>
<p><img src="https://s2.loli.net/2024/05/07/Uo8s7nkZ9Wg3pxG.webp" alt="1668060312733"></p>
<p>等小红线程执行完了，把余额改为0，出去了就会释放锁。这时小明线程就可以加锁进来执行，如下图所示。</p>
<p><img src="https://s2.loli.net/2024/05/07/7UuNTxLkp2BGM8c.webp" alt="1668060382390"></p>
<p>采用加锁的方案，就可以解决前面两个线程都取10万块钱的问题。怎么加锁呢？Java提供了三种方案</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>同步代码块</span><br><span class="line"><span class="number">2.</span>同步方法</span><br><span class="line"><span class="number">3.</span>Lock锁</span><br></pre></td></tr></table></figure>
<h3 id="3-4-同步代码块">3.4 同步代码块</h3>
<p>我们先来学习同步代码块。它的作用就是把访问共享数据的代码锁起来，以此保证线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//锁对象：必须是一个唯一的对象（同一个地址）</span></span><br><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line">    <span class="comment">//...访问共享数据的代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用同步代码块，来解决前面代码里面的线程安全问题。我们只需要修改DrawThread类中的代码即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小明 小红线程同时过来的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">    <span class="comment">// 先搞清楚是谁来取钱？</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">    <span class="comment">// 1、判断余额是否足够</span></span><br><span class="line">    <span class="comment">// this正好代表共享资源！</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱&quot;</span> + money + <span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.money -= money;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱：余额不足~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时再运行测试类，观察是否会出现不合理的情况。</p>
<p><strong>最后，说一下锁对象如何选择的问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>建议把共享资源作为锁对象, 不要将随便无关的对象当做锁对象</span><br><span class="line"><span class="number">2.</span>对于实例方法，建议使用<span class="built_in">this</span>作为锁对象</span><br><span class="line"><span class="number">3.</span>对于静态方法，建议把类的字节码(类名.class)当做锁对象</span><br></pre></td></tr></table></figure>
<h3 id="3-5-同步方法">3.5 同步方法</h3>
<p><strong>其实同步方法，就是把整个方法给锁住，一个线程调用这个方法，另一个线程调用的时候就执行不了，只有等上一个线程调用结束，下一个线程调用才能继续执行。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">    <span class="comment">// 先搞清楚是谁来取钱？</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">    <span class="comment">// 1、判断余额是否足够</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;来取钱&quot;</span> + money + <span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.money -= money;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;来取钱：余额不足~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改完之后，再次运行测试类，观察是否会出现不合理的情况。</p>
<p><strong>接着，再问同学们一个问题，同步方法有没有锁对象？锁对象是谁？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同步方法也是有锁对象，只不过这个锁对象没有显示的写出来而已。</span><br><span class="line">	<span class="number">1.</span>对于实例方法，锁对象其实是<span class="built_in">this</span>（也就是方法的调用者）</span><br><span class="line">	<span class="number">2.</span>对于静态方法，锁对象时类的字节码对象（类名.class）</span><br></pre></td></tr></table></figure>
<p><strong>最终，总结一下同步代码块和同步方法有什么区别？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>不存在哪个好与不好，只是一个锁住的范围大，一个范围小</span><br><span class="line"><span class="number">2.</span>同步方法是将方法中所有的代码锁住</span><br><span class="line"><span class="number">3.</span>同步代码块是将方法中的部分代码锁住</span><br></pre></td></tr></table></figure>
<h3 id="3-6-Lock锁">3.6 Lock锁</h3>
<p>接下来，我们再来学习一种，线程安全问题的解决办法，叫做Lock锁。</p>
<p>Lock锁是JDK5版本专门提供的一种锁对象，通过这个锁对象的方法来达到加锁，和释放锁的目的，使用起来更加灵活。格式如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>首先在成员变量位子，需要创建一个Lock接口的实现类对象（这个对象就是锁对象）</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="number">2.</span>在需要上锁的地方加入下面的代码</span><br><span class="line">	 lk.lock(); <span class="comment">// 加锁</span></span><br><span class="line">	 <span class="comment">//...中间是被锁住的代码...</span></span><br><span class="line">	 lk.unlock(); <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>
<p>使用Lock锁改写前面DrawThread中取钱的方法，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建了一个锁对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">// 先搞清楚是谁来取钱？</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lk.lock(); <span class="comment">// 加锁</span></span><br><span class="line">            <span class="comment">// 1、判断余额是否足够</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;来取钱&quot;</span> + money + <span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.money -= money;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;来取钱：余额不足~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lk.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、线程通信（了解）">四、线程通信（了解）</h2>
<p><strong>首先，什么是线程通信呢？</strong></p>
<ul>
<li>当多个线程共同操作共享资源时，线程间通过某种方式互相告知自己的状态，以相互协调，避免无效的资源挣抢。</li>
</ul>
<p><strong>线程通信的常见模式：是生产者与消费者模型</strong></p>
<ul>
<li>生产者线程负责生成数据</li>
<li>消费者线程负责消费生产者生成的数据</li>
<li>注意：生产者生产完数据后应该让自己等待，通知其他消费者消费；消费者消费完数据之后应该让自己等待，同时通知生产者生成。</li>
</ul>
<p>比如下面案例中，有3个厨师（生产者线程），两个顾客（消费者线程）。</p>
<p><img src="https://s2.loli.net/2024/05/07/itwThWyCrpRvXYK.webp" alt="1668064583299"></p>
<p>接下来，我们先分析一下完成这个案例的思路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>先确定在这个案例中，什么是共享数据？</span><br><span class="line">	答：这里案例中桌子是共享数据，因为厨师和顾客都需要对桌子上的包子进行操作。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>再确定有那几条线程？哪个是生产者，哪个是消费者？</span><br><span class="line">	答：厨师是生产者线程，<span class="number">3</span>条生产者线程； </span><br><span class="line">	   顾客是消费者线程，<span class="number">2</span>条消费者线程</span><br><span class="line">	   </span><br><span class="line"><span class="number">3.</span>什么时候将哪一个线程设置为什么状态</span><br><span class="line">	生产者线程(厨师)放包子：</span><br><span class="line">		 <span class="number">1</span>)先判断是否有包子</span><br><span class="line">		 <span class="number">2</span>)没有包子时，厨师开始做包子, 做完之后把别人唤醒，然后让自己等待</span><br><span class="line">		 <span class="number">3</span>)有包子时，不做包子了，直接唤醒别人、然后让自己等待</span><br><span class="line">		 	</span><br><span class="line">	消费者线程(顾客)吃包子：</span><br><span class="line">		 <span class="number">1</span>)先判断是否有包子</span><br><span class="line">		 <span class="number">2</span>)有包子时，顾客开始吃包子, 吃完之后把别人唤醒，然后让自己等待</span><br><span class="line">		 <span class="number">3</span>)没有包子时，不吃包子了，直接唤醒别人、然后让自己等待</span><br></pre></td></tr></table></figure>
<p>按照上面分析的思路写代码。先写桌子类，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Desk</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放1个包子的方法</span></span><br><span class="line">    <span class="comment">// 厨师1 厨师2 厨师3</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="comment">// 判断是否有包子。</span></span><br><span class="line">            <span class="keyword">if</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                list.add(name + <span class="string">&quot;做的肉包子&quot;</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;做了一个肉包子~~&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 唤醒别人, 等待自己</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 有包子了，不做了。</span></span><br><span class="line">                <span class="comment">// 唤醒别人, 等待自己</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 吃货1 吃货2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">if</span>(list.size() == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 有包子，吃了</span></span><br><span class="line">                System.out.println(name  + <span class="string">&quot;吃了：&quot;</span> + list.get(<span class="number">0</span>));</span><br><span class="line">                list.clear();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有包子</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再写测试类，在测试类中，创建3个厨师线程对象，再创建2个顾客对象，并启动所有线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//   需求：3个生产者线程，负责生产包子，每个线程每次只能生产1个包子放在桌子上</span></span><br><span class="line">        <span class="comment">//      2个消费者线程负责吃包子，每人每次只能从桌子上拿1个包子吃。</span></span><br><span class="line">        <span class="type">Desk</span> <span class="variable">desk</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Desk</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建3个生产者线程（3个厨师）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;厨师1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;厨师2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;厨师3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建2个消费者线程（2个吃货）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;吃货1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;吃货2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上面代码，运行结果如下：你会发现多个线程相互协调执行，避免无效的资源挣抢。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">厨师1做了一个肉包子~~</span><br><span class="line">吃货2吃了：厨师1做的肉包子</span><br><span class="line">厨师3做了一个肉包子~~</span><br><span class="line">吃货2吃了：厨师3做的肉包子</span><br><span class="line">厨师1做了一个肉包子~~</span><br><span class="line">吃货1吃了：厨师1做的肉包子</span><br><span class="line">厨师2做了一个肉包子~~</span><br><span class="line">吃货2吃了：厨师2做的肉包子</span><br><span class="line">厨师3做了一个肉包子~~</span><br><span class="line">吃货1吃了：厨师3做的肉包子</span><br></pre></td></tr></table></figure>
<h2 id="五、线程池">五、线程池</h2>
<h3 id="5-1-线程池概述">5.1 线程池概述</h3>
<p><strong>线程池就是一个可以复用线程的技术</strong>。</p>
<p>要理解什么是线程复用技术，我们先得看一下不使用线程池会有什么问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设：用户每次发起一个请求给后台，后台就创建一个新的线程来处理，下次新的任务过来肯定也会创建新的线程，如果用户量非常大，创建的线程也讲越来越多。然而，创建线程是开销很大的，并且请求过多时，会严重影响系统性能。</span><br></pre></td></tr></table></figure>
<p>而使用线程池，就可以解决上面的问题。如下图所示，线程池内部会有一个容器，存储几个核心线程，假设有3个核心线程，这3个核心线程可以处理3个任务。</p>
<p><img src="https://s2.loli.net/2024/05/07/QqBd95HsoeU7KjP.webp" alt="1668065892511"></p>
<p>但是任务总有被执行完的时候，假设第1个线程的任务执行完了，那么第1个线程就空闲下来了，有新的任务时，空闲下来的第1个线程可以去执行其他任务。依此内推，这3个线程可以不断的复用，也可以执行很多个任务。</p>
<p><img src="https://s2.loli.net/2024/05/07/elET3jIdsQwuah8.webp" alt="1668066073126"></p>
<p><strong>所以，线程池就是一个线程复用技术，它可以提高线程的利用率。</strong></p>
<h3 id="5-2-创建线程池">5.2 创建线程池</h3>
<p>在JDK5版本中提供了代表线程池的接口ExecutorService，而这个接口下有一个实现类叫ThreadPoolExecutor类，使用ThreadPoolExecutor类就可以用来创建线程池对象。</p>
<p>下面是它的构造器，参数比较多，不要怕，干就完了^_^。</p>
<p><img src="https://s2.loli.net/2024/05/07/Q5ShbopTngvKHIJ.webp" alt="1668066279649"></p>
<p>接下来，用这7个参数的构造器来创建线程池的对象。代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">3</span>,	<span class="comment">//核心线程数有3个</span></span><br><span class="line">    <span class="number">5</span>,  <span class="comment">//最大线程数有5个。   临时线程数=最大线程数-核心线程数=5-3=2</span></span><br><span class="line">    <span class="number">8</span>,	<span class="comment">//临时线程存活的时间8秒。 意思是临时线程8秒没有任务执行，就会被销毁掉。</span></span><br><span class="line">    TimeUnit.SECONDS,<span class="comment">//时间单位（秒）</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>), <span class="comment">//任务阻塞队列，没有来得及执行的任务在，任务队列中等待</span></span><br><span class="line">    Executors.defaultThreadFactory(), <span class="comment">//用于创建线程的工厂对象</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">//拒绝策略</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>关于线程池，我们需要注意下面的两个问题</p>
<ul>
<li>
<p>临时线程什么时候创建？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新任务提交时，发现核心线程都在忙、任务队列满了、并且还可以创建临时线程，此时会创建临时线程。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>什么时候开始拒绝新的任务？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">核心线程和临时线程都在忙、任务队列也满了、新任务过来时才会开始拒绝任务。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-3-线程池执行Runnable任务">5.3 线程池执行Runnable任务</h3>
<p>创建好线程池之后，接下来我们就可以使用线程池执行任务了。线程池执行的任务可以有两种，一种是Runnable任务；一种是callable任务。下面的execute方法可以用来执行Runnable任务。</p>
<p><img src="https://s2.loli.net/2024/05/07/7esnPvdRMha3B9m.webp" alt="1668066844202"></p>
<p>先准备一个线程任务类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 任务是干啥的？</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ==&gt; 输出666~~&quot;</span>);</span><br><span class="line">        <span class="comment">//为了模拟线程一直在执行，这里睡久一点</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是执行Runnable任务的代码，注意阅读注释，对照着前面的7个参数理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">3</span>,	<span class="comment">//核心线程数有3个</span></span><br><span class="line">    <span class="number">5</span>,  <span class="comment">//最大线程数有5个。   临时线程数=最大线程数-核心线程数=5-3=2</span></span><br><span class="line">    <span class="number">8</span>,	<span class="comment">//临时线程存活的时间8秒。 意思是临时线程8秒没有任务执行，就会被销毁掉。</span></span><br><span class="line">    TimeUnit.SECONDS,<span class="comment">//时间单位（秒）</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>), <span class="comment">//任务阻塞队列，没有来得及执行的任务在，任务队列中等待</span></span><br><span class="line">    Executors.defaultThreadFactory(), <span class="comment">//用于创建线程的工厂对象</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">//拒绝策略</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line"><span class="comment">//下面4个任务在任务队列里排队</span></span><br><span class="line">pool.execute(target);</span><br><span class="line">pool.execute(target);</span><br><span class="line">pool.execute(target);</span><br><span class="line">pool.execute(target);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面2个任务，会被临时线程的创建时机了</span></span><br><span class="line">pool.execute(target);</span><br><span class="line">pool.execute(target);</span><br><span class="line"><span class="comment">// 到了新任务的拒绝时机了！</span></span><br><span class="line">pool.execute(target);</span><br></pre></td></tr></table></figure>
<p>执行上面的代码，结果输出如下</p>
<p><img src="https://s2.loli.net/2024/05/07/qBsQNnrCc2Sat8k.webp" alt="1668067745116"></p>
<h3 id="5-4-线程池执行Callable任务">5.4 线程池执行Callable任务</h3>
<p>接下来，我们学习使用线程池执行Callable任务。callable任务相对于Runnable任务来说，就是多了一个返回值。</p>
<p>执行Callable任务需要用到下面的submit方法</p>
<p><img src="https://s2.loli.net/2024/05/07/DSMK9uohiFcVdzj.webp" alt="1668067798673"></p>
<p>先准备一个Callable线程任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCallable</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、重写call方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 描述线程的任务，返回线程执行返回后的结果。</span></span><br><span class="line">        <span class="comment">// 需求：求1-n的和返回。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot;求出了1-&quot;</span> + n + <span class="string">&quot;的和是：&quot;</span> + sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再准备一个测试类，在测试类中创建线程池，并执行callable任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、通过ThreadPoolExecutor创建一个线程池对象。</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">            <span class="number">5</span>,</span><br><span class="line">            <span class="number">8</span>,</span><br><span class="line">            TimeUnit.SECONDS, </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用线程处理Callable任务。</span></span><br><span class="line">        Future&lt;String&gt; f1 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>));</span><br><span class="line">        Future&lt;String&gt; f2 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>));</span><br><span class="line">        Future&lt;String&gt; f3 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">300</span>));</span><br><span class="line">        Future&lt;String&gt; f4 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">400</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、执行完Callable任务后，需要获取返回结果。</span></span><br><span class="line">        System.out.println(f1.get());</span><br><span class="line">        System.out.println(f2.get());</span><br><span class="line">        System.out.println(f3.get());</span><br><span class="line">        System.out.println(f4.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后，结果如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/07/gqeMhyECOaumRDo.webp" alt="1668067964048"></p>
<h3 id="5-5-线程池工具类（Executors）">5.5 线程池工具类（Executors）</h3>
<p>Java为开发者提供了一个创建线程池的工具类，叫做Executors，它提供了方法可以创建各种不能特点的线程池。如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/07/6CMjHSOvnXKk17B.webp" alt="1668068110593"></p>
<p>接下来，我们演示一下创建固定线程数量的线程池。这几个方法用得不多，所以这里不做过多演示，同学们了解一下就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、通过Executors创建一个线程池对象。</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">17</span>);</span><br><span class="line">        <span class="comment">// 老师：核心线程数量到底配置多少呢？？？</span></span><br><span class="line">        <span class="comment">// 计算密集型的任务：核心线程数量 = CPU的核数 + 1</span></span><br><span class="line">        <span class="comment">// IO密集型的任务：核心线程数量 = CPU核数 * 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用线程处理Callable任务。</span></span><br><span class="line">        Future&lt;String&gt; f1 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>));</span><br><span class="line">        Future&lt;String&gt; f2 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>));</span><br><span class="line">        Future&lt;String&gt; f3 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">300</span>));</span><br><span class="line">        Future&lt;String&gt; f4 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">400</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(f1.get());</span><br><span class="line">        System.out.println(f2.get());</span><br><span class="line">        System.out.println(f3.get());</span><br><span class="line">        System.out.println(f4.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Executors创建线程池这么好用，为什么不推荐使用呢？原因在这里：看下图，这是《阿里巴巴Java开发手册》提供的强制规范要求。</p>
<p><img src="https://s2.loli.net/2024/05/07/eoCUEtpgwuRkFNq.webp" alt="1668068399363"></p>
<h2 id="六、补充知识（理解即可）">六、补充知识（理解即可）</h2>
<h3 id="6-1-并发和并行">6.1 并发和并行</h3>
<p>先学习第一个补充知识点，并发和并行。在讲解并发和并行的含义之前，我们先来了解一下什么是进程、线程？</p>
<ul>
<li>正常运行的程序（软件）就是一个独立的进程</li>
<li>线程是属于进程，一个进程中包含多个线程</li>
<li>进程中的线程其实并发和并行同时存在（继续往下看）</li>
</ul>
<p>我们可以打开系统的任务管理器看看（快捷键：Ctrl+Shfit+Esc），自己的电脑上目前有哪些进程。</p>
<p><img src="https://s2.loli.net/2024/05/07/EbA8ukr5tGyPvwH.webp" alt="1668069176927"></p>
<p>知道了什么是进程和线程之后，接着我们再来学习并发和并行的含义。</p>
<p><strong>首先，来学习一下什么是并发？</strong></p>
<p>进程中的线程由CPU负责调度执行，但是CPU同时处理线程的数量是优先的，为了保证全部线程都能执行到，CPU采用轮询机制为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。（简单记：并发就是多条线程交替执行）</p>
<p><strong>接下，再来学习一下什么是并行？</strong></p>
<p>并行指的是，多个线程同时被CPU调度执行。如下图所示，多个CPU核心在执行多条线程</p>
<p><img src="https://s2.loli.net/2024/05/07/CwaJBS2N8iPLMTx.webp" alt="1668069524799"></p>
<p><strong>最后一个问题，多线程到底是并发还是并行呢？</strong></p>
<p>其实多个线程在我们的电脑上执行，并发和并行是同时存在的。</p>
<h3 id="6-2-线程的生命周期">6.2 线程的生命周期</h3>
<p>接下来，我们学习最后一个有关线程的知识点，叫做线程的生命周期。所谓生命周期就是线程从生到死的过程中间有哪些状态，以及这些状态之间是怎么切换的。</p>
<p>为了让大家同好的理解线程的生命周期，先用人的生命周期举个例子，人从生到死有下面的几个过程。在人的生命周期过程中，各种状态之间可能会有切换，线程也是一样的。</p>
<p><img src="https://s2.loli.net/2024/05/07/VgHFv7ZbsjyoIdX.webp" alt="1668069740969"></p>
<p>接下来就来学习线程的生命周期。在Thread类中有一个嵌套的枚举类叫Thread.Status，这里面定义了线程的6中状态。如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/07/2zXAoIrup9ERs5S.webp" alt="1668069923403"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NEW: 新建状态，线程还没有启动</span><br><span class="line">RUNNABLE: 可以运行状态，线程调用了start()方法后处于这个状态</span><br><span class="line">BLOCKED: 锁阻塞状态，没有获取到锁处于这个状态</span><br><span class="line">WAITING: 无限等待状态，线程执行时被调用了wait方法处于这个状态</span><br><span class="line">TIMED_WAITING: 计时等待状态，线程执行时被调用了sleep(毫秒)或者wait(毫秒)方法处于这个状态</span><br><span class="line">TERMINATED: 终止状态, 线程执行完毕或者遇到异常时，处于这个状态。</span><br></pre></td></tr></table></figure>
<p>这几种状态之间切换关系如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/07/gaC2MSkjTY45VcQ.webp" alt="1668070204768"></p>
<h1 id="网络编程">网络编程</h1>
<h2 id="一、网络编程概述">一、网络编程概述</h2>
<p>网络通信的基本架构。通信的基本架构主要有两种形式：一种是CS架构（Client 客户端/Server服务端）、一种是BS架构（Brower 浏览器/Server服务端）。</p>
<ul>
<li>**CS架构的特点：**CS架构需要用户在自己的电脑或者手机上安装客户端软件，然后由客户端软件通过网络连接服务器程序，由服务器把数据发给客户端，客户端就可以在页面上看到各种数据了。</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/07/PTOj61lArMiY8FV.webp" alt="1668262460269"></p>
<ul>
<li>
<p>**BS架构的特点：**BS架构不需要开发客户端软件，用户只需要通过浏览器输入网址就可以直接从服务器获取数据，并由服务器将数据返回给浏览器，用户在页面上就可以看到各种数据了。</p>
<p><img src="https://s2.loli.net/2024/05/07/MqJurmwn7BS3z1L.webp" alt="1668262589242"></p>
</li>
</ul>
<p>这两种结构不管是CS、还是BS都是需要用到网络编程的相关技术。我们学习Java的程序员，以后从事的工作方向主要还是BS架构的。</p>
<h2 id="二、网络编程三要素">二、网络编程三要素</h2>
<p>有哪三要素呢？分别是IP地址、端口号、通信协议</p>
<p><img src="https://s2.loli.net/2024/05/07/g6jTIxVaWZP7CSM.webp" alt="1668262831222"></p>
<ol>
<li>
<p>IP地址：表示设备在网络中的地址，是网络中设备的唯一标识</p>
</li>
<li>
<p>端口号：应用程序在设备中唯一的标识</p>
</li>
<li>
<p>协议：连接和数据在网络中传输的规则。</p>
</li>
</ol>
<p>如下图所示：假设现在要从一台电脑中的微信上，发一句“你愁啥？”到其他电脑的微信上，流程如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>先通过ip地址找到对方的电脑</span><br><span class="line"><span class="number">2.</span>再通过端口号找到对方的电脑上的应用程序</span><br><span class="line"><span class="number">3.</span>按照双方约定好的规则发送、接收数据</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/05/07/aviVYC4zBP3JfIm.webp" alt="1668263019076"></p>
<h3 id="2-1-IP地址">2.1 IP地址</h3>
<p>**IP（Ineternet Protocol）全称互联网协议地址，是分配给网络设备的唯一表示。**IP地址分为：IPV4地址、IPV6地址</p>
<p>IPV4地址由32个比特位（4个字节）组成，如果下图所示，但是由于采用二进制太不容易阅读了，于是就将每8位看成一组，把每一组用十进制表示（叫做点分十进制表示法）。所以就有了我们经常看到的IP地址形式，如：192.168.1.66</p>
<p><img src="https://s2.loli.net/2024/05/07/lHBzItsivT3o7PN.webp" alt="1668263179793"></p>
<p>如果想查看本机的IP地址，可以在命令行窗口，输入<code>ipconfig</code>命令查看，如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/07/Ym7w4MuF1X3yLr6.webp" alt="1668263481919"></p>
<p>经过不断的发展，现在越来越多的设备需要联网，IPV4地址已经不够用了，所以扩展出来了IPV6地址。</p>
<p>IPV6采用128位二进制数据来表示（16个字节），号称可以为地球上的每一粒沙子编一个IP地址，</p>
<p>IPV6比较长，为了方便阅读，每16位编成一组，每组采用十六进制数据表示，然后用冒号隔开（称为冒分十六进制表示法），如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/07/of8d3AejJbyxag9.webp" alt="1668263759999"></p>
<p>我们在命令行窗口输入<code>ipconfig</code>命令，同样可以看到ipv6地址，如下图所示</p>
<p><img src="https://s2.loli.net/2024/05/07/Ix9qlg7N8FWyQBZ.webp" alt="1668263881709"></p>
<p>现在的网络设备，一般IPV4和IPV6地址都是支持的。</p>
<hr>
<p>聊完什么是IP地址和IP地址分类之后，接下来再给大家介绍一下和IP地址相关的一个东西，叫做域名。</p>
<p>域名和IP其实是一一对应的，由运营商来管理域名和IP的对应关系。我们在浏览器上敲一个域名时，首先由运营商的域名解析服务，把域名转换为ip地址，再通过IP地址去访问对应的服务器设备。</p>
<p><img src="https://s2.loli.net/2024/05/07/FOG9jbctBPzMDWH.webp" alt="1668264280209"></p>
<p>关于IP地址，还有一个特殊的地址需要我们记住一下。就是我们在学习阶段进行测试时，经常会自己给自己消息，需要用到一个本地回送地址：<code>127.0.0.1</code></p>
<p>最后给同学们介绍，两个和IP地址相关的命令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipconfig: 查看本机的ip地址</span><br><span class="line">pring 域名/ip  检测当前电脑与指定的ip是否连通</span><br></pre></td></tr></table></figure>
<p>ping命令出现以下的提示，说明网络是通过的</p>
<p><img src="https://s2.loli.net/2024/05/07/hszlRGUnViev8by.webp" alt="1668264499362"></p>
<h3 id="2-2-InetAddress类">2.2 InetAddress类</h3>
<p>按照面向对象的设计思想，Java中也有一个类用来表IP地址，这个类是InetAddress类。我们在开发网络通信程序的时候，可能有时候会获取本机的IP地址，以及测试与其他地址是否连通，这个时候就可以使用InetAddress类来完成。下面学习几个InetAddress的方法。</p>
<p><img src="https://s2.loli.net/2024/05/07/5e3Kg8f2iMkUSdA.webp" alt="1668265337659"></p>
<p>演示上面几个方法的效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InetAddressTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、获取本机IP地址对象的</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip1</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        System.out.println(ip1.getHostName());</span><br><span class="line">        System.out.println(ip1.getHostAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、获取指定IP或者域名的IP地址对象。</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        System.out.println(ip2.getHostName());</span><br><span class="line">        System.out.println(ip2.getHostAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ping www.baidu.com</span></span><br><span class="line">        System.out.println(ip2.isReachable(<span class="number">6000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-端口号">2.3 端口号</h3>
<p>端口号：指的是计算机设备上运行的应用程序的标识，被规定为一个16位的二进制数据，范围（0~65535）</p>
<p>端口号分为一下几类（了解一下）</p>
<ul>
<li>周知端口：0~1023，被预先定义的知名应用程序占用（如：HTTP占用80，FTP占用21）</li>
<li>注册端口：1024~49151，分配给用户经常或者某些应用程序</li>
<li>动态端口：49152~65536，之所以称为动态端口，是因为它一般不固定分配给某进程，而是动态分配的。</li>
</ul>
<blockquote>
<p>需要我们注意的是，同一个计算机设备中，不能出现两个应用程序，用同一个端口号</p>
</blockquote>
<h3 id="2-4-协议">2.4 协议</h3>
<p>各位同学，前面我们已经学习了IP地址和端口号，但是想要完成数据通信还需要有通信协议。</p>
<p><strong>网络上通信的设备，事先规定的连接规则，以及传输数据的规则被称为网络通信协议。</strong></p>
<p>为了让世界上各种上网设备能够互联互通，肯定需要有一个组织出来，指定一个规则，大家都遵守这个规则，才能进行数据通信。</p>
<p><img src="https://s2.loli.net/2024/05/07/nfT4yV6uepXzYSo.webp" alt="1668267891624"></p>
<p>只要按照OSI网络参考模型制造的设备，就可以在国际互联网上互联互通。其中传输层有两个协议，是我们今天会接触到的（UDP协议、TCP协议）</p>
<ul>
<li><strong>UDP协议特点</strong></li>
</ul>
<p><img src="https://s2.loli.net/2024/05/07/AV5Q3uKH2nbUfJp.webp" alt="1668268046104"></p>
<ul>
<li><strong>TPC协议特点</strong></li>
</ul>
<p><img src="https://s2.loli.net/2024/05/07/3Pul8We2oOMCbhN.webp" alt="1668268144938"></p>
<p>三次握手如下图所示**：目的是确认通信双方，手法消息都是正常没问题的**</p>
<p><img src="https://s2.loli.net/2024/05/07/9CYgNUeaBAwxO3G.webp" alt="1668268174867"></p>
<p>四次挥手如下图所示：<strong>目的是确保双方数据的收发已经完成，没有数据丢失</strong></p>
<p><img src="https://s2.loli.net/2024/05/07/MLO7RIFskPaqhKz.webp" alt="1668268230804"></p>
<h2 id="三、UDP通信代码（入门案例）">三、UDP通信代码（入门案例）</h2>
<p>UDP是面向无连接的、不需要确认双方是否存在，所以它是不可靠的协议。Java提供了一个类叫DatagramSocket来完成基于UDP协议的收发数据。使用DatagramSocket收发数据时，数据要以数据包的形式体现，一个数据包限制在64KB以内</p>
<p>下面我们看一个案例，需要有两个程序，一个表示客户端程序，一个表示服务端程序。</p>
<p>需求：客户端程序发一个字符串数据给服务端，服务端程序接收数据并打印。</p>
<h3 id="3-1-客户端程序">3.1 客户端程序</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：完成UDP通信快速入门：实现1发1收。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建客户端对象（发韭菜出去的人）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建数据包对象封装要发出去的数据（创建一个韭菜盘子）</span></span><br><span class="line">       <span class="comment">/* public DatagramPacket(byte buf[], int length,</span></span><br><span class="line"><span class="comment">             InetAddress address, int port)</span></span><br><span class="line"><span class="comment">               参数一：封装要发出去的数据。</span></span><br><span class="line"><span class="comment">               参数二：发送出去的数据大小（字节个数）</span></span><br><span class="line"><span class="comment">               参数三：服务端的IP地址（找到服务端主机）</span></span><br><span class="line"><span class="comment">               参数四：服务端程序的端口。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="string">&quot;我是快乐的客户端，我爱你abc&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length</span><br><span class="line">                , InetAddress.getLocalHost(),  <span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、开始正式发送这个数据包的数据出去了</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;客户端数据发送完毕~~~&quot;</span>);</span><br><span class="line">        socket.close(); <span class="comment">// 释放资源！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-服务端程序">3.2 服务端程序</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----服务端启动----&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建一个服务端对象（创建一个接韭菜的人） 注册端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建一个数据包对象，用于接收数据的（创建一个韭菜盘子）</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">64</span>]; <span class="comment">// 64KB.</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、开始正式使用数据包来接收客户端发来的数据</span></span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、从字节数组中，把接收到的数据直接打印出来</span></span><br><span class="line">        <span class="comment">// 接收多少就倒出多少</span></span><br><span class="line">        <span class="comment">// 获取本次数据包接收了多少数据。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> packet.getLength();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> , len);</span><br><span class="line">        System.out.println(rs);</span><br><span class="line"></span><br><span class="line">        System.out.println(packet.getAddress().getHostAddress());</span><br><span class="line">        System.out.println(packet.getPort());</span><br><span class="line"></span><br><span class="line">        socket.close(); <span class="comment">// 释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、UDP通信代码（多发多收）">四、UDP通信代码（多发多收）</h2>
<p>刚才的案例，我们只能客户端发一次，服务端接收一次就结束了。下面我们想把这个代码改进一下，</p>
<p>需求：实现客户端不断的发数据，而服务端能不断的接收数据，客户端发送exit时客户端程序退出。</p>
<h3 id="4-1-客户端程序">4.1 客户端程序</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：完成UDP通信快速入门：实现客户端反复的发。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建客户端对象（发韭菜出去的人）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建数据包对象封装要发出去的数据（创建一个韭菜盘子）</span></span><br><span class="line">       <span class="comment">/* public DatagramPacket(byte buf[], int length,</span></span><br><span class="line"><span class="comment">             InetAddress address, int port)</span></span><br><span class="line"><span class="comment">               参数一：封装要发出去的数据。</span></span><br><span class="line"><span class="comment">               参数二：发送出去的数据大小（字节个数）</span></span><br><span class="line"><span class="comment">               参数三：服务端的IP地址（找到服务端主机）</span></span><br><span class="line"><span class="comment">               参数四：服务端程序的端口。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 一旦发现用户输入的exit命令，就退出客户端</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;exit&quot;</span>.equals(msg))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;欢迎下次光临！退出成功！&quot;</span>);</span><br><span class="line">                socket.close(); <span class="comment">// 释放资源</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 跳出死循环</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] bytes = msg.getBytes();</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length</span><br><span class="line">                    , InetAddress.getLocalHost(),  <span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、开始正式发送这个数据包的数据出去了</span></span><br><span class="line">            socket.send(packet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-服务端程序">4.2 服务端程序</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：完成UDP通信快速入门-服务端反复的收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----服务端启动----&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建一个服务端对象（创建一个接韭菜的人） 注册端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建一个数据包对象，用于接收数据的（创建一个韭菜盘子）</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">64</span>]; <span class="comment">// 64KB.</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 3、开始正式使用数据包来接收客户端发来的数据</span></span><br><span class="line">            socket.receive(packet);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、从字节数组中，把接收到的数据直接打印出来</span></span><br><span class="line">            <span class="comment">// 接收多少就倒出多少</span></span><br><span class="line">            <span class="comment">// 获取本次数据包接收了多少数据。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> packet.getLength();</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> , len);</span><br><span class="line">            System.out.println(rs);</span><br><span class="line"></span><br><span class="line">            System.out.println(packet.getAddress().getHostAddress());</span><br><span class="line">            System.out.println(packet.getPort());</span><br><span class="line">            System.out.println(<span class="string">&quot;--------------------------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、TCP通信（一发一收）">五、TCP通信（一发一收）</h2>
<p>学习完UDP通信的代码编写之后，接下来我们学习TCP通信的代码如何编写。Java提供了一个java.net.Socket类来完成TCP通信。</p>
<p>我们先讲一下Socket完成TCP通信的流程，再讲代码怎么编写就很好理解了。如下图所示</p>
<ol>
<li>当创建Socket对象时，就会在客户端和服务端创建一个数据通信的管道，在客户端和服务端两边都会有一个Socket对象来访问这个通信管道。</li>
<li>现在假设客户端要发送一个“在一起”给服务端，客户端这边先需要通过Socket对象获取到一个字节输出流，通过字节输出流写数据到服务端</li>
<li>然后服务端这边通过Socket对象可以获取字节输入流，通过字节输入流就可以读取客户端写过来的数据，并对数据进行处理。</li>
<li>服务端处理完数据之后，假设需要把“没感觉”发给客户端端，那么服务端这边再通过Socket获取到一个字节输出流，将数据写给客户端</li>
<li>客户端这边再获取输入流，通过字节输入流来读取服务端写过来的数据。</li>
</ol>
<p><img src="https://s2.loli.net/2024/05/07/kUgOLcoIfxhwaMS.webp" alt="1668270124031"></p>
<h3 id="5-1-TCP客户端">5.1 TCP客户端</h3>
<p>下面我们写一个客户端，用来往服务端发数据。由于原始的字节流不是很好用，这里根据我的经验，我原始的OutputStream包装为DataOutputStream是比较好用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：完成TCP通信快速入门-客户端开发：实现1发1收。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建Socket对象，并同时请求与服务端程序的连接。</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、从socket通信管道中得到一个字节输出流，用来发数据给服务端程序。</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、把低级的字节输出流包装成数据输出流</span></span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、开始写数据出去了</span></span><br><span class="line">        dos.writeUTF(<span class="string">&quot;在一起，好吗？&quot;</span>);</span><br><span class="line">        dos.close();</span><br><span class="line"></span><br><span class="line">        socket.close(); <span class="comment">// 释放连接资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-TCP服务端">5.2 TCP服务端</h3>
<p>上面我们只是写了TCP客户端，还没有服务端，接下来我们把服务端写一下。这里的服务端用来接收客户端发过来的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：完成TCP通信快速入门-服务端开发：实现1发1收。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----服务端启动成功-------&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建ServerSocket的对象，同时为服务端注册端口。</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、从socket通信管道中得到一个字节输入流。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、把原始的字节输入流包装成数据输入流</span></span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、使用数据输入流读取客户端发送过来的消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">        System.out.println(rs);</span><br><span class="line">        <span class="comment">// 其实我们也可以获取客户端的IP地址</span></span><br><span class="line">        System.out.println(socket.getRemoteSocketAddress());</span><br><span class="line"></span><br><span class="line">        dis.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、TCP通信（多发多收）">六、TCP通信（多发多收）</h2>
<p>到目前为止，我们已经完成了客户端发送消息、服务端接收消息，但是客户端只能发一次，服务端只能接收一次。现在我想要客户端能过一直发消息，服务端能够一直接收消息。</p>
<p>下面我们把客户端代码改写一下，采用键盘录入的方式发消息，为了让客户端能够一直发，我们只需要将发送消息的代码套一层循环就可以了，当用户输入exit时，客户端退出循环并结束客户端。</p>
<h3 id="6-1-TCP客户端">6.1 TCP客户端</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：完成TCP通信快速入门-客户端开发：实现客户端可以反复的发消息出去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建Socket对象，并同时请求与服务端程序的连接。</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、从socket通信管道中得到一个字节输出流，用来发数据给服务端程序。</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、把低级的字节输出流包装成数据输出流</span></span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 一旦用户输入了exit，就退出客户端程序</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;exit&quot;</span>.equals(msg))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;欢迎您下次光临！退出成功！&quot;</span>);</span><br><span class="line">                dos.close();</span><br><span class="line">                socket.close();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、开始写数据出去了</span></span><br><span class="line">            dos.writeUTF(msg);</span><br><span class="line">            dos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-TCP服务端">6.2 TCP服务端</h3>
<p>为了让服务端能够一直接收客户端发过来的消息，服务端代码也得改写一下。我们只需要将读取数据的代码加一个循环就可以了。</p>
<p>但是需要我们注意的时，如果客户端Socket退出之后，就表示连接客户端与服务端的数据通道被关闭了，这时服务端就会出现异常。服务端可以通过出异常来判断客户端下线了，所以可以用try…catch把读取客户端数据的代码套一起来，catch捕获到异常后，打印客户端下线。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：完成TCP通信快速入门-服务端开发：实现服务端反复发消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----服务端启动成功-------&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建ServerSocket的对象，同时为服务端注册端口。</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、从socket通信管道中得到一个字节输入流。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、把原始的字节输入流包装成数据输入流</span></span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 5、使用数据输入流读取客户端发送过来的消息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">                System.out.println(rs);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;离线了！&quot;</span>);</span><br><span class="line">                dis.close();</span><br><span class="line">                socket.close();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七、TCP通信（多线程改进）">七、TCP通信（多线程改进）</h2>
<p>上一个案例中我们写的服务端程序只能和一个客户端通信，如果有多个客户端连接服务端，此时服务端是不支持的。</p>
<p>为了让服务端能够支持多个客户端通信，就需要用到多线程技术。具体的实现思路如下图所示：每当有一个客户端连接服务端，在服务端这边就为Socket开启一条线程取执行读取数据的操作，来多少个客户端，就有多少条线程。按照这样的设计，服务端就可以支持多个客户端连接了。</p>
<p><img src="https://s2.loli.net/2024/05/07/F5sXP2YQL7o8reh.webp" alt="1668315156739"></p>
<p>按照上面的思路，改写服务端代码。</p>
<h3 id="7-1-多线程改进">7.1 多线程改进</h3>
<p>首先，我们需要写一个服务端的读取数据的线程类，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;有人下线了：&quot;</span> + socket.getRemoteSocketAddress());</span><br><span class="line">                    dis.close();</span><br><span class="line">                    socket.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，再改写服务端的主程序代码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：完成TCP通信快速入门-服务端开发：要求实现与多个客户端同时通信。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----服务端启动成功-------&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建ServerSocket的对象，同时为服务端注册端口。</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;有人上线了：&quot;</span> + socket.getRemoteSocketAddress());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServerReaderThread</span>(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-案例拓展（群聊）">7.2 案例拓展（群聊）</h3>
<p>接着前面的案例，下面我们案例再次拓展一下，这个并不需要同学们必须掌握，主要是为了锻炼同学们的编程能力、和编程思维。</p>
<p>我们想把刚才的案例，改进成全能够实现群聊的效果，就是一个客户端发的消息，其他的每一个客户端都可以收到。</p>
<p>刚才我们写的多个客户端可以往服务端发现消息，但是客户端和客户端是不能直接通信的。想要试下全群聊的效果，我们还是必须要有服务端在中间做中转。 具体实现方案如下图所示：</p>
<p>我们可以在服务端创建一个存储Socket的集合，每当一个客户端连接服务端，就可以把客户端Socket存储起来；当一个客户端给服务端发消息时，再遍历集合通过每个Socket将消息再转发给其他客户端。</p>
<p><img src="https://s2.loli.net/2024/05/07/pAXBamqhS4j3RUL.webp" alt="1668315820569"></p>
<p>下面我们改造服务端代码，由于服务端读取数据是在线程类中完成的，所以我们改<code>SerReaderThread</code>类就可以了。服务端的主程序不用改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                    <span class="comment">// 把这个消息分发给全部客户端进行接收。</span></span><br><span class="line">                    sendMsgToAll(msg);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;有人下线了：&quot;</span> + socket.getRemoteSocketAddress());</span><br><span class="line">                    Server.onLineSockets.remove(socket);</span><br><span class="line">                    dis.close();</span><br><span class="line">                    socket.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMsgToAll</span><span class="params">(String msg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 发送给全部在线的socket管道接收。</span></span><br><span class="line">        <span class="keyword">for</span> (Socket onLineSocket : Server.onLineSockets) &#123;</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> onLineSocket.getOutputStream();</span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line">            dos.writeUTF(msg);</span><br><span class="line">            dos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="八、BS架构程序（简易版）">八、BS架构程序（简易版）</h2>
<p>前面我们所写的代码都是基于CS架构的。我们说网络编程还可以编写BS架构的程序，为了让同学们体验一下BS架构通信，这里我们写一个简易版的程序。仅仅只是体验下一，后期我们会详细学习BS架构的程序如何编写。</p>
<p>BS架构程序的实现原理，如下图所示：不需要开发客户端程序，此时浏览器就相当于是客户端，此时我们只需要写服务端程序就可以了。</p>
<p><img src="https://s2.loli.net/2024/05/07/S8uqw4MBZU2xrc3.webp" alt="1668316417640"></p>
<p>在BS结构的程序中，浏览器和服务器通信是基于HTTP协议来完成的，浏览器给客户端发送数据需要按照HTTP协议规定好的数据格式发给服务端，服务端返回数据时也需要按照HTTP协议规定好的数据给是发给浏览器，只有这两双方才能完成一次数据交互。</p>
<p>客户端程序不需要我们编写（浏览器就是），所以我们只需要写服务端就可以了。</p>
<p>服务端给客户端响应数据的数据格式（HTTP协议规定数据格式）如下图所示：左图是数据格式，右图是示例。</p>
<p><img src="https://s2.loli.net/2024/05/07/8SXpue6n1bhywkC.webp" alt="1668316630797"></p>
<p>接下来，我们写一个服务端程序按照右图示例的样子，给浏览器返回数据。<strong>注意：数据是由多行组成的，必须按照规定的格式来写。</strong></p>
<h3 id="8-1-服务端程序">8.1 服务端程序</h3>
<p>先写一个线程类，用于按照HTTP协议的格式返回数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//  立即响应一个网页内容：“黑马程序员”给浏览器展示。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">            ps.println(<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>);</span><br><span class="line">            ps.println(<span class="string">&quot;Content-Type:text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">            ps.println(); <span class="comment">// 必须换行</span></span><br><span class="line">            ps.println(<span class="string">&quot;&lt;div style=&#x27;color:red;font-size:120px;text-align:center&#x27;&gt;黑马程序员666&lt;div&gt;&quot;</span>);</span><br><span class="line">            ps.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再写服务端的主程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：完成TCP通信快速入门-服务端开发：要求实现与多个客户端同时通信。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----服务端启动成功-------&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建ServerSocket的对象，同时为服务端注册端口。</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;有人上线了：&quot;</span> + socket.getRemoteSocketAddress());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServerReaderThread</span>(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-2-服务端主程序用线程池改进">8.2 服务端主程序用线程池改进</h3>
<p>为了避免服务端创建太多的线程，可以把服务端用线程池改进，提高服务端的性能。</p>
<p>先写一个给浏览器响应数据的线程任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderRunnable</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//  立即响应一个网页内容：“黑马程序员”给浏览器展示。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">            ps.println(<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>);</span><br><span class="line">            ps.println(<span class="string">&quot;Content-Type:text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">            ps.println(); <span class="comment">// 必须换行</span></span><br><span class="line">            ps.println(<span class="string">&quot;&lt;div style=&#x27;color:red;font-size:120px;text-align:center&#x27;&gt;黑马程序员666&lt;div&gt;&quot;</span>);</span><br><span class="line">            ps.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再改写服务端的主程序，使用ThreadPoolExecutor创建一个线程池，每次接收到一个Socket就往线程池中提交任务就行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----服务端启动成功-------&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建ServerSocket的对象，同时为服务端注册端口。</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建出一个线程池，负责处理通信管道的任务。</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">16</span> * <span class="number">2</span>, <span class="number">16</span> * <span class="number">2</span>, <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">8</span>) , Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。</span></span><br><span class="line">            pool.execute(<span class="keyword">new</span> <span class="title class_">ServerReaderRunnable</span>(socket));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>Java基础</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://blog.xing-ye.top/posts/Java/">https://blog.xing-ye.top/posts/Java/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>XINGYE</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-02-09</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-06-23</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>Java</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://xingye-blog.s3.bitiful.net/WePay.webp" target="_blank"><img class="post-qr-code-img" src="https://xingye-blog.s3.bitiful.net/WePay.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://xingye-blog.s3.bitiful.net/AliPay.webp" target="_blank"><img class="post-qr-code-img" src="https://xingye-blog.s3.bitiful.net/AliPay.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/posts/MySQL/"><img class="prev-cover" src="https://xingye-blog.s3.bitiful.net/2024/06/64bdadc3e711cb518968411a402b3d3e.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL基础篇笔记</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Twikoo</span><span class="switch-btn"></span><span class="second-comment">Giscus</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%EF%BC%88%E4%B8%80%EF%BC%89"><span class="toc-text">面向对象高级（一）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%9D%99%E6%80%81"><span class="toc-text">一、静态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-static%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">1.1 static修饰成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-static%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">1.2 static修饰成员变量的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-static%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">1.3 static修饰成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">1.4 工具类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-static%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">1.5 static的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-static%E5%BA%94%E7%94%A8%EF%BC%88%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89"><span class="toc-text">1.6 static应用（代码块）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BB%A7%E6%89%BF"><span class="toc-text">二、继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%BB%A7%E6%89%BF"><span class="toc-text">2.1 继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">2.2 继承的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">2.3 权限修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%8D%95%E7%BB%A7%E6%89%BF%E3%80%81Object"><span class="toc-text">2.4 单继承、Object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-text">2.5 方法重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%AD%90%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">2.6 子类中访问成员的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E5%AD%90%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">2.7 子类中访问构造器的特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="toc-text">面向对象高级（二）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%A4%9A%E6%80%81"><span class="toc-text">一、多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%A4%9A%E6%80%81%E6%A6%82%E8%BF%B0"><span class="toc-text">1.1 多态概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">1.2 多态的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">1.3 类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">二、final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-final%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">2.1 final修饰符的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%EF%BC%9A%E5%B8%B8%E9%87%8F"><span class="toc-text">2.2 补充知识：常量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%8A%BD%E8%B1%A1"><span class="toc-text">三、抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%AE%A4%E8%AF%86%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">3.1 认识抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">3.2 抽象类的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-text">3.3 模板方法模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%8E%A5%E5%8F%A3"><span class="toc-text">四、接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%AE%A4%E8%AF%86%E6%8E%A5%E5%8F%A3"><span class="toc-text">4.1 认识接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">4.2 接口的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="toc-text">4.3 接口的案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E6%8E%A5%E5%8F%A3JDK8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">4.4 接口JDK8的新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B6%E4%BB%96%E7%BB%86%E8%8A%82"><span class="toc-text">4.5 接口的其他细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%EF%BC%88%E4%B8%89%EF%BC%89"><span class="toc-text">面向对象高级（三）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">一、内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">1.1 成员内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">1.2 静态内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">1.3 局部内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">1.4 匿名内部类*</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%9E%9A%E4%B8%BE"><span class="toc-text">二、枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%AE%A4%E8%AF%86%E6%9E%9A%E4%B8%BE"><span class="toc-text">2.1 认识枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2.2 枚举的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="toc-text">三、泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B"><span class="toc-text">3.1 认识泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-text">3.2 自定义泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-text">3.3 自定义泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">3.4 泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E6%B3%9B%E5%9E%8B%E9%99%90%E5%AE%9A"><span class="toc-text">3.5 泛型限定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-text">3.6 泛型擦除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B8%B8%E7%94%A8API"><span class="toc-text">四、常用API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Object%E7%B1%BB"><span class="toc-text">4.1 Object类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Objects%E7%B1%BB"><span class="toc-text">4.2 Objects类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">4.3 基本类型包装类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8API"><span class="toc-text">常用API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81-StringBuilder%E7%B1%BB"><span class="toc-text">一、 StringBuilder类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81StringJoiner%E7%B1%BB"><span class="toc-text">二、StringJoiner类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Math%E7%B1%BB"><span class="toc-text">三、Math类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-System%E7%B1%BB"><span class="toc-text">四、 System类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Runtime%E7%B1%BB"><span class="toc-text">五、Runtime类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81BigDecimal%E7%B1%BB"><span class="toc-text">六、BigDecimal类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Date%E7%B1%BB"><span class="toc-text">五、Date类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81SimpleDateFormat%E7%B1%BB"><span class="toc-text">六、SimpleDateFormat类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81Calendar%E7%B1%BB"><span class="toc-text">七、Calendar类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88JDK8%E8%A6%81%E6%96%B0%E5%A2%9E%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-text">八、为什么JDK8要新增日期类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81JDK8%E6%97%A5%E6%9C%9F%E3%80%81%E6%97%B6%E9%97%B4%E3%80%81%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-text">九、JDK8日期、时间、日期时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81JDK8%E6%97%A5%E6%9C%9F%EF%BC%88%E6%97%B6%E5%8C%BA%EF%BC%89"><span class="toc-text">十、JDK8日期（时区）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81JDK8%E6%97%A5%E6%9C%9F%EF%BC%88Instant%E7%B1%BB%EF%BC%89"><span class="toc-text">十一、JDK8日期（Instant类）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81JDK8%E6%97%A5%E6%9C%9F%EF%BC%88%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%99%A8%EF%BC%89"><span class="toc-text">十二、JDK8日期（格式化器）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81JDK8%E6%97%A5%E6%9C%9F%EF%BC%88Period%E7%B1%BB%EF%BC%89"><span class="toc-text">十三、JDK8日期（Period类）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81JDK8%E6%97%A5%E6%9C%9F%EF%BC%88Duration%E7%B1%BB%EF%BC%89"><span class="toc-text">十四、JDK8日期（Duration类）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lambda%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">Lambda、方法引用、正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">一、Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">1.1 Lambda表达式基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9C%81%E7%95%A5%E8%A7%84%E5%88%99"><span class="toc-text">1.2 Lambda表达式省略规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81JDK8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%89"><span class="toc-text">二、JDK8新特性（方法引用）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">2.1 静态方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">2.2 实例方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%89%B9%E5%AE%9A%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">2.3 特定类型的方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-text">2.4 构造器引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">三、正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%9D%E4%BD%93%E9%AA%8C"><span class="toc-text">3.1 正则表达式初体验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B9%A6%E5%86%99%E8%A7%84%E5%88%99"><span class="toc-text">3.2 正则表达式书写规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">3.3 正则表达式应用案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BF%A1%E6%81%AF%E7%88%AC%E5%8F%96"><span class="toc-text">3.4 正则表达式信息爬取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%90%9C%E7%B4%A2%E3%80%81%E6%9B%BF%E6%8D%A2"><span class="toc-text">3.5 正则表达式搜索、替换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E3%80%81%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6"><span class="toc-text">异常、集合进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%BC%82%E5%B8%B8"><span class="toc-text">一、异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E8%AE%A4%E8%AF%86%E5%BC%82%E5%B8%B8"><span class="toc-text">1.1 认识异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-text">1.2 自定义异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">1.3 异常处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-text">二、集合概述和分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%9B%86%E5%90%88%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">2.1 集合的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Collection%E9%9B%86%E5%90%88%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">2.2 Collection集合的常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Collection%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-text">三、Collection遍历方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88"><span class="toc-text">3.1 迭代器遍历集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%A2%9E%E5%BC%BAfor%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88"><span class="toc-text">3.2 增强for遍历集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-forEach%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88"><span class="toc-text">3.3 forEach遍历集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81List%E7%B3%BB%E5%88%97%E9%9B%86%E5%90%88"><span class="toc-text">四、List系列集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-List%E9%9B%86%E5%90%88%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">4.1 List集合的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-List%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-text">4.2 List集合的遍历方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-ArrayList%E5%BA%95%E5%B1%82%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">4.3 ArrayList底层的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-LinkedList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">4.4 LinkedList底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-LinkedList%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">4.5 LinkedList集合的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Set%E7%B3%BB%E5%88%97%E9%9B%86%E5%90%88"><span class="toc-text">五、Set系列集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E8%AE%A4%E8%AF%86Set%E9%9B%86%E5%90%88%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">5.1 认识Set集合的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-HashSet%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">5.2 HashSet集合底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-HashSet%E5%8E%BB%E9%87%8D%E5%8E%9F%E7%90%86"><span class="toc-text">5.3 HashSet去重原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-LinkedHashSet%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">5.4 LinkedHashSet底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-TreeSet%E9%9B%86%E5%90%88"><span class="toc-text">5.5 TreeSet集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E6%80%BB%E7%BB%93Collection%E9%9B%86%E5%90%88"><span class="toc-text">5.6 总结Collection集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8"><span class="toc-text">5.7 并发修改异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Collection%E7%9A%84%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C"><span class="toc-text">六、Collection的其他操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-text">6.1 可变参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">6.2 Collections工具类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81Map%E9%9B%86%E5%90%88"><span class="toc-text">七、Map集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-Map%E6%A6%82%E8%BF%B0%E4%BD%93%E7%B3%BB"><span class="toc-text">7.1 Map概述体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-Map%E9%9B%86%E5%90%88%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">7.2 Map集合的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F1"><span class="toc-text">7.2.1 Map集合遍历方式1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F2"><span class="toc-text">7.2.2 Map集合遍历方式2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F3"><span class="toc-text">7.2.3 Map集合遍历方式3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-HashMap"><span class="toc-text">7.3 HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-LinkedHashMap"><span class="toc-text">7.4 LinkedHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-TreeMap"><span class="toc-text">7.5 TreeMap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Stream%E6%B5%81%E3%80%81File%E7%B1%BB"><span class="toc-text">Stream流、File类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81JDK8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88Stream%E6%B5%81%EF%BC%89"><span class="toc-text">一、JDK8新特性（Stream流）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Stream%E6%B5%81%E4%BD%93%E9%AA%8C"><span class="toc-text">1.1 Stream流体验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Stream%E6%B5%81%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">1.2 Stream流的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Stream%E6%B5%81%E4%B8%AD%E9%97%B4%E6%96%B9%E6%B3%95"><span class="toc-text">1.3 Stream流中间方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-Stream%E6%B5%81%E7%BB%88%E7%BB%93%E6%96%B9%E6%B3%95"><span class="toc-text">1.4 Stream流终结方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81File%E7%B1%BB"><span class="toc-text">二、File类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-File%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">2.1 File对象的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-File%E5%88%A4%E6%96%AD%E5%92%8C%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95"><span class="toc-text">2.2 File判断和获取方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95"><span class="toc-text">2.3 创建和删除方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E5%A4%B9%E6%96%B9%E6%B3%95"><span class="toc-text">2.4 遍历文件夹方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E9%80%92%E5%BD%92%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2"><span class="toc-text">2.5 递归文件搜索</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86%E3%80%81IO%E6%B5%81-%E4%B8%80"><span class="toc-text">字符集、IO流(一)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-text">一、字符集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%AD%97%E7%AC%A6%E9%9B%86%E7%9A%84%E6%9D%A5%E5%8E%86"><span class="toc-text">1.1 字符集的来历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%B1%89%E5%AD%97%E5%92%8C%E5%AD%97%E6%AF%8D%E7%9A%84%E7%BC%96%E7%A0%81%E7%89%B9%E7%82%B9"><span class="toc-text">1.2 汉字和字母的编码特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Unicode%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-text">1.3 Unicode字符集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%AD%97%E7%AC%A6%E9%9B%86%E5%B0%8F%E7%BB%93"><span class="toc-text">1.4 字符集小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81"><span class="toc-text">1.5 编码和解码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81IO%E6%B5%81%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81%EF%BC%89"><span class="toc-text">二、IO流（字节流）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-IO%E6%B5%81%E6%A6%82%E8%BF%B0"><span class="toc-text">2.1 IO流概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-FileInputStream%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82"><span class="toc-text">2.2 FileInputStream读取一个字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-FileInputStream%E8%AF%BB%E5%8F%96%E5%A4%9A%E4%B8%AA%E5%AD%97%E8%8A%82"><span class="toc-text">2.3 FileInputStream读取多个字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-FileInputStream%E8%AF%BB%E5%8F%96%E5%85%A8%E9%83%A8%E5%AD%97%E8%8A%82"><span class="toc-text">2.4 FileInputStream读取全部字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-FileOutputStream%E5%86%99%E5%AD%97%E8%8A%82"><span class="toc-text">2.5 FileOutputStream写字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%AD%97%E8%8A%82%E6%B5%81%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-text">2.6 字节流复制文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81IO%E6%B5%81%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE"><span class="toc-text">三、IO流资源释放</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-JDK7%E4%BB%A5%E5%89%8D%E7%9A%84%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE"><span class="toc-text">3.1 JDK7以前的资源释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-JDK7%E4%BB%A5%E5%90%8E%E7%9A%84%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE"><span class="toc-text">3.2 JDK7以后的资源释放</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO%E6%B5%81%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="toc-text">IO流（二）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-text">一、字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-FileReader%E7%B1%BB"><span class="toc-text">1.1 FileReader类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-FileWriter%E7%B1%BB"><span class="toc-text">1.2 FileWriter类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-FileWriter%E5%86%99%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">1.3 FileWriter写的注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">二、缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%BC%93%E5%86%B2%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-text">2.1 缓冲字节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">2.2 字符缓冲流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%BC%93%E5%86%B2%E6%B5%81%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">2.3 缓冲流性能分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-text">三、转换流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-InputStreamReader%E7%B1%BB"><span class="toc-text">3.1 InputStreamReader类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-OutputStreamWriter%E7%B1%BB"><span class="toc-text">3.2 OutputStreamWriter类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-text">四、打印流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%89%93%E5%8D%B0%E6%B5%81%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">4.1 打印流基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5"><span class="toc-text">4.2 重定向输出语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-text">五、数据流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-DataOutputStream%E7%B1%BB"><span class="toc-text">5.1 DataOutputStream类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-DataInputStream%E7%B1%BB"><span class="toc-text">5.2 DataInputStream类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81"><span class="toc-text">六、序列化流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-ObjectOutputStraem%E7%B1%BB"><span class="toc-text">6.1 ObjectOutputStraem类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-ObjectInputStream%E7%B1%BB"><span class="toc-text">6.2 ObjectInputStream类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%EF%BC%9AIO%E6%A1%86%E6%9E%B6"><span class="toc-text">七、补充知识：IO框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E3%80%81%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF"><span class="toc-text">特殊文件、日志技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6"><span class="toc-text">一、属性文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">1.1 特殊文件概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Properties%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6"><span class="toc-text">1.2 Properties属性文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81XML%E6%96%87%E4%BB%B6"><span class="toc-text">二、XML文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-XML%E6%96%87%E4%BB%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">2.1 XML文件概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-XML%E8%A7%A3%E6%9E%901"><span class="toc-text">2.2 XML解析1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-XML%E8%A7%A3%E6%9E%902"><span class="toc-text">2.3 XML解析2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-XML%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5"><span class="toc-text">2.4 XML文件写入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-XML%E7%BA%A6%E6%9D%9F%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">2.5 XML约束（了解）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF"><span class="toc-text">三、日志技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%97%A5%E5%BF%97%E6%A6%82%E8%BF%B0"><span class="toc-text">3.1 日志概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%97%A5%E5%BF%97%E7%9A%84%E4%BD%93%E7%B3%BB"><span class="toc-text">3.2 日志的体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Logback%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">3.3 Logback快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">3.4 日志配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB"><span class="toc-text">3.5 配置日志级别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">一、多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F1"><span class="toc-text">1.1 线程创建方式1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F2"><span class="toc-text">1.2 线程创建方式2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F2%E2%80%94%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">1.3 线程创建方式2—匿名内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F3"><span class="toc-text">1.4 线程的创建方式3</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">二、多线程常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">三、线程安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E6%A6%82%E8%BF%B0"><span class="toc-text">3.1 线程安全问题概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-text">3.2 线程安全问题的代码演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88"><span class="toc-text">3.3 线程同步方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">3.4 同步代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-text">3.5 同步方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-Lock%E9%94%81"><span class="toc-text">3.6 Lock锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">四、线程通信（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">五、线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E8%BF%B0"><span class="toc-text">5.1 线程池概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">5.2 创建线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8CRunnable%E4%BB%BB%E5%8A%A1"><span class="toc-text">5.3 线程池执行Runnable任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8CCallable%E4%BB%BB%E5%8A%A1"><span class="toc-text">5.4 线程池执行Callable任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%88Executors%EF%BC%89"><span class="toc-text">5.5 线程池工具类（Executors）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%EF%BC%88%E7%90%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="toc-text">六、补充知识（理解即可）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-text">6.1 并发和并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">6.2 线程的生命周期</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-text">一、网络编程概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-text">二、网络编程三要素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-IP%E5%9C%B0%E5%9D%80"><span class="toc-text">2.1 IP地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-InetAddress%E7%B1%BB"><span class="toc-text">2.2 InetAddress类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">2.3 端口号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%8D%8F%E8%AE%AE"><span class="toc-text">2.4 协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81UDP%E9%80%9A%E4%BF%A1%E4%BB%A3%E7%A0%81%EF%BC%88%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B%EF%BC%89"><span class="toc-text">三、UDP通信代码（入门案例）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A8%8B%E5%BA%8F"><span class="toc-text">3.1 客户端程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A8%8B%E5%BA%8F"><span class="toc-text">3.2 服务端程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81UDP%E9%80%9A%E4%BF%A1%E4%BB%A3%E7%A0%81%EF%BC%88%E5%A4%9A%E5%8F%91%E5%A4%9A%E6%94%B6%EF%BC%89"><span class="toc-text">四、UDP通信代码（多发多收）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A8%8B%E5%BA%8F"><span class="toc-text">4.1 客户端程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A8%8B%E5%BA%8F"><span class="toc-text">4.2 服务端程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81TCP%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%E5%8F%91%E4%B8%80%E6%94%B6%EF%BC%89"><span class="toc-text">五、TCP通信（一发一收）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-TCP%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">5.1 TCP客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-TCP%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">5.2 TCP服务端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81TCP%E9%80%9A%E4%BF%A1%EF%BC%88%E5%A4%9A%E5%8F%91%E5%A4%9A%E6%94%B6%EF%BC%89"><span class="toc-text">六、TCP通信（多发多收）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-TCP%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">6.1 TCP客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-TCP%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">6.2 TCP服务端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81TCP%E9%80%9A%E4%BF%A1%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%B9%E8%BF%9B%EF%BC%89"><span class="toc-text">七、TCP通信（多线程改进）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%B9%E8%BF%9B"><span class="toc-text">7.1 多线程改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%A1%88%E4%BE%8B%E6%8B%93%E5%B1%95%EF%BC%88%E7%BE%A4%E8%81%8A%EF%BC%89"><span class="toc-text">7.2 案例拓展（群聊）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81BS%E6%9E%B6%E6%9E%84%E7%A8%8B%E5%BA%8F%EF%BC%88%E7%AE%80%E6%98%93%E7%89%88%EF%BC%89"><span class="toc-text">八、BS架构程序（简易版）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A8%8B%E5%BA%8F"><span class="toc-text">8.1 服务端程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%BB%E7%A8%8B%E5%BA%8F%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%94%B9%E8%BF%9B"><span class="toc-text">8.2 服务端主程序用线程池改进</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/site/echarts/">文章统计</a><a href="/site/time/">建站日志</a></li><li><a href="/personal/essay/">即刻说说</a><a href="/personal/about/">关于本站</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a href="https://blog.xing-ye.top/" title="XINGYE's Blog"><img src="https://xingye-blog.s3.bitiful.net/avatar.webp" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src="	https://www.fomal.cc/assets/avatar.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2024</b></span><span><b>&nbsp;&nbsp;By XINGYE</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><!--a.github-badge(target='_blank' href="https://user.51.la/" style='margin-inline:5px' title="本站数据分析得益于51la技术支持")img(src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt='')
--><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20246966" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20246966号"><img src="https://img.shields.io/badge/%E8%90%8CICP%E5%A4%87-20246966-ff1485?style=flat&amp;logo=Bitwarden" alt=""/></a><!--a.github-badge(target='_blank' href="https://bitiful.dogecast.com/buckets" style='margin-inline:5px' title="本网站经Service Worker分流至缤纷云对象存储")img(src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt='') 
--><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src=" https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.xing-ye.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.xing-ye.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script><script>function loadGiscus () {
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  const config = Object.assign({
    src: 'https://giscus.app/client.js',
    'data-repo': 'XINGYE391/xingye391.github.io',
    'data-repo-id': 'R_kgDOLq6oog',
    'data-category-id': 'DIC_kwDOLq6oos4Ce2T-',
    'data-mapping': 'pathname',
    'data-theme': nowTheme,
    'data-reactions-enabled': '1',
    crossorigin: 'anonymous',
    async: true
  },null)

  let ele = document.createElement('script')
  for (let key in config) {
    ele.setAttribute(key, config[key])
  }
  document.getElementById('giscus-wrap').insertAdjacentElement('afterbegin',ele)
}

function changeGiscusTheme () {
  const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  function sendMessage(message) {
    const iframe = document.querySelector('iframe.giscus-frame');
    if (!iframe) return;
    iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }

  sendMessage({
    setConfig: {
      theme: theme
    }
  });
}

if ('Twikoo' === 'Giscus' || !true) {
  if (true) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
  else loadGiscus()
} else {
  function loadOtherComment () {
    loadGiscus()
  }
}</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="//at.alicdn.com/t/c/font_4506396_r2fapg82tn8.js"></script><script async src="//at.alicdn.com/t/c/font_4506285_lb3ur628yh9.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><script src="/zhheo/random.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["link[rel=\"canonical\"]","meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://blog.xing-ye.top/categories/博客/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 XINGYEの博客教程 (7)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://blog.xing-ye.top/categories/学习笔记/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 XINGYEの学习笔记 (18)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://blog.xing-ye.top/categories/算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 XINGYEの算法之路 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://blog.xing-ye.top/categories/实用工具/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🔧 XINGYEの实用工具 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://blog.xing-ye.top/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c681026a/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://t.mwm.moe/fj/?postId=1" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-28</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c681026a/&quot;);" href="javascript:void(0);" alt="">Redis实战篇——黑马点评</a><div class="blog-slider__text">Redis实战篇</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c681026a/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ae1c1b1b/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://t.mwm.moe/fj/?postId=3" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-07</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ae1c1b1b/&quot;);" href="javascript:void(0);" alt="">建站小记基础篇</a><div class="blog-slider__text">建站小记基础篇</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ae1c1b1b/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '06588af4d4e84f368f4bd373e0142725';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '121.482075,38.923897';
  var clock_default_rectangle_enable = 'true';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>